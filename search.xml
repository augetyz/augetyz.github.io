<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一键超频</title>
    <url>/2023/09/29/a-chao-pin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696776023223.png" alt="引入.png"></p>
<h1 id="一键超频"><a href="#一键超频" class="headerlink" title="一键超频"></a>一键超频</h1><h2 id="实现目的"><a href="#实现目的" class="headerlink" title="实现目的"></a>实现目的</h2><p>单片机超频的主要目的是提高处理器的工作速度，以获得更高的性能和处理能力。超频可以使单片机在特定的应用场景下执行更多的指令，加快数据处理和运行速度，从而提升整体系统性能。</p>
<p>芯片超频能做什么：</p>
<ol>
<li>加快运算速度：超频可以使单片机在相同的时间内执行更多的指令，从而加快程序的运行速度。</li>
<li>提高响应速度：对于一些需要实时响应的应用，超频可以减少处理器的响应时间，使系统更加敏捷和快速响应外部事件。</li>
<li>处理更复杂的任务：通过超频，单片机可以处理更大规模、更复杂的任务，例如高清视频处理、实时图像处理等。</li>
<li>提高系统性能：在某些应用场景下，超频可以提高整个系统的性能，使其能够更好地满足需求。</li>
</ol>
<p>在获取更高的运算速度的同时，超频也会引入更高的功耗和温度，有可能导致稳定性问题。因此，在进行超频操作时，不建议将芯片主频过分提高，同时需要谨慎注意系统的工作环境和散热条件，以确保系统的安全和可靠性。</p>
<h2 id="时钟树"><a href="#时钟树" class="headerlink" title="时钟树"></a>时钟树</h2><hr>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696776057961.png" alt="时钟树"></p>
<p>上图为STM32F401的时钟树，本节主要分析芯片总线的时钟逻辑。</p>
<h3 id="时钟输入"><a href="#时钟输入" class="headerlink" title="时钟输入"></a>时钟输入</h3><p>HSE时钟，即高速的外部时钟。</p>
<p>来源：有源晶振（ 1-50M）、无源晶振（ 4-26M）</p>
<p>特点：能够提供高精度、稳定的时钟信号，频率可调，适用于高性能应用。依赖于外部晶体振荡器，可能受到外部环境和干扰的影响，需要额外的硬件支持以及较好的电磁兼容设计，较高的功耗。</p>
<p>HSI时钟，即高速的内部时钟。</p>
<p>来源：芯片内部，大小为16M，当HSE故障时，系统时钟会自动<br>切换到HSI，直到HSE启动成功。</p>
<p>特点：时钟精度相对较低，不适用于高性能和高精度的应用。</p>
<p>在实际应用中，一般均选用HSE时钟作为芯片总线时钟输入源。</p>
<h3 id="锁相环时钟"><a href="#锁相环时钟" class="headerlink" title="锁相环时钟"></a>锁相环时钟</h3><p>锁相环时钟（PLL）是一种常用的时钟源和时钟倍频器，主要用于提供高频率的时钟信号。锁相环时钟能够提供高精度的时钟源，锁相环时钟可以通过倍频器将输入的参考时钟信号（HSE/HSI）进行倍频，生成更高频率的时钟信号，使单片机可以以更高的时钟频率运行，提供更高的计算和数据处理能力。其次，锁相环时钟可以作为单片机内部各个外设的主时钟源。通过将锁相环时钟与外设和处理器的时钟信号同步，可以确保它们以相同的基准进行工作，实现数据的准确同步和协调操作。</p>
<p>主 PLL 有两路的时钟输出，第一个输出时钟 PLLCLK 用于系统时钟， F407 里面最高是 168M，第二个输出用于 USB OTG FS 的时钟（48M）、 RNG 和 SDIO 时钟（&lt;=48M）。专用的 PLLI2S 用于生成精确时钟，给 I2S 提供时钟。</p>
<p>HSE 或者 HSI 经过 PLL 时钟输入分频因子 M（2<del>63）分频后，成为 VCO 的时钟输入， VCO 的时钟必须在 1</del>2M 之间，一般将VCO 输入时钟配置为1M。</p>
<p>VCO 输入时钟经过 VCO 倍频因子 N 倍频之后，成为 VCO 时钟输出， VCO 时钟必须在 192~432M之间。若配置 N 为336，则 VCO 的输出时钟等于 336M。如果要把系统时钟超频，就得在 VCO 倍频系数 N 这里进行改动。</p>
<p>VCO 输出时钟之后有三个分频因子，锁相环时钟经PLLCLK 分频因子p输出到系统时钟， p 可以取值 2、 4、 6、 8, 将配置为 4，则得到PLLCLK=84M。 </p>
<p>tips：<br>以我使用的F401核心板为例，HSE为12M晶振，使 PLL_M = 12,PLL_N = 336,PLL_P = 4,得到系统时钟输入为84MHz。此为正常情况下系统时钟的最大输入值。通过修改PLL_N的值，使系统时钟输出超过84MHz即为超频。</p>
<p>SYSCLK = HSE / PLL_M * PLL_N / PLL_P</p>
<h3 id="系统时钟"><a href="#系统时钟" class="headerlink" title="系统时钟"></a>系统时钟</h3><p>系统时钟来源可以是： HSI、 PLLCLK、 HSE，具体的由时钟配置寄存器 RCC_CFGR 的 SW 位配置。上述操作系统时钟配置为： SYSCLK = PLLCLK =84M。如果系统时钟是由 HSE 经过 PLL 倍频之后的 PLLCLK 得到，当 HSE 出现故障的时候，系统时钟会切换为 HSI=16M，直到 HSE 恢复正常为止。</p>
<h3 id="总线时钟"><a href="#总线时钟" class="headerlink" title="总线时钟"></a>总线时钟</h3><h4 id="AHB总线时钟："><a href="#AHB总线时钟：" class="headerlink" title="AHB总线时钟："></a>AHB总线时钟：</h4><p>系统时钟 SYSCLK 经过 AHB 预分频器分频之后得到时钟叫 AHB 总线时钟，即 HCLK，分频因子可以是:[1,2,4， 8， 16， 64， 128，256， 512]，具体的由时钟配置寄存器 RCC_CFGR 的 HPRE 位设置。片上大部分外设的时钟都是经过 HCLK 分频得到。</p>
<h4 id="APB总线时钟："><a href="#APB总线时钟：" class="headerlink" title="APB总线时钟："></a>APB总线时钟：</h4><ol>
<li>APB2总线时钟：</li>
</ol>
<p>PCLK2 由 HCLK 经过高速 APB2 预分频器得到，分频因子可以是:[1,2,4， 8， 16]。PCLK2 属于高速的总线时钟，片上高速的外设挂载到这条总线上。</p>
<ol start="2">
<li>APB1总线时钟</li>
</ol>
<p>APB1 总线时钟 PCLK1 由 HCLK 经过低速 APB 预分频器得到，分频因子可以是:[1,2,4， 8， 16]。 PCLK1 属于低速的总线时钟，片上低速的外设挂载到这条总线上，</p>
<hr>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696776074841.png" alt="CubeMX配置的时钟"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696776093984.png" alt="源码中时钟配置的默认参数"></p>
<p>至此，已经完成对片上总线时钟的输入输出的溯源，下面进行相应代码的编写。</p>
<hr>
<p>Tips:</p>
<h2 id="这里插入部分STM32的启动文件的部分介绍，启动文件由汇编编写，是系统上电复位后第一个执行的程序。主要做了以下工作：1-初始化堆栈指针-SP-initial-sp2-初始化-PC-指针-Reset-Handler3-初始化中断向量表4-配置系统时钟-（SystemInit函数）5-调用-C-库函数-main-初始化用户堆栈，从而最终调用-main-函数去到-C-的世界"><a href="#这里插入部分STM32的启动文件的部分介绍，启动文件由汇编编写，是系统上电复位后第一个执行的程序。主要做了以下工作：1-初始化堆栈指针-SP-initial-sp2-初始化-PC-指针-Reset-Handler3-初始化中断向量表4-配置系统时钟-（SystemInit函数）5-调用-C-库函数-main-初始化用户堆栈，从而最终调用-main-函数去到-C-的世界" class="headerlink" title="这里插入部分STM32的启动文件的部分介绍，启动文件由汇编编写，是系统上电复位后第一个执行的程序。主要做了以下工作：1. 初始化堆栈指针 SP=_initial_sp2. 初始化 PC 指针 =Reset_Handler3. 初始化中断向量表4. 配置系统时钟 （SystemInit函数）5. 调用 C 库函数 _main 初始化用户堆栈，从而最终调用 main 函数去到 C 的世界
   "></a>这里插入部分STM32的启动文件的部分介绍，启动文件由汇编编写，是系统上电复位后第一个执行的程序。主要做了以下工作：<br>1. 初始化堆栈指针 SP=_initial_sp<br>2. 初始化 PC 指针 =Reset_Handler<br>3. 初始化中断向量表<br>4. 配置系统时钟 （SystemInit函数）<br>5. 调用 C 库函数 _main 初始化用户堆栈，从而最终调用 main 函数去到 C 的世界
   </h2><p>根据程序的执行顺序，在程序来到main函数之前，SystemInit()函数已经完成对系统时钟的初始化（SystemInit()在system_stm32f4xx.c中定义），如果想修改系统时钟，可自行编写程序修改，重新设置系统时钟，同时可以选择使用HSE还是HSI。</p>
<p>注意 ：由于在 PLL 使能后主 PLL 配置参数便不可更改，而系统上电后会自动进行初始化，因此在对HES重新初始化之前，需要将system_stm32f4xx.c中的line514：SetSysClock();注释掉,否则HSE重新初始化之后不生效。</p>
<p>将SetSysClock()注释之后可以仿照该函数编写自己的时钟初始化函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token keyword">void</span> <span class="token function">HSE_SetSysClock</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> PLLM<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> PLLN<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> PLLP<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> PLLQ<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>

    ErrorStatus HSE_ErrorStatus<span class="token operator">=</span>ERROR<span class="token punctuation">;</span>
	<span class="token comment">/* 复位RCC的所有寄存器 */</span>
    <span class="token function">RCC_DeInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">/* 使能 HSE */</span>
    <span class="token function">RCC_HSEConfig</span><span class="token punctuation">(</span>RCC_HSE_ON<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">/* 等待HSE启动 */</span>
	HSE_ErrorStatus<span class="token operator">=</span><span class="token function">RCC_WaitForHSEStartUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>HSE_ErrorStatus<span class="token operator">==</span>SUCCESS<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">/* 选择电压调节器的模式为1 */</span>
		RCC<span class="token operator">-&gt;</span>APB1ENR <span class="token operator">|=</span> RCC_APB1ENR_PWREN<span class="token punctuation">;</span>
		PWR<span class="token operator">-&gt;</span>CR <span class="token operator">|=</span> PWR_CR_VOS<span class="token punctuation">;</span>
		
		<span class="token comment">/* 配置三个总线的分频因子 */</span>
		<span class="token function">RCC_HCLKConfig</span><span class="token punctuation">(</span>RCC_SYSCLK_Div1<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//AHB总线  1 分频</span>
		<span class="token function">RCC_PCLK1Config</span><span class="token punctuation">(</span>RCC_HCLK_Div2<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//APB1总线 2 分频</span>
		<span class="token function">RCC_PCLK2Config</span><span class="token punctuation">(</span>RCC_HCLK_Div1<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//APB2总线 1 分频</span>
		
		<span class="token comment">/* 配置主PLL */</span>
		<span class="token function">RCC_PLLConfig</span><span class="token punctuation">(</span>RCC_PLLSource_HSE<span class="token punctuation">,</span> PLLM<span class="token punctuation">,</span> PLLN<span class="token punctuation">,</span> PLLP<span class="token punctuation">,</span> PLLQ<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">/* 使能主PLL */</span>
		<span class="token function">RCC_PLLCmd</span><span class="token punctuation">(</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">/* 等待主PLL稳定 */</span>
    	<span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token function">RCC_GetFlagStatus</span><span class="token punctuation">(</span>RCC_FLAG_PLLRDY<span class="token punctuation">)</span> <span class="token operator">==</span> RESET <span class="token punctuation">)</span>
		<span class="token punctuation">{</span><span class="token punctuation">}</span>	

		<span class="token comment">/* 配置FLASH预取指，指令缓存，数据缓存，等待周期 */</span>
        FLASH<span class="token operator">-&gt;</span>ACR <span class="token operator">=</span> FLASH_ACR_PRFTEN <span class="token operator">|</span> FLASH_ACR_ICEN <span class="token operator">|</span>FLASH_ACR_DCEN <span class="token operator">|</span>FLASH_ACR_LATENCY_5WS<span class="token punctuation">;</span>
		
		<span class="token comment">/* 选择主PLL为系统时钟 */</span>
		<span class="token function">RCC_SYSCLKConfig</span><span class="token punctuation">(</span>RCC_SYSCLKSource_PLLCLK<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">/* 确保主PLL被选为系统时钟 */</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token function">RCC_GetSYSCLKSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span><span class="token number">0x08</span> <span class="token punctuation">)</span>
		<span class="token punctuation">{</span><span class="token punctuation">}</span>
			
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{</span>
		<span class="token comment">/*HES启动失败，在这里添加处理代码*/</span>
	<span class="token punctuation">}</span>

  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>超频实际上是提高芯片总线主频，获取更高的运算速率，超频会对阻塞式延时函数的延时时间造成一定影响（原定延时1s实际延时不足1s），具体效果可以通过LED灯闪烁的快慢体现。</p>
<hr>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696776119362.png" alt="完结撒花"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>F401</tag>
        <tag>时钟树</tag>
        <tag>一键超频</tag>
      </tags>
  </entry>
  <entry>
    <title>串口通讯</title>
    <url>/2023/09/30/b-chuan-kou-tong-xun/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778044589.png" alt="引入"></h2><h1 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯"></a>串口通讯</h1><p>串口通讯 (Serial Communication) 是一种设备间非常常用的串行通讯方式，它简单便捷，并且大部分电子设备都支持该通讯方式，在调试设备时经常使用该通讯方式输出调试信息。</p>
<p>串口协议物理层：<br>TTL电平：</p>
<p>逻辑1：2.4V ~ 5V<br>逻辑0： 0   ~ 0.5V</p>
<p>RS232电平：</p>
<p>逻辑1：-15V ~ -3V<br>逻辑0： +3  ~ +15V</p>
<p>串口协议协议层：</p>
<p>串口通讯的数据包由发送设备通过自身的 TXD 接口传输到接收设备的 RXD 接口。在串口通讯的协议层中，规定了数据包的内容，它由启始位、主体数据、校验位以及停止位组成，通讯双方<br>的数据包格式要约定一致才能正常收发数据。<br>本节主要讲解的是串口异步通讯，异步通讯中由于没有时钟信号 ，所以两个通讯设备之间需要约定好波特率，即每个码元的长度，以便对信号进行解码，下图为串口数据包的基本组成，其中用虚线分开的每一格就是代表一个码元。常见的波特率为9600，115200 等。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778084226.png" alt="串口数据包"></h2><p>STM32 芯片具有多个 USART 外设用于串口通讯，它是 Universal Synchronous Asynchronous Receiver<br>and Transmitter 的缩写，即通用同步异步收发器可以灵活地与外部设备进行全双工数据交换。有别于 USART，它还有具有 UART 外设 (Universal Asynchronous Receiver and Transmitter)，它是在USART 基础上裁剪掉了同步通信功能，只有异步通信。简单区分同步和异步就是看通信时需不<br>需要对外提供时钟输出，我们平时用的串口通信基本都是 UART。</p>
<h3 id="功能引脚"><a href="#功能引脚" class="headerlink" title="功能引脚"></a>功能引脚</h3><p>TX -&gt;   发送数据输出引脚。</p>
<p>RX -&gt;   接收数据输入引脚。</p>
<p>nRTS -&gt; 请求以发送 (Request To Send)， n 表示低电平有效。如果使能 RTS 流控制，当 USART 接收器准备好接收新数据时就会将 nRTS 变成低电平；当接收寄存器已满时， nRTS 将被设置为高电平。该引脚只适用于硬件流控制。</p>
<p>nCTS -&gt; 清除以发送 (Clear To Send)， n 表示低电平有效。如果使能 CTS 流控制，发送器在发送下一帧数据之前会检测 nCTS 引脚，如果为低电平，表示可以发送数据，如果为高电平则在发送完当前数据帧之后停止发送。该引脚只适用于硬件流控制。</p>
<p>SCLK -&gt; 发送器时钟输出引脚。这个引脚仅适用于同步模式。</p>
<h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p>USART 数据寄存器 (USART_DR) 只有低 9 位有效，并且第 9 位数据是否有效要取决于 USART控制寄存器 1(USART_CR1) 的 M 位设置，当 M 位为 0 时表示 8 位数据字长，当 M 位为 1 表示 9位数据字长，一般使用 8 位数据字长。</p>
<p>USART_DR 包含了已发送的数据或者接收到的数据。</p>
<p> USART_DR 实际是包含了两个寄存器，一个专门用于发送的可写 TDR，一个专门用于接收的可读 RDR。当进行发送操作时，往 USART_DR写入数据会自动存储在 TDR 内；当进行读取操作时，向 USART_DR 读取数据会自动提取 RDR数据。</p>
<p>TDR 和 RDR 都是介于系统总线和移位寄存器之间。串行通信是一个位一个位传输的，发送时把TDR 内容转移到发送移位寄存器，然后把移位寄存器数据每一位发送出去，接收时把接收到的<br>每一位顺序保存在接收移位寄存器内然后才转移到 RDR。</p>
<h3 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h3><p>USART 有多个中断请求，可以根据相应标志位判断当前状态。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778122019.png" alt="串口中断"></p>
<p>下面为USART2的初始化，波特率配置为115200，8字长，无校验，1停止位</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">USART2_Config</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">/* 第一步：初始化GPIO */</span>
	GPIO_InitTypeDef  GPIO_InitStructure<span class="token punctuation">;</span>
	USART_InitTypeDef USART_InitStructure<span class="token punctuation">;</span>
	
	<span class="token function">RCC_AHB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_AHB1Periph_GPIOA<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_OType <span class="token operator">=</span> GPIO_OType_PP<span class="token punctuation">;</span>
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_PuPd <span class="token operator">=</span> GPIO_PuPd_UP<span class="token punctuation">;</span>  
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>
  
    <span class="token comment">/* 配置Tx  --  PA9引脚为复用功能  */</span>
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_AF<span class="token punctuation">;</span>
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_2<span class="token punctuation">;</span>  
    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* 配置Rx  --  PA10引脚为复用功能 */</span>
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_3<span class="token punctuation">;</span>
    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">/* 配置GPIO的第二功能 */</span>
	 <span class="token comment">/* 连接 PA10 到 USARTx_Tx*/</span>
    <span class="token function">GPIO_PinAFConfig</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span>GPIO_PinSource3<span class="token punctuation">,</span>GPIO_AF_USART2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/*  连接 PA9 到 USARTx__Rx*/</span>
    <span class="token function">GPIO_PinAFConfig</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span>GPIO_PinSource2<span class="token punctuation">,</span>GPIO_AF_USART2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">/* 第二步：配置串口初始化结构体 */</span>
	
	 <span class="token comment">/* 使能 USART 时钟 */</span>
    <span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_USART2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">/* 配置 USART2  */</span>
    <span class="token comment">/* 波特率设置：DEBUG_USART_BAUDRATE */</span>
    USART_InitStructure<span class="token punctuation">.</span>USART_BaudRate <span class="token operator">=</span> <span class="token number">115200</span><span class="token punctuation">;</span><span class="token comment">//串口波特率</span>
    <span class="token comment">/* 字长(数据位+校验位)：8 */</span>
    USART_InitStructure<span class="token punctuation">.</span>USART_WordLength <span class="token operator">=</span> USART_WordLength_8b<span class="token punctuation">;</span>
    <span class="token comment">/* 停止位：1个停止位 */</span>
    USART_InitStructure<span class="token punctuation">.</span>USART_StopBits <span class="token operator">=</span> USART_StopBits_1<span class="token punctuation">;</span>
    <span class="token comment">/* 校验位选择：不使用校验 */</span>
    USART_InitStructure<span class="token punctuation">.</span>USART_Parity <span class="token operator">=</span> USART_Parity_No<span class="token punctuation">;</span>
    <span class="token comment">/* 硬件流控制：不使用硬件流 */</span>
    USART_InitStructure<span class="token punctuation">.</span>USART_HardwareFlowControl <span class="token operator">=</span> USART_HardwareFlowControl_None<span class="token punctuation">;</span>
    <span class="token comment">/* USART模式控制：同时使能接收和发送 */</span>
    USART_InitStructure<span class="token punctuation">.</span>USART_Mode <span class="token operator">=</span> USART_Mode_Rx <span class="token operator">|</span> USART_Mode_Tx<span class="token punctuation">;</span>
    <span class="token comment">/* 完成USART初始化配置 */</span>
    <span class="token function">USART_Init</span><span class="token punctuation">(</span>USART2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>USART_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	
	<span class="token comment">/* 第三步：配置串口的接收中断 */</span>
    <span class="token comment">/* 嵌套向量中断控制器NVIC配置 */</span>
	<span class="token function">NVIC_Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*使能串口接收中断 */</span>
	<span class="token function">USART_ITConfig</span><span class="token punctuation">(</span>USART2<span class="token punctuation">,</span> USART_IT_RXNE<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
    <span class="token comment">/* 第四步：使能串口 */</span>
    <span class="token function">USART_Cmd</span><span class="token punctuation">(</span>USART2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">NVIC_Configuration</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    NVIC_InitTypeDef NVIC_InitStructure<span class="token punctuation">;</span>
    
    <span class="token comment">/* 嵌套向量中断控制器组选择 */</span>
    <span class="token function">NVIC_PriorityGroupConfig</span><span class="token punctuation">(</span>NVIC_PriorityGroup_2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">/* 配置USART1为中断源 */</span>
    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannel <span class="token operator">=</span> USART2_IRQn<span class="token punctuation">;</span>
    <span class="token comment">/* 抢断优先级为1 */</span>
    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelPreemptionPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">/* 子优先级为1 */</span>
    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelSubPriority <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">/* 使能中断 */</span>
    NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span>
    <span class="token comment">/* 初始化配置NVIC */</span>
    <span class="token function">NVIC_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>NVIC_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="完成串口初始化之后，开始着手处理WT1-IMU发送的数据。"><a href="#完成串口初始化之后，开始着手处理WT1-IMU发送的数据。" class="headerlink" title="完成串口初始化之后，开始着手处理WT1-IMU发送的数据。"></a>完成串口初始化之后，开始着手处理WT1-IMU发送的数据。</h2><h3 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h3><p>补充一下，为什么要使用数据帧进行通讯</p>
<p>串口通信虽然简单方便，但实际使用时会发现需要传输数据的不止1个字节，往往需要传输多个字节组成的数据包，由于串口通信中字节之间相互独立，在传输多个字节的数据时，将面临以下问题：</p>
<ul>
<li>接收端从串口接收的是字节流，那它是如何知道帧的开始或结束呢？它又是如何知道这个帧有多长？</li>
<li>真实的物理硬件是充满噪音和干扰的，由于电噪声，某些字节的位可能被翻转，字节甚至整个帧都可能会丢失。</li>
</ul>
<p>串口通信虽然简单方便，但实际使用时会发现需要传输数据的不止1个字节，往往需要传输多个字节组成的数据包，而因为串口通信中字节之间相互独立，在接收数据时面临“数据包对齐”和“防止数据出错”两大问题。</p>
<p>数据包对齐在也叫数据帧同步。解决方法就是引入帧同步字节，也就是增加帧头、帧尾等，对于固定长度数据帧通信可以只使用帧头帧尾，对于可变长度数据帧通信还需引入描述帧长的字节。利用帧头、帧尾、帧长即可解决。</p>
<p>防止数据出错也叫差错控制。在通信原理中，有四种差错控制方法：检错重发、前向纠错、反馈校验、检错删除。四种差错控制方法各有其优缺点，一般采用检错删除的差错控制算法，故只需要考虑如何检错这一个问题，常用的方法是在数据帧中增加校验字节。</p>
<hr>
<p><a href="https://wit-motion.yuque.com/wumwnr/ltst03/wegquy#%20%E3%80%8AWT61%E5%8D%8F%E8%AE%AE%E3%80%8B">WT1-IMU的通讯协议</a></p>
<p>首先浏览WT1-IMU的通讯协议文档，从中可知：</p>
<pre><code>1.单帧的数据格式
</code></pre>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778287562.png" alt="B-IMU数据帧格式"><br>    2.数据的发送格式<br>    一次发送三帧数据，由二级帧头TYPE区分（我习惯称之为功能字），最终得到的有效数据为9个short类型的数据。</p>
<p>理清通讯协议之后，开始进行串口接收部分的代码编写。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//IMU数据结构体</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{</span>
    s16 acceleration_X<span class="token punctuation">;</span>
    s16 acceleration_Y<span class="token punctuation">;</span>
    s16 acceleration_Z<span class="token punctuation">;</span><span class="token comment">//三轴加速度</span>
    s16 angular_velocity_X<span class="token punctuation">;</span>
    s16 angular_velocity_Y<span class="token punctuation">;</span>
    s16 angular_velocity_Z<span class="token punctuation">;</span><span class="token comment">//三轴角速度</span>
    s16 Roll<span class="token punctuation">;</span>
    s16 Pitch<span class="token punctuation">;</span>
    s16 Yaw<span class="token punctuation">;</span><span class="token comment">//三轴角度</span>
<span class="token punctuation">}</span>IMU_Data<span class="token punctuation">;</span>

u8 Data_Buf<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//串口接收缓冲区</span>
IMU_Data IMU_DATA<span class="token punctuation">;</span>


<span class="token comment">//串口接收中断</span>
<span class="token keyword">void</span> <span class="token function">USART2_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">uint8_t</span> ucTemp<span class="token punctuation">;</span>

	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">USART_GetITStatus</span><span class="token punctuation">(</span>USART2<span class="token punctuation">,</span>USART_IT_RXNE<span class="token punctuation">)</span><span class="token operator">!=</span>RESET<span class="token punctuation">)</span><span class="token comment">//获取标志位</span>
	<span class="token punctuation">{</span>		
		ucTemp <span class="token operator">=</span> <span class="token function">USART_ReceiveData</span><span class="token punctuation">(</span> USART2 <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读取数据</span>
        <span class="token function">Data_ByteGet</span><span class="token punctuation">(</span>ucTemp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>	 
<span class="token punctuation">}</span>


<span class="token keyword">void</span> <span class="token function">Data_ByteGet</span><span class="token punctuation">(</span>u8 data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> u8 pos<span class="token punctuation">;</span>
    
    Data_Buf<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>
    
    <span class="token keyword">if</span><span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Data_Buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0x55</span><span class="token punctuation">)</span><span class="token comment">//帧头判断</span>
        <span class="token punctuation">{</span>
            pos<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            pos<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>Data_Buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> acceleration<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>Data_Buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> angular_velocity<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>Data_Buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> angle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//功能字</span>
        <span class="token punctuation">{</span>
            pos<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            pos<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pos <span class="token operator">&gt;=</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> pos <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        pos<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//数据域</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">//数据和校验比对</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Data_Buf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token function">SUMCRC</span><span class="token punctuation">(</span>Data_Buf<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">//校验通过，开始对数据进行处理</span>
            <span class="token function">Data_Analysis</span><span class="token punctuation">(</span>Data_Buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>


<span class="token comment">/**
  * @brief  和校验计算函数
  * @param  data_buf -&gt; 待计算的数组地址 lenth -&gt; 数组中待累加元素个数
  * @retval 校验和的低8位
  */</span>
u8 <span class="token function">SUMCRC</span><span class="token punctuation">(</span>u8<span class="token operator">*</span> data_buf<span class="token punctuation">,</span>u8 lenth<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    u8 i<span class="token punctuation">;</span>
    u8 ret<span class="token punctuation">;</span>
    
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>lenth<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ret <span class="token operator">+=</span> data_buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">void</span> <span class="token function">Data_Analysis</span><span class="token punctuation">(</span>u8<span class="token operator">*</span> Buf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> acceleration<span class="token punctuation">)</span><span class="token comment">//加速度帧</span>
    <span class="token punctuation">{</span>
        IMU_DATA<span class="token punctuation">.</span>acceleration_X<span class="token operator">=</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>Buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>Buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token operator">/</span><span class="token number">32768</span><span class="token operator">*</span><span class="token number">16</span><span class="token operator">*</span><span class="token number">9.8</span><span class="token punctuation">;</span>
        IMU_DATA<span class="token punctuation">.</span>acceleration_Y<span class="token operator">=</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>Buf<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>Buf<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token operator">/</span><span class="token number">32768</span><span class="token operator">*</span><span class="token number">16</span><span class="token operator">*</span><span class="token number">9.8</span><span class="token punctuation">;</span>
        IMU_DATA<span class="token punctuation">.</span>acceleration_Z<span class="token operator">=</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>Buf<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>Buf<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token operator">/</span><span class="token number">32768</span><span class="token operator">*</span><span class="token number">16</span><span class="token operator">*</span><span class="token number">9.8</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>Buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> angular_velocity<span class="token punctuation">)</span><span class="token comment">//角速度帧</span>
    <span class="token punctuation">{</span>
        IMU_DATA<span class="token punctuation">.</span>angular_velocity_X<span class="token operator">=</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>Buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>Buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768</span><span class="token operator">*</span><span class="token number">2000</span><span class="token punctuation">;</span>
        IMU_DATA<span class="token punctuation">.</span>angular_velocity_Y<span class="token operator">=</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>Buf<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>Buf<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span>  <span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768</span><span class="token operator">*</span><span class="token number">2000</span><span class="token punctuation">;</span>
        IMU_DATA<span class="token punctuation">.</span>angular_velocity_Z<span class="token operator">=</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>Buf<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>Buf<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768</span><span class="token operator">*</span><span class="token number">2000</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>Buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> angle<span class="token punctuation">)</span><span class="token comment">//角度帧</span>
    <span class="token punctuation">{</span>
        IMU_DATA<span class="token punctuation">.</span>Roll<span class="token operator">=</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>Buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>Buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768</span><span class="token operator">*</span><span class="token number">180</span><span class="token punctuation">;</span>
        IMU_DATA<span class="token punctuation">.</span>Pitch<span class="token operator">=</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>Buf<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>Buf<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768</span><span class="token operator">*</span><span class="token number">180</span><span class="token punctuation">;</span>
        IMU_DATA<span class="token punctuation">.</span>Yaw<span class="token operator">=</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>Buf<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>Buf<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768</span><span class="token operator">*</span><span class="token number">180</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p>至此，对WT1-IMU的数据接收已经完成，接下来可以在main.c中将IMU的数据输出到上位机，以此检验串口数据帧的接收。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用串口通过数据帧进行多数据的交互在实际应用中相当常见。串口数据帧的结构相对简单，易于实现和解析，可自行设置数据长度以适应不同数据长度的需求，适用性广泛。</p>
<hr>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778157853.png" alt="串口总结"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>F401</tag>
        <tag>串口通讯</tag>
        <tag>协议帧</tag>
      </tags>
  </entry>
  <entry>
    <title>Keil5的魔法棒选项简介</title>
    <url>/2023/10/01/c-keil5-de-mo-fa-bang-jian-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<h1 id="Keil5的魔法棒选项简介"><a href="#Keil5的魔法棒选项简介" class="headerlink" title="Keil5的魔法棒选项简介"></a>Keil5的魔法棒选项简介</h1><h2 id="Device"><a href="#Device" class="headerlink" title="Device"></a>Device</h2><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778460206.png" alt="Device"></p>
<p>这个页面功能较为简单，左上方分别显示供应商、芯片类型、工具集，右上方pack为当前使用的芯片包的版本号，URL为arm芯片包的下载地址（魔法上网访问）。中间带有一个搜索框可供检索。下方左侧是目前支持的芯片列表，右侧为该系列芯片资源的英文简介。</p>
<h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778479212.png" alt="Target"></p>
<p>在这个界面中有很多配置信息。<br>Xtal:为当前工程使用的晶振频率</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778525728.png" alt="代码生成区"><br>ARM Compiler:编译器版本<br>下方两个选项分别为：</p>
<ul>
<li>是否使用跨模块优化</li>
<li>是否使用MicroLIB</li>
</ul>
<hr>
<p><strong>tips：</strong><br>MicroLib是一个针对用C编写的基于ARM的嵌入式应用程序的高度优化的库。与包含在ARM编译器工具链中的标准C库相比，MicroLib提供了许多嵌入式系统所需的代码大小的显著优势。</p>
<p>MicroLib和标准C库之间的主要区别是:</p>
<p>1、MicroLib是专为深度嵌入式应用程序而设计的。</p>
<p>2、MicroLib经过优化，比使用ARM标准库使用更少的代码和数据内存。</p>
<p>3、MicroLib被设计成在没有操作系统的情况下工作，但是这并不妨碍它与任何操作系统或RTOS一起使用，如Keil RTX。</p>
<p>4、MicroLib不包含文件I/O或宽字符支持。</p>
<p>5、由于MicroLib已经优化到最小化代码大小，一些函数将比ARM编译工具中可用的标准C库例程执行得更慢。</p>
<p>6、MicroLib和ARM标准库都包含在Keil MDK-ARM中。</p>
<hr>
<p> MicroLIB是一个c语言标准库，它编译出来的固件相比标准C库的固件更小一点，当然性能相对差一些，如果是程序存储空间比较紧张的情况下可以将这个选项打勾。</p>
<p> PS：</p>
<hr>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778676996.png" alt="内存读写区"><br> 左侧通俗点讲是程序指令和只读数据存储区的配置，startup代表程序入口地址所在的区域，左边一般配置为Flash、OTP等存储器挂载在总线上的地址区域，当然我们的程序也可以执行在RAM中，所以左边也可以配置为RAM所在的总线地址区间。右边通俗讲是可读写数据存储的区域，例如栈和堆以及程序中的可读写全局变量，这一块的配置一般在RAM上所以一般配置为RAM所在总线的地址区间。另外，如果我们有多块存储器挂载在总线上时也可以配置多块。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778695180.png" alt="OUTPUT"></p>
<p>输出界面。</p>
<p>包括生成的可执行文件的名称，存储路径(均可修改)。</p>
<h2 id="以及：-是否生成调试信息-是否生成hex文件-是否生成浏览信息-是否生成批处理文件-是否创建库文件"><a href="#以及：-是否生成调试信息-是否生成hex文件-是否生成浏览信息-是否生成批处理文件-是否创建库文件" class="headerlink" title="以及：- 是否生成调试信息- 是否生成hex文件- 是否生成浏览信息- 是否生成批处理文件- 是否创建库文件"></a>以及：<br>- 是否生成调试信息<br>- 是否生成hex文件<br>- 是否生成浏览信息<br>- 是否生成批处理文件<br>- 是否创建库文件</h2><ul>
<li>Creat HEX ile:</li>
</ul>
<p>可执行文件（用于下载到芯片的程序文件），.hex文件一般用于在无法进行仿真器烧录代码的时候使用，通过串口在Boot模式下将代码烧录至芯片。</p>
<ul>
<li>Browse Information:</li>
</ul>
<p>勾选后会生成.crf文件，便于调试，但会使工程编译速度变慢</p>
<p>.crf：浏览信息文件，使用Go to Definition Of(F12) 功能，就需要有这类文件。</p>
<h2 id="Listing"><a href="#Listing" class="headerlink" title="Listing"></a>Listing</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778724401.png" alt="Listing"></h2><p>第一个选项，可以选择生成链接文件的文件夹。<br>其余配置一般默认。</p>
<h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778760780.png" alt="C-C++"></h2><ul>
<li><p>Preprocessor Symbols:<br>预处理符号，在这里进行的Define/Undefine具有全局属性。</p>
</li>
<li><p>Language/Code Generation：</p>
<p>   <strong>Optimization:</strong> 代码优化，有不同等级可选，配置合适的优化等级将高效的利用编译器的功能对程序进行优化，可以大大提高程序的效率以及对存储的优化。有时优化会带来程序的bug，有时候优化后不是实际想要的结果，这需要在使用的过程中积累经验。</p>
<p>   <strong>C99 Mode：</strong></p>
<p>   <strong>在C99中包括的特性有：</strong></p>
<p>   增加了对编译器的限制，比如源程序每行要求至少支持到 4095 字节，变量名函数名的要求支持到 63 字节（extern 要求支持到 31）。</p>
<p>   增强了预处理功能。例如：<br>   宏支持取可变参数 #define Macro(…) <strong>VA_ARGS</strong><br>   使用宏的时候，允许省略参数，被省略的参数会被扩展成空串。</p>
<p>   支持 // 开头的单行注释（这个特性实际上在C89的很多编译器上已经被支持了）<br>   增加了新关键字 restrict, inline, _Complex, _Imaginary, _Bool<br>   支持 long long, long double _Complex, float _Complex 等类型</p>
<p>   支持不定长的数组，即数组长度可以在运行时决定，比如利用变量作为数组长度。声明时使用 int a[var] 的形式。不过考虑到效率和实现，不定长数组不能用在全局，或 struct 与 union 里。</p>
<p>   变量声明不必放在语句块的开头，for 语句提倡写成 for(int i=0;i&lt;100;++i) 的形式，即i 只在 for 语句块内部有效。</p>
</li>
</ul>
<p>使用 C99 Mode 时需要考虑兼容性和可移植性问题。</p>
<ul>
<li><p>Include Paths:</p>
<p>   在这里需要添加工程中包含的头文件路径。</p>
</li>
</ul>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778787505.png" alt="Debug"></h2><p>这个页面主要跟调试有关，这部分的功能在我们日常工作中经常会使用。如果可以灵活使用这部分的功能在工作中可以达到事半功倍的效果。左边是软件仿真调试配置，右边是硬件仿真调试配置。</p>
<p>两个复选use选项，二选一。我一般使用DAP_link仿真器（便宜），性能一般，支持的断点数目较少。</p>
<ul>
<li><p>仿真器选型<br>下拉选项，可以根据需要选择不同的仿真器。</p>
</li>
<li><p>Load Application at Startup是指跳转到启动文件开始执行。</p>
</li>
<li><p>Run to main()是指开始调试时程序的指针位置main()函数的第一条指令处。</p>
</li>
<li><p>Initialization File:用户自定义地址,能够使开始调试时程序的指针跳转到指定位置</p>
<p><a href="https://blog.csdn.net/u014783785/article/details/92581102">详细内容参考此博客</a></p>
</li>
</ul>
<hr>
<ul>
<li>setting</li>
</ul>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778826246.png" alt="Setting"><br>在这个界面主要进行下载模式的选择（Port: SW/JTAG）以及最大时钟频率的配置（Max Clock）</p>
<p>如果成功识别到仿真器，SWDIO处会显示该设备的序列号</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778867435.png" alt="FlashDown"></p>
<p><em>Download unction</em></p>
<pre><code> Erase Full Chip：下载程序时对芯片flash进行全片擦除；

 Erase Sectors：下载程序时对芯片flash用到的扇区进行擦除；

 Do not Erase：下载程序时不对flash进行擦除；
</code></pre>
<p>右面是对过程的控制：编程、校验、对芯片复位和运行；</p>
<p>正常情况下建议选择部分擦除，，当遇到芯片锁死的情况建议使用全擦除。</p>
<p><em>RAM Algorithm</em></p>
<p>配置RAM的起始地址和大小。</p>
<p><em>Programming Algorithm</em></p>
<p>flash下载引导算法，这个算法的作用就是可以将数据写到芯片内部或者外部的flash中,选择与芯片flash大小一致的即可。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>keil5的魔法棒有很多功能，用好这些会让开发变得更加简单。这里仅对常用功能作大致介绍，余下部分可以自行探索。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696778886935.png" alt="C结束"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>魔法棒</tag>
      </tags>
  </entry>
  <entry>
    <title>FATFS文件系统常用函数记录</title>
    <url>/2024/08/13/fatfs-wen-jian-xi-tong-han-shu-shi-yong-ji-lu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Fatfs-文件系统函数使用记录"><a href="#Fatfs-文件系统函数使用记录" class="headerlink" title="Fatfs 文件系统函数使用记录"></a>Fatfs 文件系统函数使用记录</h1><p><strong>FatFs 文件系统</strong></p>
<h2 id="1、f-open-打开-创建文件"><a href="#1、f-open-打开-创建文件" class="headerlink" title="1、f_open 打开/创建文件"></a>1、f_open 打开/创建文件</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">FRESULT <span class="token function">f_open</span> <span class="token punctuation">(</span>
    FIL<span class="token operator">*</span> fp<span class="token punctuation">,</span>           <span class="token comment">/* [OUT] Pointer to the file object structure */</span>
    <span class="token keyword">const</span> TCHAR<span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token comment">/* [IN] File name */</span>
    BYTE mode          <span class="token comment">/* [IN] Mode flags */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>参数：</strong></p>
<ul>
<li><code>@fp</code>：文件结构体指针</li>
<li><code>@path</code>：文件路径（文件名）</li>
<li><code>@mode</code>：打开方式</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>成功返回 <code>FR_OK</code>（0），文件对象有效</li>
<li>失败则文件对象无效（NULL）</li>
<li>可能的返回值：<code>FR_OK</code>, <code>FR_DISK_ERR</code>, <code>FR_INT_ERR</code>, <code>FR_NOT_READY</code>, <code>FR_NO_FILE</code>, <code>FR_NO_PATH</code>, <code>FR_INVALID_NAME</code>, <code>FR_DENIED</code>, <code>FR_EXIST</code>, <code>FR_INVALID_OBJECT</code>, <code>FR_WRITE_PROTECTED</code>, <code>FR_INVALID_DRIVE</code>, <code>FR_NOT_ENABLED</code>, <code>FR_NO_FILESYSTEM</code>, <code>FR_TIMEOUT</code>, <code>FR_LOCKED</code>, <code>FR_NOT_ENOUGH_CORE</code>, <code>FR_TOO_MANY_OPEN_FILES</code></li>
</ul>
<p><strong>描述：</strong></p>
<ul>
<li><code>f_open</code> 打开并创建一个文件对象，打开的文件应该在使用后调用 <code>f_close</code> 关闭文件。</li>
<li>如果对文件进行了更改，并且在断电、删除介质或重新挂载前未关闭，则文件可能会崩溃。</li>
<li>只能以读的方式重复打开一个文件，不能以任何具有写模式的方式重复打开一个文件（第二次打开不成功 <code>FR_LOCKED</code>，哪怕第二次是只读、只打开）。</li>
<li>当把 FatFs 配置为只读模式（<code>FF_FS_READONLY == 1</code>）的时候，<code>mode</code> 只能是 <code>FA_READ</code> 和 <code>FA_OPEN_EXISTING</code>。</li>
</ul>
<p><strong>MODE：</strong></p>
<table>
<thead>
<tr>
<th>标志</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><code>FA_READ</code></td>
<td>指定对文件的读取访问权限。可以从文件中读取数据。</td>
</tr>
<tr>
<td><code>FA_WRITE</code></td>
<td>指定对文件的写入权限。数据可以写入文件。与 <code>FA_READ</code> 结合使用以实现读写访问。</td>
</tr>
<tr>
<td><code>FA_OPEN_EXISTING</code></td>
<td>打开文件。如果文件不存在，则该函数将失败。（默认）</td>
</tr>
<tr>
<td><code>FA_CREATE_NEW</code></td>
<td>创建新文件。如果文件存在，则该函数将失败并返回 <code>FR_EXIST</code>。</td>
</tr>
<tr>
<td><code>FA_CREATE_ALWAYS</code></td>
<td>创建新文件。如果该文件存在，它将被截断并覆盖。</td>
</tr>
<tr>
<td><code>FA_OPEN_ALWAYS</code></td>
<td>打开文件（如果存在）。如果没有，将创建一个新文件。</td>
</tr>
<tr>
<td><code>FA_OPEN_APPEND</code></td>
<td>与 <code>FA_OPEN_ALWAYS</code> 相同，只是读/写指针设置在文件的末尾。</td>
</tr>
</tbody></table>
<p><strong>POSIX <code>fopen()</code> 函数中的模式标志对应于 FatFs 模式标志，如下所示：</strong></p>
<table>
<thead>
<tr>
<th>POSIX</th>
<th>FatFs</th>
</tr>
</thead>
<tbody><tr>
<td><code>”r”</code></td>
<td><code>FA_READ</code></td>
</tr>
<tr>
<td><code>”r+”</code></td>
<td><code>FA_READ / FA_WRITE</code></td>
</tr>
<tr>
<td><code>”w”</code></td>
<td><code>FA_CREATE_ALWAYS / FA_WRITE</code></td>
</tr>
<tr>
<td><code>”w+”</code></td>
<td><code>FA_CREATE_ALWAYS / FA_WRITE / FA_READ</code></td>
</tr>
<tr>
<td><code>”a”</code></td>
<td><code>FA_OPEN_APPEND / FA_WRITE</code></td>
</tr>
<tr>
<td><code>”a+”</code></td>
<td><code>FA_OPEN_APPEND / FA_WRITE / FA_READ</code></td>
</tr>
<tr>
<td><code>”wx”</code></td>
<td><code>FA_CREATE_NEW / FA_WRITE</code></td>
</tr>
<tr>
<td><code>”w+x”</code></td>
<td><code>FA_CREATE_NEW / FA_WRITE / FA_READ</code></td>
</tr>
</tbody></table>
<h2 id="2、f-close-关闭文件"><a href="#2、f-close-关闭文件" class="headerlink" title="2、f_close 关闭文件"></a>2、f_close 关闭文件</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">FRESULT <span class="token function">f_close</span> <span class="token punctuation">(</span>
    FIL<span class="token operator">*</span> fp     <span class="token comment">/* [IN] Pointer to the file object */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>参数：</strong></p>
<ul>
<li><code>@fp</code>：文件指针</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li><code>FR_OK</code></li>
<li><code>FR_DISK_ERR</code></li>
<li><code>FR_INT_ERR</code></li>
<li><code>FR_INVALID_OBJECT</code>（double free）</li>
<li><code>FR_TIMEOUT</code></li>
</ul>
<p><strong>描述：</strong></p>
<ul>
<li><code>f_close</code> 函数关闭打开的文件对象。如果文件已更改，则文件的缓存信息将写回卷。函数成功后，文件对象不再有效（在函数中将文件指针置为 0），可以丢弃。</li>
<li>请注意，如果文件对象处于只读模式且未启用 <code>FF_FS_LOCK</code>（限制最大打开数量），则也可以在不执行此过程的情况下丢弃该文件对象。但是，为了将来的兼容性，不建议这样做。</li>
</ul>
<p><strong>使用条件：</strong></p>
<ul>
<li>始终可用</li>
</ul>
<h2 id="3、f-read-从文件中读数据"><a href="#3、f-read-从文件中读数据" class="headerlink" title="3、f_read 从文件中读数据"></a>3、f_read 从文件中读数据</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">FRESULT <span class="token function">f_read</span> <span class="token punctuation">(</span>
    FIL<span class="token operator">*</span> fp<span class="token punctuation">,</span>     <span class="token comment">/* [IN] File object */</span>
    <span class="token keyword">void</span><span class="token operator">*</span> buff<span class="token punctuation">,</span>  <span class="token comment">/* [OUT] Buffer to store read data */</span>
    UINT btr<span class="token punctuation">,</span>    <span class="token comment">/* [IN] Number of bytes to read */</span>
    UINT<span class="token operator">*</span> br     <span class="token comment">/* [OUT] Number of bytes read */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>参数：</strong></p>
<ul>
<li><code>@fp</code>：文件指针</li>
<li><code>@buff</code>：读出数据存放的地址，如果需要快速读出数据则空间应该尽量大</li>
<li><code>@btr</code>：想要读取的数据字节数</li>
<li><code>@br</code>：实际读取的数据字节数。无论函数返回代码如何，此值在函数调用后始终有效。如果返回值等于 <code>btr</code>，则函数返回代码应为 <code>FR_OK</code></li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li><code>FR_OK</code></li>
<li><code>FR_DISK_ERR</code></li>
<li><code>FR_INT_ERR</code></li>
<li><code>FR_DENIED</code></li>
<li><code>FR_INVALID_OBJECT</code></li>
<li><code>FR_TIMEOUT</code></li>
</ul>
<p><strong>描述：</strong></p>
<ul>
<li>读取文件后，文件的读写指针（可以理解为光标）将会向后偏移。</li>
<li>函数执行成功后，如果 <code>*br &lt; btr</code> 则表明文件读取到文件末尾。</li>
</ul>
<p><strong>使用条件：</strong></p>
<ul>
<li>始终可用</li>
</ul>
<h2 id="4、f-write-向文件中写数据"><a href="#4、f-write-向文件中写数据" class="headerlink" title="4、f_write 向文件中写数据"></a>4、f_write 向文件中写数据</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">FRESULT <span class="token function">f_write</span> <span class="token punctuation">(</span>
    FIL<span class="token operator">*</span> fp<span class="token punctuation">,</span>           <span class="token comment">/* [IN] Pointer to the file object structure */</span>
    <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> buff<span class="token punctuation">,</span>  <span class="token comment">/* [IN] Pointer to the data to be written */</span>
    UINT btw<span class="token punctuation">,</span>          <span class="token comment">/* [IN] Number of bytes to write */</span>
    UINT<span class="token operator">*</span> bw           <span class="token comment">/* [OUT] Pointer to the variable to return number of bytes written */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>参数：</strong></p>
<ul>
<li><code>@fp</code>：文件指针</li>
<li><code>@buff</code>：要写入数据的存放地址，如果需要快速写入数据则空间应该尽量大</li>
<li><code>@btw</code>：想要写入的数据字节数</li>
<li><code>@bw</code>：实际写入的数据字节数。无论函数返回代码如何，此值在函数调用后始终有效。如果返回值等于 <code>btw</code>，则函数返回代码应为 <code>FR_OK</code></li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li><code>FR_OK</code></li>
<li><code>FR_DISK_ERR</code></li>
<li><code>FR_INT_ERR</code></li>
<li><code>FR_DENIED</code></li>
<li><code>FR_INVALID_OBJECT</code></li>
<li><code>FR_TIMEOUT</code></li>
</ul>
<p><strong>描述：</strong></p>
<ul>
<li>函数成功后，应检查 <code>*bw</code> 以检测磁盘是否已满。如果 <code>*bw &lt; btw</code>，则表示卷在写入操作期间已满。当卷已满或接近满时，该函数可能需要一段时间。</li>
</ul>
<p><strong>使用条件：</strong></p>
<ul>
<li>当 <code>FF_FS_READONLY == 0</code> 时可用</li>
</ul>
<h2 id="5、f-lseek-重定位"><a href="#5、f-lseek-重定位" class="headerlink" title="5、f_lseek 重定位"></a>5、f_lseek 重定位</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">FRESULT <span class="token function">f_lseek</span> <span class="token punctuation">(</span>
    FIL<span class="token operator">*</span>    fp<span class="token punctuation">,</span>  <span class="token comment">/* [IN] File object */</span>
    FSIZE_t ofs  <span class="token comment">/* [IN] Offset of file read/write pointer to be set */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>参数：</strong></p>
<ul>
<li><code>@fp</code>：文件指针</li>
<li><code>@ofs</code>：文件偏移的字节数（从文件开头计算）。数据类型 <code>FSIZE_t</code> 是 <code>DWORD</code>（32 位）或 <code>QWORD</code>（64 位）（exFAT）的别名，具体取决于 <code>FF_FS_EXFAT</code> 配置选项。</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li><code>FR_OK</code></li>
<li><code>FR_DISK_ERR</code></li>
<li><code>FR_INT_ERR</code></li>
<li><code>FR_INVALID_OBJECT</code></li>
<li><code>FR_TIMEOUT</code></li>
</ul>
<p><strong>描述：</strong></p>
<ul>
<li>如果在写入模式下指定了超出文件大小的偏移量，则文件大小将扩展到指定的偏移量。留下的空间，但是在此过程中并没有写入数据。</li>
<li>若是函数执行成功但是指针却没有偏移，则可能是：<ul>
<li>文件结束。指定的 <code>ofs</code> 以只读模式在文件末尾剪裁。</li>
<li>磁盘已满。卷上没有可用空间来扩展文件。</li>
</ul>
</li>
</ul>
<p><strong>使用条件：</strong></p>
<ul>
<li>当 <code>FF_FS_MINIMIZE &lt;= 2</code> 时可用。要使用快速查找功能，需要将 <code>FF_USE_FASTSEEK</code> 设置为 1 以启用此功能（当 <code>FF_FS_MINIMIZE = 3</code> 时删除了 <code>f_lseek</code>）。</li>
</ul>
<p><strong>宏：</strong></p>
<ul>
<li><code>f_rewind</code>（光标移动到文件开头）函数作为宏：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">f_rewind</span><span class="token expression"><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token function">f_lseek</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h2 id="6、f-truncate-截断文件"><a href="#6、f-truncate-截断文件" class="headerlink" title="6、f_truncate 截断文件"></a>6、f_truncate 截断文件</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">FRESULT <span class="token function">f_truncate</span> <span class="token punctuation">(</span>
    FIL<span class="token operator">*</span> fp     <span class="token comment">/* [IN] File object */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>参数：</strong></p>
<ul>
<li><code>@fp</code>：文件指针</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li><code>FR_OK</code></li>
<li><code>FR_DISK_ERR</code></li>
<li><code>FR_INT_ERR</code></li>
<li><code>FR_DENIED</code>（操作只读函数）</li>
<li><code>FR_INVALID_OBJECT</code></li>
<li><code>FR_TIMEOUT</code></li>
</ul>
<p><strong>描述：</strong></p>
<ul>
<li>将文件截断为当前文件指针所在的大小，如果文件指针指向末尾则不起作用。</li>
</ul>
<p><strong>使用条件：</strong></p>
<ul>
<li>当 <code>FF_FS_READONLY == 0</code> 和 <code>FF_FS_MINIMIZE == 0</code> 时可用。</li>
</ul>
<h2 id="7、f-sync-冲刷数据缓冲区"><a href="#7、f-sync-冲刷数据缓冲区" class="headerlink" title="7、f_sync 冲刷数据缓冲区"></a>7、f_sync 冲刷数据缓冲区</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">FRESULT <span class="token function">f_sync</span> <span class="token punctuation">(</span>
    FIL<span class="token operator">*</span> fp     <span class="token comment">/* [IN] File object */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>参数：</strong></p>
<ul>
<li><code>@fp</code>：文件指针</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li><code>FR_OK</code></li>
<li><code>FR_DISK_ERR</code></li>
<li><code>FR_INT_ERR</code></li>
<li><code>FR_INVALID_OBJECT</code></li>
<li><code>FR_TIMEOUT</code></li>
</ul>
<p><strong>描述：</strong></p>
<ul>
<li>文件在写入的时候会暂存在文件缓冲区，只有遇到刷新条件的时候才会将写缓冲区的数据写入到文件中。但是在未将缓冲区的数据冲刷到缓冲区之前突然发生错误，那么写入的信息就丢失了。</li>
</ul>
<p><strong>使用条件：</strong></p>
<ul>
<li>当 <code>FF_FS_READONLY == 0</code> 时可用。</li>
</ul>
<h2 id="8、f-forward-读取文件数据并将其转发到数据流设备"><a href="#8、f-forward-读取文件数据并将其转发到数据流设备" class="headerlink" title="8、f_forward 读取文件数据并将其转发到数据流设备"></a>8、f_forward 读取文件数据并将其转发到数据流设备</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">FRESULT <span class="token function">f_forward</span> <span class="token punctuation">(</span>
    FIL<span class="token operator">*</span> fp<span class="token punctuation">,</span>                        <span class="token comment">/* [IN] File object */</span>
    <span class="token function">UINT</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> BYTE<span class="token operator">*</span><span class="token punctuation">,</span> UINT<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">/* [IN] Data streaming function */</span>
    UINT btf<span class="token punctuation">,</span>                       <span class="token comment">/* [IN] Number of bytes to forward */</span>
    UINT<span class="token operator">*</span> bf                        <span class="token comment">/* [OUT] Number of bytes forwarded */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>参数：</strong></p>
<ul>
<li><code>@fp</code>：文件指针</li>
<li><code>@func</code>：数据处理函数</li>
<li><code>@btf</code>：传输的数据大小</li>
<li><code>@bf</code>：实际传输的数据</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li><code>FR_OK</code></li>
<li><code>FR_DISK_ERR</code></li>
<li><code>FR_INT_ERR</code></li>
<li><code>FR_INVALID_OBJECT</code></li>
<li><code>FR_DENIED</code></li>
<li><code>FR_TIMEOUT</code></li>
</ul>
<p><strong>描述：</strong></p>
<ul>
<li>如果 <code>*bf</code> 小于 <code>btf</code> 而没有错误，则表示由于文件结束或流在数据传输期间繁忙，无法传输请求的数据大小。</li>
</ul>
<h2 id="9、f-expand-为文件准备或分配一个连续的区域"><a href="#9、f-expand-为文件准备或分配一个连续的区域" class="headerlink" title="9、f_expand 为文件准备或分配一个连续的区域"></a>9、f_expand 为文件准备或分配一个连续的区域</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">FRESULT <span class="token function">f_expand</span> <span class="token punctuation">(</span>
    FIL<span class="token operator">*</span>    fp<span class="token punctuation">,</span>  <span class="token comment">/* [IN] File object */</span>
    FSIZE_t fsz<span class="token punctuation">,</span> <span class="token comment">/* [IN] File size expanded to */</span>
    BYTE    opt  <span class="token comment">/* [IN] Allocation mode */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>参数：</strong></p>
<ul>
<li><code>@fp</code>：文件指针</li>
<li><code>@fsz</code>：分配空间的大小</li>
<li><code>@opt</code>：分配模式（0）准备分配、（1）立即分配</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li><code>FR_OK</code></li>
<li><code>FR_DISK_ERR</code></li>
<li><code>FR_INT_ERR</code></li>
<li><code>FR_INVALID_OBJECT</code></li>
<li><code>FR_DENIED</code></li>
<li><code>FR_TIMEOUT</code></li>
</ul>
<p><strong>描述：</strong></p>
<ul>
<li>为一个空文件分配连续的空间，必须是空文件，函数执行完之后读写指针（光标）在文件开头。在分配空间的时候不会像文件写入数据。由于以下一些原因，该函数可能会因 <code>FR_DENIED</code> 而失败：<ul>
<li>未找到可用的连续空间。</li>
<li>文件大小不为零。</li>
<li>该文件已以只读模式打开。</li>
<li>不允许的文件大小（&gt;= 4 GB 的 FAT 卷）。</li>
</ul>
</li>
</ul>
<p><strong>使用条件：</strong></p>
<ul>
<li>当 <code>FF_USE_EXPAND == 1</code> 和 <code>FF_FS_READONLY == 0</code> 时可用。</li>
</ul>
<h2 id="10、f-tell-获取当前文件指针的位置"><a href="#10、f-tell-获取当前文件指针的位置" class="headerlink" title="10、f_tell 获取当前文件指针的位置"></a>10、f_tell 获取当前文件指针的位置</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">FSIZE_t <span class="token function">f_tell</span> <span class="token punctuation">(</span>
    FIL<span class="token operator">*</span> fp   <span class="token comment">/* [IN] File object */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>参数：</strong></p>
<ul>
<li><code>@fp</code>：文件指针</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>文件指针的位置，也就是光标的位置，距离文件开头的位置</li>
</ul>
<p><strong>描述：</strong></p>
<ul>
<li>此函数为宏：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">f_tell</span><span class="token expression"><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token operator">-&gt;</span>fptr<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p><strong>使用条件：</strong></p>
<ul>
<li>始终可用</li>
</ul>
<h2 id="11、f-eof-判断文件指针是否在文件尾"><a href="#11、f-eof-判断文件指针是否在文件尾" class="headerlink" title="11、f_eof 判断文件指针是否在文件尾"></a>11、f_eof 判断文件指针是否在文件尾</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">f_eof</span> <span class="token punctuation">(</span>
    FIL<span class="token operator">*</span> fp   <span class="token comment">/* [IN] File object */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>参数：</strong></p>
<ul>
<li><code>@fp</code>：文件指针</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>如果读/写指针到达文件末尾，则 <code>f_eof</code> 函数返回非零值；否则返回零。</li>
</ul>
<p><strong>描述：</strong></p>
<ul>
<li>此函数为宏：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">f_eof</span><span class="token expression"><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token operator">-&gt;</span>fptr <span class="token operator">==</span> <span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token operator">-&gt;</span>fsize<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p><strong>使用条件：</strong></p>
<ul>
<li>始终可用</li>
</ul>
<h2 id="12、f-size-获取文件的大小"><a href="#12、f-size-获取文件的大小" class="headerlink" title="12、f_size 获取文件的大小"></a>12、f_size 获取文件的大小</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">FSIZE_t <span class="token function">f_size</span> <span class="token punctuation">(</span>
    FIL<span class="token operator">*</span> fp   <span class="token comment">/* [IN] File object */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>参数：</strong></p>
<ul>
<li><code>@fp</code>：文件指针</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>以字节为单位返回文件的大小</li>
</ul>
<p><strong>描述：</strong></p>
<ul>
<li>此函数为宏：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">f_size</span><span class="token expression"><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token operator">-&gt;</span>obj<span class="token punctuation">.</span>objsize<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p><strong>使用条件：</strong></p>
<ul>
<li>始终可用</li>
</ul>
<h2 id="13、f-error-测试文件上的错误"><a href="#13、f-error-测试文件上的错误" class="headerlink" title="13、f_error 测试文件上的错误"></a>13、f_error 测试文件上的错误</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">f_error</span> <span class="token punctuation">(</span>
    FIL<span class="token operator">*</span> fp   <span class="token comment">/* [IN] File object */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>参数：</strong></p>
<ul>
<li><code>@fp</code>：文件指针</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>如果发生硬错误，则返回非零值；否则返回零。</li>
</ul>
<p><strong>描述：</strong></p>
<ul>
<li>此函数为宏：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">f_error</span><span class="token expression"><span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token operator">-&gt;</span>err<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p><strong>使用条件：</strong></p>
<ul>
<li>始终可用</li>
</ul>
<h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>欢迎访问<a href="https://sparkle-now.cn/">我的博客</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32DMA学习</title>
    <url>/2023/10/01/dma-xue-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="DMA中断"><a href="#DMA中断" class="headerlink" title="DMA中断"></a><strong>DMA中断</strong></h1><h2 id="实现目的"><a href="#实现目的" class="headerlink" title="实现目的"></a><strong>实现目的</strong></h2><ul>
<li><p>DMA用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。<strong>无须CPU的干预</strong>，通过DMA数据可以快速地移动。这就节省了CPU的资源来做其他操作。</p>
</li>
<li><p>中断是指CPU在执行程序的过程中，出现了某些突发事件时CPU必须暂停执行当前的程序，转去处理突发事件，处理完毕后CPU又返回源程序被中断的位置并继续执行。</p>
</li>
<li><p>利用DMA实现大量数据传输，配合中断对数据进行解析，可以大量节省CPU资源并在大工程中能够有效避免数据处理对程序的卡顿现象。</p>
</li>
</ul>
<h2 id="DMA简介"><a href="#DMA简介" class="headerlink" title="DMA简介"></a><strong>DMA简介</strong></h2><p><strong><a href="https://blog.csdn.net/as480133937/article/details/104927922/">DMA详细原理</a></strong></p>
<h3 id="1-DMA介绍"><a href="#1-DMA介绍" class="headerlink" title="1. DMA介绍"></a>1. DMA介绍</h3><h6 id="（1）DMA基本概念"><a href="#（1）DMA基本概念" class="headerlink" title="（1）DMA基本概念:"></a>（1）DMA基本概念:</h6><p>DMA，全称Direct MemoryAccess，即直接存储器访问。DMA传输将数据从一个地址空间复制到另一个地址空间，-用于在外设与存储器之间以及存储器与存储器之间进行高速数据传输。DMA传输过程的初始化和启动由CPU完成，传输过程由DMA控制器来执行，无需CPU参与，从而节省CPU资源，提高利用率。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781153485.png" alt="DMA.png"></p>
<h6 id="（2）STM32的DMA控制器特点"><a href="#（2）STM32的DMA控制器特点" class="headerlink" title="（2）STM32的DMA控制器特点:"></a>（2）STM32的DMA控制器特点:</h6><ol>
<li>STM32F401微控制器具备两个DMA控制器：DMA1和DMA2，每个控制器有8个数据流，每个数据流可以映射到8个通道（或请求）；</li>
<li>每一个DMA控制器用于管理一个或多个外设的存储器访问请求，并通过总线仲裁器来协调各个DMA请求的优先级；</li>
<li>数据流（stream）是用于连接传输源和传输目标的数据通路，每个数据流可以配置为不同的传输源和传输目标，这些传输源和传输目标称为通道（Channel）；</li>
<li>具备16字节的FIFO。使能FIFO功能后，源数据先送入FIFO，达到FIFO的触发阈值后，再传送到目标地址。</li>
</ol>
<h6 id="（3）DMA的主要特征"><a href="#（3）DMA的主要特征" class="headerlink" title="（3）DMA的主要特征:"></a>（3）DMA的主要特征:</h6><ol>
<li><p>在同一个DMA模块上，多个请求间的优先权可以通过软件编程设置（共有四级：很高、高、中等和低），优先权设置相等时由硬件决定（请求0优先于请求1，依此类推）；</p>
</li>
<li><p>独立数据源和目标数据区的传输宽度（字节、半字、全字），模拟打包和拆包的过程。源和目标地址必须按数据传输宽度对齐；</p>
</li>
<li><p>支持循环的缓冲器管理，即FIFO模式，用于在源数据传输到目标地址之前临时存放这些数据，阈值有1/4、1/2、3/4 和满；</p>
</li>
<li><p>每个通道都有3个事件标志（DMA半传输、DMA传输完成和DMA传输出错），这3个事件标志逻辑或成为一个单独的中断请求；</p>
</li>
<li><p>存储器和存储器间的传输、外设和存储器、存储器和外设之间的传输，如图所示；<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781120173.png" alt="DMA.png"></p>
</li>
<li><p>闪存、SRAM、外设的SRAM、APB1、APB2和AHB外设均可作为访问的源和目标；<br>可编程的数据传输数目：最大为65535。</p>
</li>
</ol>
<h6 id="（4）DMA的数据传输方式："><a href="#（4）DMA的数据传输方式：" class="headerlink" title="（4）DMA的数据传输方式："></a>（4）DMA的数据传输方式：</h6><ul>
<li><strong>普通模式:</strong><br>传输结束后（即要传输数据的数量达到零），将不再产生DMA操作。若开始新的DMA传输，需在关闭DMA通道情况下，重新启动DMA传输。</li>
<li><strong>循环模式:</strong><br>可用于处理环形缓冲区和连续数据流（例如ADC扫描模式）。当激活循环模式后，每轮传输结束时，要传输的数据数量将自动用设置的初始值进行加载， 并继续响应DMA请求。</li>
</ul>
<h3 id="2-DMA原理图"><a href="#2-DMA原理图" class="headerlink" title="2. DMA原理图"></a>2. DMA原理图</h3><h5 id="这是DMA工作流程图："><a href="#这是DMA工作流程图：" class="headerlink" title="这是DMA工作流程图："></a>这是DMA工作流程图：</h5><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696780984930.png" alt="工作流程图"></p>
<h5 id="DMA1通道图如下："><a href="#DMA1通道图如下：" class="headerlink" title="DMA1通道图如下："></a>DMA1通道图如下：</h5><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781002302.png" alt=" DMA1"></p>
<h5 id="DMA2通道图如下："><a href="#DMA2通道图如下：" class="headerlink" title="DMA2通道图如下："></a>DMA2通道图如下：</h5><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781021656.png" alt="DMA2"></p>
<h5 id="DMA系统框图如下："><a href="#DMA系统框图如下：" class="headerlink" title="DMA系统框图如下："></a>DMA系统框图如下：</h5><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781037048.png" alt="系统框图"></p>
<h2 id="DMA结构体"><a href="#DMA结构体" class="headerlink" title="DMA结构体"></a><strong>DMA结构体</strong></h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> DMA_Channel<span class="token punctuation">;</span>             <span class="token comment">//通道选择,通道0~7</span>
    <span class="token class-name">uint32_t</span> DMA_PeripheralBaseAddr<span class="token punctuation">;</span>  <span class="token comment">//外设地址</span>
    <span class="token class-name">uint32_t</span> DMA_Memory0BaseAddr<span class="token punctuation">;</span>     <span class="token comment">//存储器地址</span>
    <span class="token class-name">uint32_t</span> DMA_DIR<span class="token punctuation">;</span>                 <span class="token comment">//传输方向</span>
    <span class="token class-name">uint32_t</span> DMA_BufferSize<span class="token punctuation">;</span>          <span class="token comment">//数据数目,设定待传输数据数目</span>
    <span class="token class-name">uint32_t</span> DMA_PeripheralInc<span class="token punctuation">;</span>       <span class="token comment">//外设递增</span>
    <span class="token class-name">uint32_t</span> DMA_MemoryInc<span class="token punctuation">;</span>           <span class="token comment">//存储器递增</span>
    <span class="token class-name">uint32_t</span> DMA_PeripheralDataSize<span class="token punctuation">;</span>  <span class="token comment">//外设数据宽度(字节、半字、全字)</span>
    <span class="token class-name">uint32_t</span> DMA_MemoryDataSize<span class="token punctuation">;</span>      <span class="token comment">//存储器数据宽度(字节、半字、全字)</span>
    <span class="token class-name">uint32_t</span> DMA_Mode<span class="token punctuation">;</span>                <span class="token comment">//模式选择(普通模式和循环模式)</span>
    <span class="token class-name">uint32_t</span> DMA_Priority<span class="token punctuation">;</span>            <span class="token comment">//优先级(很高、高、中等和低)</span>
    <span class="token class-name">uint32_t</span> DMA_FIFOMode<span class="token punctuation">;</span>            <span class="token comment">//FIFO模式</span>
    <span class="token class-name">uint32_t</span> DMA_FIFOThreshold<span class="token punctuation">;</span>       <span class="token comment">//FIFO阈值</span>
    <span class="token class-name">uint32_t</span> DMA_MemoryBurst<span class="token punctuation">;</span>         <span class="token comment">//存储器突发传输</span>
    <span class="token class-name">uint32_t</span> DMA_PeripheralBurst<span class="token punctuation">;</span>     <span class="token comment">//外设突发传输</span>
<span class="token punctuation">}</span> DMA_InitTypeDef<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="DMA结构体初始化"><a href="#DMA结构体初始化" class="headerlink" title="DMA结构体初始化"></a><strong>DMA结构体初始化</strong></h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>       <span class="token macro-name">JY60_len</span>             <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">30</span><span class="token punctuation">)</span>       </span><span class="token comment">//陀螺仪数据缓存区长度</span></span>
<span class="token class-name">uint8_t</span>       JY60_Buff<span class="token punctuation">[</span>JY60_len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token comment">// 陀螺仪接收数据缓存区（自定义内存）</span>

<span class="token keyword">void</span> <span class="token function">DMA_USART2_Config</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">/*开启DMA时钟*/</span>
	<span class="token function">RCC_AHB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_AHB1Periph_DMA1<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">/*使能DMA1的数据流1*/</span>
	<span class="token function">DMA_DeInit</span><span class="token punctuation">(</span>DMA1_Stream5<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">/*等待DMA可配置*/</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">DMA_GetCmdStatus</span><span class="token punctuation">(</span>DMA1_Stream5<span class="token punctuation">)</span> <span class="token operator">!=</span> DISABLE<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>	
		
    <span class="token comment">/*DMA结构体初始化*/</span>
    DMA_InitTypeDef DMA_InitStructure<span class="token punctuation">;</span>
	DMA_InitStructure<span class="token punctuation">.</span>DMA_Channel<span class="token operator">=</span>DMA_Channel_4<span class="token punctuation">;</span><span class="token comment">//使能DMA数据流1的通道4</span>
	DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralBaseAddr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>USART2<span class="token operator">-&gt;</span>DR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置DMA外设基地址</span>
	DMA_InitStructure<span class="token punctuation">.</span>DMA_Memory0BaseAddr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>JY60_Buff<span class="token punctuation">;</span><span class="token comment">//设置内存基地址 (要传输的变量的指针)</span>
	DMA_InitStructure<span class="token punctuation">.</span>DMA_DIR <span class="token operator">=</span> DMA_DIR_PeripheralToMemory<span class="token punctuation">;</span><span class="token comment">//传输方向：从外设到内存</span>
	DMA_InitStructure<span class="token punctuation">.</span>DMA_BufferSize <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>JY60_len<span class="token punctuation">;</span><span class="token comment">//DMA通道的DMA缓存的大小</span>
	DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralInc <span class="token operator">=</span> DMA_PeripheralInc_Disable<span class="token punctuation">;</span><span class="token comment">//外设基地址不增</span>
	DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryInc <span class="token operator">=</span> DMA_MemoryInc_Enable<span class="token punctuation">;</span><span class="token comment">//内存基地址自增</span>
	DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralDataSize<span class="token operator">=</span>DMA_PeripheralDataSize_Byte<span class="token punctuation">;</span><span class="token comment">//外设数据宽度：一个字节</span>
	DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryDataSize <span class="token operator">=</span> DMA_MemoryDataSize_Byte<span class="token punctuation">;</span><span class="token comment">//内存数据宽度：一个字节</span>
	DMA_InitStructure<span class="token punctuation">.</span>DMA_Mode <span class="token operator">=</span> DMA_Mode_Normal<span class="token punctuation">;</span><span class="token comment">//DMA 模式：正常传输</span>
	DMA_InitStructure<span class="token punctuation">.</span>DMA_Priority <span class="token operator">=</span> DMA_Priority_High<span class="token punctuation">;</span><span class="token comment">//优先级：高 </span>

    DMA_InitStructure<span class="token punctuation">.</span>DMA_FIFOMode <span class="token operator">=</span> DMA_FIFOMode_Enable<span class="token punctuation">;</span><span class="token comment">//禁用 FIFO</span>

    <span class="token comment">/*此处为FIFO模式功能，已被禁用，无需设置*/</span>
	DMA_InitStructure<span class="token punctuation">.</span>DMA_FIFOThreshold <span class="token operator">=</span> DMA_FIFOThreshold_Full<span class="token punctuation">;</span><span class="token comment">//FIFO 阈值：满</span>
	DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryBurst <span class="token operator">=</span> DMA_MemoryBurst_Single<span class="token punctuation">;</span><span class="token comment">//存储器突发传输 16 个节拍</span>
	DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralBurst <span class="token operator">=</span> DMA_PeripheralBurst_Single<span class="token punctuation">;</span><span class="token comment">//外设突发传输 1 个节拍</span>

    <span class="token function">DMA_Init</span><span class="token punctuation">(</span>DMA1_Stream5<span class="token punctuation">,</span> <span class="token operator">&amp;</span>DMA_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">/*使能完成中断*/</span>	
	<span class="token function">DMA_ITConfig</span><span class="token punctuation">(</span>DMA1_Stream5<span class="token punctuation">,</span> DMA_IT_TC<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>	
	
	<span class="token comment">/*使能DMA*/</span>
    <span class="token function">DMA_Cmd</span><span class="token punctuation">(</span>DMA1_Stream5<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>==<strong>注意要点：</strong>==</p>
<ol>
<li>需要使能DMA时钟和数据流，一般禁用FIFO模式。</li>
<li>外设—&gt;存储器（内存）：外设基地址不增，内存基地址自增。</li>
<li>存储器（内存）—&gt;外设：内存基地址不增，外设基地址自增。</li>
<li>DMA_BufferSize需要根据数据实际解算频率设置，否者会影响程序运行。</li>
<li>DMA用于数据传输时，一般用普通模式，循环模式常用于ADC信号扫描。</li>
</ol>
<h2 id="DMA中断函数及数据解析"><a href="#DMA中断函数及数据解析" class="headerlink" title="DMA中断函数及数据解析"></a><strong>DMA中断函数及数据解析</strong></h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*-------------------------------开启一次DMA传输-------------------------*/</span>
<span class="token comment">//此函数为DMA普通模式下对DMA进行重新初始化，保证DMA可以连续解析数据</span>
<span class="token keyword">void</span> <span class="token function">DMA_Enable</span><span class="token punctuation">(</span>DMA_Stream_TypeDef<span class="token operator">*</span> DMAy_Streamx<span class="token punctuation">,</span><span class="token class-name">uint32_t</span> DMA_FLAG_TCIFx<span class="token punctuation">,</span><span class="token class-name">uint32_t</span> DMA_FLAG_TEIFx<span class="token punctuation">,</span><span class="token class-name">uint32_t</span> DMA_FLAG_HTIFx<span class="token punctuation">,</span><span class="token class-name">uint16_t</span> length<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">DMA_Cmd</span><span class="token punctuation">(</span>DMAy_Streamx<span class="token punctuation">,</span> DISABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>                                           <span class="token comment">//关闭DMA</span>
  <span class="token function">DMA_ClearFlag</span><span class="token punctuation">(</span>DMAy_Streamx<span class="token punctuation">,</span>DMA_FLAG_TCIFx<span class="token operator">|</span> DMA_FLAG_TEIFx<span class="token operator">|</span>DMA_FLAG_HTIFx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//清除DMAy_Streamx传输完成标志</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">DMA_GetCmdStatus</span><span class="token punctuation">(</span>DMAy_Streamx<span class="token punctuation">)</span> <span class="token operator">!=</span> DISABLE<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>                       <span class="token comment">//等待传输结束</span>
  <span class="token function">DMA_SetCurrDataCounter</span><span class="token punctuation">(</span>DMAy_Streamx<span class="token punctuation">,</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment">//设置传输数据长度 </span>
  <span class="token function">DMA_Cmd</span><span class="token punctuation">(</span>DMAy_Streamx<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>                                            <span class="token comment">//开启DMA</span>
<span class="token punctuation">}</span>

<span class="token comment">/*-------------------------DMA1_Stream6-USART2-JY60-中断函数-------------------------*/</span>
<span class="token keyword">void</span> <span class="token function">DMA1_Stream5_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">DMA_GetITStatus</span><span class="token punctuation">(</span>DMA1_Stream5<span class="token punctuation">,</span>DMA_IT_TCIF5<span class="token punctuation">)</span><span class="token operator">==</span>SET<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">JY60_Data_Out</span><span class="token punctuation">(</span>JY60_Buff<span class="token punctuation">,</span>JY60_len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//JY60数据解析</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>JY60_len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//将数据缓存区清零</span>
		<span class="token punctuation">{</span>
			JY60_Buff<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//清除DMA各种中断标志位，重装载DMA,方便下次数据传输</span>
		<span class="token function">DMA_Enable</span><span class="token punctuation">(</span>DMA1_Stream5<span class="token punctuation">,</span>DMA_FLAG_TCIF5<span class="token punctuation">,</span>DMA_FLAG_TEIF5<span class="token punctuation">,</span>DMA_FLAG_HTIF5<span class="token punctuation">,</span>JY61_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>		
<span class="token punctuation">}</span>


<span class="token keyword">float</span> fAcc<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   	<span class="token comment">//加速度</span>
<span class="token keyword">float</span> fGyro<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>	  	<span class="token comment">//角速度</span>
<span class="token keyword">float</span> fAngle<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 	<span class="token comment">//角度</span>
<span class="token keyword">float</span> Temp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>			<span class="token comment">//温度</span>
<span class="token class-name">uint8_t</span> JY60_flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">//JY60通讯成功标志位</span>
<span class="token keyword">float</span> yaw<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>			<span class="token comment">//航向角</span>

<span class="token keyword">void</span> <span class="token function">JY61_Data_Out</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> Rebuf<span class="token punctuation">,</span><span class="token class-name">uint32_t</span> Size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> Sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span><span class="token comment">//接收缓冲器下标索引</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>	  
		<span class="token keyword">if</span><span class="token punctuation">(</span>Rebuf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0x55</span><span class="token punctuation">)</span><span class="token comment">//检查帧头</span>
		<span class="token punctuation">{</span>
		   <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
		   <span class="token punctuation">{</span>
			Sum <span class="token operator">=</span> Sum<span class="token operator">+</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//对数据求和</span>
		   <span class="token punctuation">}</span>
			<span class="token keyword">switch</span><span class="token punctuation">(</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{</span>
				<span class="token keyword">case</span> <span class="token number">0x51</span><span class="token operator">:</span><span class="token comment">//加速度数据解析</span>
						fAcc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token operator">|</span> Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768.0</span><span class="token operator">*</span><span class="token number">16</span><span class="token punctuation">;</span>
						fAcc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token operator">|</span> Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768.0</span><span class="token operator">*</span><span class="token number">16</span><span class="token punctuation">;</span>
						fAcc<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token operator">|</span> Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768.0</span><span class="token operator">*</span><span class="token number">16</span><span class="token punctuation">;</span>
						Temp    <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token operator">|</span> Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">340.0</span><span class="token operator">+</span><span class="token number">36.25</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token keyword">case</span> <span class="token number">0x52</span><span class="token operator">:</span><span class="token comment">//角速度数据解析</span>
						fGyro<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token operator">|</span> Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768.0</span><span class="token operator">*</span><span class="token number">2000</span><span class="token punctuation">;</span>
						fGyro<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token operator">|</span> Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768.0</span><span class="token operator">*</span><span class="token number">2000</span><span class="token punctuation">;</span>
						fGyro<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token operator">|</span> Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768.0</span><span class="token operator">*</span><span class="token number">2000</span><span class="token punctuation">;</span>
						Temp     <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token operator">|</span> Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">340.0</span><span class="token operator">+</span><span class="token number">36.25</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token keyword">case</span> <span class="token number">0x53</span><span class="token operator">:</span><span class="token comment">//角度数据解析</span>
						fAngle<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token operator">|</span> Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768.0</span><span class="token operator">*</span><span class="token number">180</span><span class="token punctuation">;</span>
						fAngle<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token operator">|</span> Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768.0</span><span class="token operator">*</span><span class="token number">180</span><span class="token punctuation">;</span>
						fAngle<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token operator">|</span> Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">32768.0</span><span class="token operator">*</span><span class="token number">180</span><span class="token punctuation">;</span>
						Temp      <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token operator">|</span> Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">340.0</span><span class="token operator">+</span><span class="token number">36.25</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
            <span class="token comment">//对数据进行求和校验，并对角度数据进行处理</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">==</span>Sum<span class="token operator">&amp;&amp;</span>Rebuf<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0x53</span><span class="token punctuation">)</span>
			<span class="token punctuation">{</span>
				JY60_flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>JY60_flag<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>
			<span class="token punctuation">{</span>
				JY60_flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//JY60标志位清零</span>

                <span class="token comment">//将角度由0°~180°~360°转化为-180°~0°~180°，方便后续对角度的运用</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>fAngle<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&gt;=</span><span class="token number">0.0f</span><span class="token operator">&amp;&amp;</span>fAngle<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">180.0f</span><span class="token punctuation">)</span>
				<span class="token punctuation">{</span>
					fAngle<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>fAngle<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>fAngle<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token number">180.0f</span><span class="token operator">&amp;&amp;</span>fAngle<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">360.0f</span><span class="token punctuation">)</span>
				<span class="token punctuation">{</span>
					fAngle<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>fAngle<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">360.0f</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token comment">//防止其他数据对yaw的干扰</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>fAngle<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>
				<span class="token punctuation">{</span>
				 yaw<span class="token operator">=</span>  fAngle<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>					
		<span class="token punctuation">}</span>					
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>==<strong>注意要点：</strong>==</p>
<ol>
<li>DMA中断和串口接收中断对数据解析有所不同，DMA中断是直接对内存中已有数据进行for循环解析，而串口接收中断是需要先存储数据再解析。</li>
<li>DMA中断名是规定的，不可随便更改。</li>
<li>每次DMA解析结束时，需要对DMA重初始化，否则将无法进行下次数据传输。</li>
<li>解析结束时，记得将数据缓存区清零。</li>
</ol>
<h2 id="编程要点及总结"><a href="#编程要点及总结" class="headerlink" title="编程要点及总结"></a><strong>编程要点及总结</strong></h2><ol>
<li>首先定义一个全局数组用于存放DMA传输数据。</li>
<li>接着初始化DMA,开启DMA相关时钟，配置普通模式并开启DMA完成中断。</li>
<li>写DMA中断函数，并将DMA解析函数和DMA重装载函数放入中断里。</li>
<li>接着在main 函数延时500ms打印解析数据至上位机。</li>
</ol>
<p>==<strong>总结：</strong>==<br>熟练掌握DMA中断处理数据，将大大减少数据处理对程序的卡顿现象，并且可以有效避免多个中断存在时引起数据处理不及时问题，因此DMA非常重要！</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>DMA</tag>
      </tags>
  </entry>
  <entry>
    <title>Keil5-debug仿真教程</title>
    <url>/2023/10/01/keil5-debug-fang-zhen-jiao-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Keil5-debug仿真教程"><a href="#Keil5-debug仿真教程" class="headerlink" title="Keil5-debug仿真教程"></a><strong>Keil5-debug仿真教程</strong></h1><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781254220.jpg" alt="keil5"></p>
<h2 id="一、学习目的"><a href="#一、学习目的" class="headerlink" title="一、学习目的"></a>一、学习目的</h2><hr>
<p><strong>Debug</strong> 是指在软件开发过程中，通过识别和解决问题来调试程序的过程。通常需要找出程序中的错误、异常或潜在问题，并修复它们以确保程序的正确性和稳定性。</p>
<h5 id="常见的debug方法有三种："><a href="#常见的debug方法有三种：" class="headerlink" title="常见的debug方法有三种："></a><strong>常见的debug方法有三种：</strong></h5><ol>
<li><p>==硬件调试==：通过LED灯、蜂鸣器等能使人员感知到的器件，利用其交互性进行调试。</p>
</li>
<li><p>==打印调试==：使用串口（Printf）,能将数据信息发送的方式，追踪程序运行状态。</p>
</li>
<li><p>==调速器调试==：利用设备支持的硬件内部运行状态追踪功能调试，大部分单片机都支持调试器调试，如STM32配合ST-Link,DAP-Link,fireDAP等调试工具。</p>
</li>
</ol>
<p><strong>目的：</strong> 众所周知，硬件调试过于复杂，需要单独写一段初始化代码，所以不经常使用；而打印调试需要在源代码中加入大量 &lt;printf&gt;,极易引起代码混乱。以上两者方法调试效率低下，因此作为一名嵌入式工程师掌握调试器调试必不可少。</p>
<hr>
<h2 id="二、keil5-debug-步骤"><a href="#二、keil5-debug-步骤" class="headerlink" title="二、keil5-debug 步骤"></a>二、keil5-debug 步骤</h2><h3 id="（1）正确连接烧录器"><a href="#（1）正确连接烧录器" class="headerlink" title="（1）正确连接烧录器"></a>（1）正确连接烧录器</h3><table>
<thead>
<tr>
<th align="center"><strong>DAP-Link</strong></th>
<th align="center"><strong>ST-Link</strong></th>
<th align="center"><strong>Stm32单片机</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>SCK</strong></td>
<td align="center"><strong>SWCLK</strong></td>
<td align="center"><strong>SCK</strong></td>
</tr>
<tr>
<td align="center"><strong>SWD</strong></td>
<td align="center"><strong>SWDIO</strong></td>
<td align="center"><strong>DIO</strong></td>
</tr>
<tr>
<td align="center"><strong>3V3			（5V）</strong></td>
<td align="center"><strong>3V3			（5V）</strong></td>
<td align="center"><strong>VCC		（5V）</strong></td>
</tr>
<tr>
<td align="center"><strong>GND</strong></td>
<td align="center"><strong>GND</strong></td>
<td align="center"><strong>GND</strong></td>
</tr>
</tbody></table>
<h3 id="（2）设置-keil5-Options-Debug选项"><a href="#（2）设置-keil5-Options-Debug选项" class="headerlink" title="（2）设置 keil5-Options-Debug选项"></a>（2）设置 keil5-Options-Debug选项</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781300736.png" alt="keil5-Debug-1.png"></p>
<ol>
<li>选择ST-link或者DAP-Link;</li>
<li>勾选“Load Application at Startup” 和 Run to main();</li>
<li>打开“Setting”并确定。</li>
</ol>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781319301.png" alt="keil5-Debug-2.png"></p>
<ol>
<li>检查SWDIO是否连接成功；</li>
<li>“Port” 设置为 “SW”，“Connect” 设置为 “Normal”，“Reset” 设置为 SYSRESETREQ(Default);</li>
<li>Max Clock 设置低于10M;</li>
<li>点击确定。</li>
</ol>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781338308.png" alt="keil5-Debug-3.png"></p>
<ol>
<li>选择Flash DownLoad 中的 “Reset and Run”；</li>
<li>检查是否添加Flash编程算法；</li>
<li>Utilities 选择 “St-link Debugger” 或者 “DAP-Link Dabugger”,勾选 “Update Target before Debugger”；</li>
<li>设置完毕后点击确定。</li>
</ol>
<h3 id="（3）开始调试"><a href="#（3）开始调试" class="headerlink" title="（3）开始调试"></a>（3）开始调试</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781385531.png" alt="image.png"></p>
<p>单击窗口上的调试按钮快捷图标（上图红色框内图标），进入到软件模拟调试模式。</p>
<h3 id="（4）调试工具栏介绍"><a href="#（4）调试工具栏介绍" class="headerlink" title="（4）调试工具栏介绍"></a>（4）调试工具栏介绍</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781398621.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th align="center"><strong>1</strong></th>
<th align="center"><strong>复位</strong></th>
<th align="left">对程序进行复位操作，根据烧录器不同的复位方式配置会触发不同的复位类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>2</strong></td>
<td align="center"><strong>全速运行</strong></td>
<td align="left">使当前程序开始正常全速运行，直到程序遇到断点时停止</td>
</tr>
<tr>
<td align="center"><strong>3</strong></td>
<td align="center"><strong>单步调试</strong></td>
<td align="left">根据当前调试的窗口的语言，执行单条语句。如果遇到函数，则会进入函数内部。如果是在反汇编窗口中，则只执行一条汇编指令</td>
</tr>
<tr>
<td align="center"><strong>4</strong></td>
<td align="center"><strong>单步跳过调试</strong></td>
<td align="left">如果是在C语言窗口中，则是按单条语句执行，与单步调试不同的是，遇到函数不会进入函数内部，而是直接全速运行函数，并跳到下一条语句</td>
</tr>
<tr>
<td align="center"><strong>5</strong></td>
<td align="center"><strong>单步返回调试</strong></td>
<td align="left">如果是在C语言窗口中，则是按单条语句执行，与单步调试不同的是，遇到函数不会进入函数内部，而是直接全速运行函数，并跳到下一条语句</td>
</tr>
<tr>
<td align="center"><strong>6</strong></td>
<td align="center"><strong>运行到当前光标</strong></td>
<td align="left">程序直接运行至当前光标所在行</td>
</tr>
<tr>
<td align="center"><strong>7</strong></td>
<td align="center"><strong>插入/移除断点</strong></td>
<td align="left">如果当前光标所在行未有断点，则插入断点，在有断点的情况下则是移除断点，插入断点后，当前行前面会有个红圆表示断点位置。（断点最多只能打7个）</td>
</tr>
<tr>
<td align="center"><strong>8</strong></td>
<td align="center"><strong>使能/禁止断点</strong></td>
<td align="left">开启或禁止当前光标所在行的断点。禁止后红圆变成白圆。</td>
</tr>
<tr>
<td align="center"><strong>9</strong></td>
<td align="center"><strong>禁止所有断点</strong></td>
<td align="left">禁止当前所有的断点</td>
</tr>
<tr>
<td align="center"><strong>10</strong></td>
<td align="center"><strong>删除所有断点</strong></td>
<td align="left">删除所有断点</td>
</tr>
</tbody></table>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781418964.png" alt="image.png"></p>
<blockquote>
<p>停止全速运行（上图红色框内图标），全速运行程序时激活该按钮，用来停止正全速运行的程序。</p>
</blockquote>
<p><a href="https://www.bilibili.com/video/BV1we4y1t7Uh/?spm_id_from=333.337.search-card.all.click&amp;vd_source=65cc1b0c6a89ff46e6b6a0afb26e5023">点击观看  Debug模式下调试选项介绍</a></p>
<h3 id="（5）全局变量查看（Watch1-和-Watch2）"><a href="#（5）全局变量查看（Watch1-和-Watch2）" class="headerlink" title="（5）全局变量查看（Watch1    和    Watch2）"></a>（5）全局变量查看（Watch1    和    Watch2）</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781653394.gif" alt="Watch.gif"></p>
<blockquote>
<p>通过”View-&gt;Watch Windows-&gt;Watch1、Watch2”可以选择打开Watch窗口，也可以在工具栏打开。</p>
</blockquote>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781474820.gif" alt="Watch.gif"></p>
<blockquote>
<p>通过选中一个变量，右键添加入对应的Watch窗口，可以追踪查看当前变量的变化状态。注意，只有全局变量可以全程监视，临时变量只有在进入当前函数中才可监视到其数据，用static关键词修饰的变量无法监视。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781490481.gif" alt="Periodic-Window-Update.png"></p>
</blockquote>
<blockquote>
<p>如果当前变量没有实时更新，则需要点击”View-&gt;Periodic Window Update”将其勾选上。</p>
</blockquote>
<h3 id="（6）局部变量查看（Call-Stack-Window）"><a href="#（6）局部变量查看（Call-Stack-Window）" class="headerlink" title="（6）局部变量查看（Call Stack Window）"></a>（6）局部变量查看（Call Stack Window）</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781712720.gif" alt="Call-Stack-window.gif"></p>
<blockquote>
<p>这个窗口可以查看函数内部局部变量的栈空间，也可以查看当前程序调度关系，当出现有进入硬件错误异常调试时可以快速定位到是哪里触发的异常。</p>
</blockquote>
<h3 id="（6）逻辑分析窗口（Analysis-Windows）"><a href="#（6）逻辑分析窗口（Analysis-Windows）" class="headerlink" title="（6）逻辑分析窗口（Analysis Windows）"></a>（6）逻辑分析窗口（Analysis Windows）</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781528548.gif" alt="image.gif"></p>
<blockquote>
<p>这个窗口只能在软件模拟仿真中使用，如果使用硬件调试，需要硬件支持，如下是逻辑分析窗口介绍。</p>
</blockquote>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781546611.png" alt="image.png"></p>
<p><a href="https://www.bilibili.com/video/BV1fm4y17777/?spm_id_from=333.337.search-card.all.click">点击观看逻辑分析窗口详细用法</a></p>
<h3 id="（7）内存查看窗口（Memory）"><a href="#（7）内存查看窗口（Memory）" class="headerlink" title="（7）内存查看窗口（Memory）"></a>（7）内存查看窗口（Memory）</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781562136.gif" alt="memory.gif"></p>
<blockquote>
<p>通过”View-&gt;Memory Windows-&gt;Memory1/2/3/4”打开Memory窗口，也可以通过工具栏打开。此窗口可以用来查看各变量的内存地址和RAM地址。</p>
</blockquote>
<h3 id="（8）寄存器窗口（Register-Window）"><a href="#（8）寄存器窗口（Register-Window）" class="headerlink" title="（8）寄存器窗口（Register Window）"></a>（8）寄存器窗口（Register Window）</h3><p>![image.gif]<img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781574989.gif" alt="enter description here"></p>
<blockquote>
<p>这个窗口用于查看当前内核的相关寄存器，如汇编里常说的15个通用寄存器。</p>
</blockquote>
<h3 id="（9）断点调试"><a href="#（9）断点调试" class="headerlink" title="（9）断点调试"></a>（9）断点调试</h3><p><a href="https://www.bilibili.com/video/BV1ee4y177Ad/?spm_id_from=333.788.recommend_more_video.0">点击观看 Debug模式下断点的使用</a></p>
<ol>
<li>设置断点；</li>
<li>点击全速运行；</li>
<li>查看代码光标是否运行到断点位置，如果运行至断点结束则说明前面代码正常运行；</li>
<li>如果代码无法运行至断点则说明前面代码出现卡死现象异常或者断点设置异常；</li>
<li>接着从最有可能卡停位置进行单步调试，适当观察全局变量和局部变量是否正常改变，直至找到bug；</li>
<li>也可以利用逻辑分析仪观察对应IO口的电平变化，从而了解问题所在。</li>
</ol>
<p><a href="https://blog.csdn.net/u012749085/article/details/126830777?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169623360016800192274943%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169623360016800192274943&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-126830777-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=keil5%20debug%E6%95%99%E7%A8%8B&amp;spm=1018.2226.3001.4187">如要详细了解 Keil5-debug 其他窗口，请点击这里</a></p>
<hr>
<h2 id="三、其他问题总结"><a href="#三、其他问题总结" class="headerlink" title="三、其他问题总结"></a>三、其他问题总结</h2><h5 id="1-keil硬件仿真无法进入main函数-或-debug卡死的原因总结"><a href="#1-keil硬件仿真无法进入main函数-或-debug卡死的原因总结" class="headerlink" title="1.keil硬件仿真无法进入main函数 或 debug卡死的原因总结"></a>1.keil硬件仿真无法进入main函数 或 debug卡死的原因总结</h5><p><a href="https://blog.csdn.net/sarsscofy/article/details/122395372?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=keil5%20%20debug%20%20%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-122395372.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">问题1解决方案</a></p>
<h5 id="2-keil软件仿真进不去main函数"><a href="#2-keil软件仿真进不去main函数" class="headerlink" title="2.keil软件仿真进不去main函数"></a>2.keil软件仿真进不去main函数</h5><p><a href="https://blog.csdn.net/YANGHUIFEI01/article/details/132320956?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169624640016800186551666%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169624640016800186551666&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-13-132320956-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=keil5%E8%BD%AF%E4%BB%B6%E4%BB%BF%E7%9C%9F%E4%B8%8D%E8%83%BD%E8%BF%90%E8%A1%8C&amp;spm=1018.2226.3001.4187">问题2解决方案</a></p>
<p><a href="https://www.bilibili.com/video/BV12E411c7Nd/?spm_id_from=333.337.search-card.all.click&amp;vd_source=65cc1b0c6a89ff46e6b6a0afb26e5023">如果调试过程还有疑问，请点击观看调试全过程</a></p>
<h4 id="总结：对于初学者来说，务必要实际动手操作一遍，特别是调试方法，要熟练掌握，因为以后工程调试时，用到的最多。"><a href="#总结：对于初学者来说，务必要实际动手操作一遍，特别是调试方法，要熟练掌握，因为以后工程调试时，用到的最多。" class="headerlink" title="总结：对于初学者来说，务必要实际动手操作一遍，特别是调试方法，要熟练掌握，因为以后工程调试时，用到的最多。"></a>总结：对于初学者来说，务必要实际动手操作一遍，特别是调试方法，要熟练掌握，因为以后工程调试时，用到的最多。</h4>]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>Keil5</tag>
      </tags>
  </entry>
  <entry>
    <title>RK3588S-Rock5A开机玩耍记录</title>
    <url>/2023/09/10/rk3588s-rock5a-kai-ji-wan-shua/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="RK3588S-Rock5A开机玩耍记录"><a href="#RK3588S-Rock5A开机玩耍记录" class="headerlink" title="RK3588S-Rock5A开机玩耍记录"></a>RK3588S-Rock5A开机玩耍记录</h1><h2 id="下载系统"><a href="#下载系统" class="headerlink" title="下载系统"></a>下载系统</h2><p><a href="https://github.com/radxa-build/rock-5a/releases">镜像下载地址</a></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1694268263152.png" alt="github界面"><br>可能需要翻个墙，也可以使用GitHub文件下载工具</p>
<p><a href="https://gh.api.99988866.xyz/">github下载文件加速</a></p>
<p>下载后使用<a href="https://balenaetcher.en.softonic.com/">balenaEtcher-Portable</a> 下载到SD卡，建议整好一些的SD卡</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1694268589247.png" alt="镜像烧录软件"></p>
<p>完成后插入SD卡，使用支持快充的供电器进行供电，好像是20W的需要，不然会启动不成功。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1694271172558.gif" alt="绿灯常亮，蓝灯闪烁"></p>
<h2 id="SSH访问连接"><a href="#SSH访问连接" class="headerlink" title="SSH访问连接"></a>SSH访问连接</h2><p>使用SSH终端工具</p>
<p>扫描以太网共享的IP</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1694272796986.png" alt="IP扫描"></p>
<p>俺的是192.168.137.219</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1694272895199.png" alt="SSH连接"></p>
<p>用户名和密码都是 rock</p>
<h2 id="添加官方软件源-（可以先不添加）"><a href="#添加官方软件源-（可以先不添加）" class="headerlink" title="添加官方软件源 （可以先不添加）"></a>添加官方软件源 （可以先不添加）</h2><p><a href="https://wiki.radxa.com/Rock5/guide/radxa-apt">参考链接</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">DISTRO</span><span class="token operator">=</span>bionic-stable
<span class="token builtin class-name">echo</span> <span class="token string">"deb http://apt.radxa.com/<span class="token variable">$DISTRO</span>/ <span class="token variable">${DISTRO<span class="token operator">%</span>-*}</span> main"</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> <span class="token parameter variable">-a</span> /etc/apt/sources.list.d/apt-radxa-com.list
<span class="token function">sudo</span> <span class="token function">apt</span> update
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="开启VNC远程登录"><a href="#开启VNC远程登录" class="headerlink" title="开启VNC远程登录"></a>开启VNC远程登录</h2><p><strong>下载vncserver</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> tigervnc-standalone-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>设置VNC登录密码</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vncpasswd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rock@rock-5a:~$ vncpasswd
Password:
Verify:
Would you like to enter a view-only password <span class="token punctuation">(</span>y/n<span class="token punctuation">)</span>? n
A view-only password is not used
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>添加配置文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.vnc/xstartup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token comment">#!/bin/sh</span>
<span class="token comment"># Start kde Desktop </span>
<span class="token builtin class-name">unset</span> <span class="token environment constant">SESSION_MANAGER</span>
<span class="token builtin class-name">unset</span> <span class="token environment constant">DBUS_SESSION_BUS_ADDRESS</span>
<span class="token assign-left variable">OS</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> <span class="token parameter variable">-s</span><span class="token variable">`</span></span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$OS</span> <span class="token operator">=</span> <span class="token string">'Linux'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token keyword">case</span> <span class="token string">"<span class="token variable">$WINDOWMANAGER</span>"</span> <span class="token keyword">in</span>
    *gnome*<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-e</span> /etc/SuSE-release <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/opt/gnome/bin
        <span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span>
      <span class="token keyword">fi</span>
      <span class="token punctuation">;</span><span class="token punctuation">;</span>
  <span class="token keyword">esac</span>
<span class="token keyword">fi</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-x</span> /etc/X11/xinit/xinitrc <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">exec</span> /etc/X11/xinit/xinitrc
<span class="token keyword">fi</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> /etc/X11/xinit/xinitrc <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">exec</span> <span class="token function">sh</span> /etc/X11/xinit/xinitrc
<span class="token keyword">fi</span>
<span class="token punctuation">[</span> <span class="token parameter variable">-r</span> <span class="token environment constant">$HOME</span>/.Xresources <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> xrdb <span class="token environment constant">$HOME</span>/.Xresources
xsetroot <span class="token parameter variable">-solid</span> grey
xterm <span class="token parameter variable">-geometry</span> <span class="token number">80</span>*24+10+10 <span class="token parameter variable">-ls</span> <span class="token parameter variable">-title</span> <span class="token string">"<span class="token variable">$VNCDESKTOP</span> Desktop"</span> <span class="token operator">&amp;</span>
twm <span class="token operator">&amp;</span>
startkde <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>增加可执行权限：</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">chmod</span> +x ~/.vnc/xstartup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>启动vnc服务：</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vncserver <span class="token parameter variable">-geometry</span> 1920x1080 <span class="token parameter variable">-alwaysshared</span> <span class="token parameter variable">-depth</span> <span class="token number">24</span> <span class="token parameter variable">-dpi</span> <span class="token number">96</span> :1 <span class="token parameter variable">-localhost</span> no<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>查看VNC服务</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vncserver <span class="token parameter variable">-list</span>

TigerVNC server sessions:

X <span class="token environment constant">DISPLAY</span> <span class="token comment">#     RFB PORT #      RFB UNIX PATH   PROCESS ID #    SERVER</span>
<span class="token number">1</span>               <span class="token number">5901</span>                            <span class="token number">3295</span>            Xtigervnc
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用VNC连接即可</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1694316548629.png" alt="登录桌面"></p>
<p><strong>参考链接</strong><br><a href="https://zhuanlan.zhihu.com/p/638955703">给Rock5a开启远程桌面</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RK3588s</tag>
        <tag>Rock5A</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32PID学习</title>
    <url>/2023/10/01/pid-xue-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PID教程"><a href="#PID教程" class="headerlink" title="PID教程"></a><strong>PID教程</strong></h1><hr>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781828298.gif" alt="PID参数示意"></p>
<h2 id="一、学习目的"><a href="#一、学习目的" class="headerlink" title="一、学习目的"></a>一、学习目的</h2><p><strong>PID</strong>（比例-积分-微分）是一种经典的<strong>闭环控制算法</strong>，其采用反馈的控制回路机制，用于自动调整系统的输出以接近设定点，，广泛用于工业控制系统和需要连续调制控制的其他各种应用中。它有三个组成部分：<strong>比例项Kp</strong>（根据当前误差调整输出）、<strong>积分项Ki</strong>（减小稳态误差）、<strong>微分项Kd</strong>（减小振荡和响应时间）。通过调整这些部分的权重，PID控制器能够适应不同的系统需求，实现稳定而精确的控制。无论是温度控制、速度调节还是位置控制，PID都是一个重要的工具。</p>
<hr>
<h2 id="二、PID简介"><a href="#二、PID简介" class="headerlink" title="二、PID简介"></a>二、PID简介</h2><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781802782.png" alt="PID.png"></p>
<p><a href="https://www.bilibili.com/video/BV1me4y1s7sE/?spm_id_from=333.337.search-card.all.click&amp;vd_source=65cc1b0c6a89ff46e6b6a0afb26e5023">请观看两分钟PID原理视频</a></p>
<ul>
<li><p><strong>Kp</strong>：比例环节是为了加快响应速度快速达到稳定，能减少误差但不能消除误差。</p>
</li>
<li><p><strong>Ki</strong>：积分环节是为了消除稳态误差，只要系统有误差他就一直积分，稳态后不会出现误差，过大会超调。</p>
</li>
<li><p><strong>Kd</strong>：微分环节预测误差的趋势，减少超调量来克服振荡，使系统稳定性提高。</p>
</li>
</ul>
<hr>
<h2 id="三、位置式PID"><a href="#三、位置式PID" class="headerlink" title="三、位置式PID"></a>三、位置式PID</h2><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781816620.png" alt="PID.png"></p>
<ul>
<li>比例P：e(k)           （此次误差）</li>
<li>积分I：∑e(i)          （误差的累加）</li>
<li>微分D：e(k) - e(k-1)  （此次误差-上次误差）</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>PID控制</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32F4驱动USB实现虚拟串口</title>
    <url>/2023/07/15/stm32f4-qu-dong-usb-shi-xian-xu-ni-chuan-kou/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STM32F4驱动USB实现虚拟串口"><a href="#STM32F4驱动USB实现虚拟串口" class="headerlink" title="STM32F4驱动USB实现虚拟串口"></a>STM32F4驱动USB实现虚拟串口</h1><h2 id="实现目的"><a href="#实现目的" class="headerlink" title="实现目的"></a>实现目的</h2><p>使用Dap-link和stlink的时候，就发现这些仿真器上并没有USB转TTL芯片，就可以实现USB转串口，实现虚拟串口，非常方便。这里实测得出，使用USB虚拟串口，可以轻松达到921600波特率，接近1M/s，因为这个虚拟串口实际就是USB通讯，使用USB通讯，模拟COM类通讯端口协议，实现串口通讯。</p>
<p>这个功能主要用于实现单片机通过USB线同上位机通讯，实现速率高（1M/s），稳定性强（USB线+差分信号），操作简单（串口通讯效果）的效果。</p>
<p>最终实现了单片机同上位机进行串口通讯，并编写了类似于HAL库串口通讯的USB串口通信操作函数，包括数据发送，printf发送，堵塞接收，中断接收等函数</p>
<p>注意，此方案单片机作为USB从机，同上位机（主机）通讯，不能够使用USB同使用了USB串口的其他设备通讯，因为他们也是从机。</p>
<h2 id="cubemx初始化"><a href="#cubemx初始化" class="headerlink" title="cubemx初始化"></a>cubemx初始化</h2><p>STM32F407VET6+CubeMx+MDK5</p>
<h3 id="系统时钟初始化"><a href="#系统时钟初始化" class="headerlink" title="系统时钟初始化"></a>系统时钟初始化</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/USB%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%2F1.%E5%A4%96%E9%83%A8%E9%AB%98%E9%80%9F%E6%97%B6%E9%92%9F%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="外部高速时钟初始化"></p>
<h3 id="修改debug方式"><a href="#修改debug方式" class="headerlink" title="修改debug方式"></a>修改debug方式</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/USB%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%2F2.%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE.jpg" alt="调试方式修改"></p>
<h3 id="GPIO配置"><a href="#GPIO配置" class="headerlink" title="GPIO配置"></a>GPIO配置</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/USB%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%2F3.%E6%8C%89%E9%94%AE%20led%E9%85%8D%E7%BD%AE.jpg" alt="按键led配置"></p>
<h3 id="USB外设初始化"><a href="#USB外设初始化" class="headerlink" title="USB外设初始化"></a>USB外设初始化</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/USB%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%2F4.%E5%85%A8%E9%80%9FUSB%E5%A4%96%E8%AE%BE%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="全速USB外设初始化"></p>
<p>啥都不用改，把中断打开记得</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/USB%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%2F5.%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="中断配置"></p>
<h3 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/USB%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%2F6.%E6%97%B6%E9%92%9F%E4%BF%AE%E6%94%B9.jpg" alt="修改时钟"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/USB%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%2F7.%E5%B7%A5%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="配置工程"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/USB%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%2F8.%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE.jpg" alt="目录修改"></p>
<h3 id="keil5修改"><a href="#keil5修改" class="headerlink" title="keil5修改"></a>keil5修改</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/USB%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%2F9.keil%E9%85%8D%E7%BD%AE.jpg" alt="勾选Micolib"></p>
<p><strong>初始化完成</strong></p>
<h2 id="实现HAL库uart通讯功能"><a href="#实现HAL库uart通讯功能" class="headerlink" title="实现HAL库uart通讯功能"></a>实现HAL库uart通讯功能</h2><p><strong>简单使用系统函数 <code>uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)</code>进行通讯</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">/* USER CODE END WHILE */</span>

    <span class="token comment">/* USER CODE BEGIN 3 */</span>
      led_GPIO_Port<span class="token operator">-&gt;</span>ODR<span class="token operator">^=</span>led_Pin<span class="token punctuation">;</span>

      <span class="token function">CDC_Transmit_FS</span><span class="token punctuation">(</span>Tx_Buffer<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>Tx_Buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/USB%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%2F10.%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95%E5%8A%A9%E6%89%8B%E6%88%AA%E5%9B%BE.jpg" alt="效果"></p>
<h3 id="设计USB-CDC-printf格式化输出函数"><a href="#设计USB-CDC-printf格式化输出函数" class="headerlink" title="设计USB_CDC_printf格式化输出函数"></a><strong>设计USB_CDC_printf格式化输出函数</strong></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
  * @brief  USB虚拟串口格式化输出printf实现
  * @param  格式化输入
  * @retval 无
  */</span>
<span class="token keyword">void</span> <span class="token function">usb_printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    va_list args<span class="token punctuation">;</span>
    <span class="token class-name">uint32_t</span> length<span class="token punctuation">;</span>
 
    <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span>
    length <span class="token operator">=</span> <span class="token function">vsnprintf</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>UserTxBufferFS<span class="token punctuation">,</span> APP_TX_DATA_SIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>format<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CDC_Transmit_FS</span><span class="token punctuation">(</span>UserTxBufferFS<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>USB虚拟串口主要使用CDC通讯协议，在usbd_cdc_if.c文件中，有相关函数描述，其中数据中断接收回调函数需要重点关注</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token class-name">int8_t</span> <span class="token function">CDC_Receive_FS</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> Buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> <span class="token operator">*</span>Len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">/* USER CODE BEGIN 6 */</span>
  
  <span class="token comment">/* 定义外部变量 */</span>
  <span class="token keyword">extern</span> <span class="token class-name">uint16_t</span> Rx_Date_Num<span class="token punctuation">,</span>RX_goal_num<span class="token punctuation">;</span>
  <span class="token keyword">extern</span> <span class="token class-name">uint8_t</span> UserRxBuffer<span class="token punctuation">[</span>APP_RX_DATA_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">extern</span> <span class="token class-name">uint8_t</span> Rx_status<span class="token punctuation">;</span>
  <span class="token keyword">extern</span> <span class="token class-name">uint8_t</span><span class="token operator">*</span> p<span class="token punctuation">;</span>

  <span class="token comment">/* 保存接收到的数据 */</span>
  <span class="token function">Rx_date_save</span><span class="token punctuation">(</span>Buf<span class="token punctuation">,</span>UserRxBuffer<span class="token punctuation">,</span><span class="token operator">*</span>Len<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* 如果接收到的数据量小于或等于缓冲区大小，增加接收数据的数量 */</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>Rx_Date_Num<span class="token operator">&lt;=</span>APP_RX_DATA_SIZE<span class="token punctuation">)</span>
      Rx_Date_Num<span class="token operator">+=</span><span class="token operator">*</span>Len<span class="token punctuation">;</span>
  <span class="token comment">/* 如果接收到的数据量大于缓冲区大小，将接收数据的数量设置为缓冲区大小 */</span>
  <span class="token keyword">else</span>
      Rx_Date_Num<span class="token operator">=</span>APP_RX_DATA_SIZE<span class="token punctuation">;</span>

  <span class="token comment">/* 如果接收状态为0 */</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>Rx_status<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">/* 如果接收到的数据量大于或等于目标数据量 */</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Rx_Date_Num<span class="token operator">&gt;=</span>RX_goal_num<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token comment">/* 将用户接收缓冲区的数据复制到p指向的位置 */</span>
      <span class="token function">Rx_buffer_copy</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>UserRxBuffer<span class="token punctuation">,</span>RX_goal_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">/* 减少接收数据的数量 */</span>
        Rx_Date_Num<span class="token operator">-=</span>RX_goal_num<span class="token punctuation">;</span>
      <span class="token comment">/* 将接收状态设置为1 */</span>
      Rx_status<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* 设置USB设备的接收缓冲区 */</span>
  <span class="token function">USBD_CDC_SetRxBuffer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hUsbDeviceFS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* 接收USB数据包 */</span>
  <span class="token function">USBD_CDC_ReceivePacket</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hUsbDeviceFS<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* 返回操作结果 */</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>USBD_OK<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE END 6 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>虚拟串口的接收方式是覆盖式的，相关缓存区大小由宏定义 APP_RX_DATA_SIZE 确定</strong></p>
<p><strong>比方说，本次接受了8个字节数据，分别是，“12345678”，然后发送了4个字节数据，分别是“abcd”，则缓存区数据变为“abcd5678”，原数据会被覆盖</strong></p>
<p><strong>这样是不利于我们接收数据的，如果我要接收128个字节的数据，为防止数据丢失，我会设置256个字节宽度的缓存区，原系统的接受到的数据会被及时转存到用户自定义的缓存区内，随取随用。</strong></p>
<p><strong>所以代码里我们定义了<code>uint8_t UserRxBuffer[APP_RX_DATA_SIZE];</code>用于存储用户想要接收的信息，放置被覆盖，并定义了相关函数，操作读取数据</strong></p>
<h3 id="堵塞型数据接收函数"><a href="#堵塞型数据接收函数" class="headerlink" title="堵塞型数据接收函数*"></a><em>堵塞型数据接收函数</em>*</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
  * @brief  这个函数用于接收USB虚拟串口的数据
  * @param  Rx_Buffer: 接收缓冲区
  * @param  num: 需要接收的数据数量
  * @param  overtime: 超时时间
  * @retval 如果接收成功，返回1，如果超时，返回0
  */</span>
 
<span class="token class-name">uint8_t</span> <span class="token function">usb_vbc_Receive</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> Rx_Buffer<span class="token punctuation">,</span><span class="token class-name">uint16_t</span> num<span class="token punctuation">,</span><span class="token class-name">uint32_t</span> overtime<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> time<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    overtime<span class="token operator">=</span>overtime<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Rx_Date_Num<span class="token operator">&gt;=</span>num<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">Rx_buffer_copy</span><span class="token punctuation">(</span>Rx_Buffer<span class="token punctuation">,</span>UserRxBuffer<span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Rx_Date_Num<span class="token operator">-=</span>num<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>Rx_Date_Num<span class="token operator">&gt;=</span>num<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">Rx_buffer_copy</span><span class="token punctuation">(</span>Rx_Buffer<span class="token punctuation">,</span>UserRxBuffer<span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
                Rx_Date_Num<span class="token operator">-=</span>num<span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
                time<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>time<span class="token operator">&gt;</span>overtime<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="中断型数据接收函数"><a href="#中断型数据接收函数" class="headerlink" title="中断型数据接收函数"></a>中断型数据接收函数</h3><p><strong>内容较少，仅改变几个全局标志位的值，主要操作内容在中断回调函数里</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
  * @brief  开启接收数据，不堵塞，完成接收任务后，全局变量Rx_status置一，否则为0
  * @param  Rx_Buffer: 接收缓冲区
  * @param  num: 需要接收的数据数量
  * @retval 无
  */</span>
<span class="token keyword">void</span> <span class="token function">usb_vbc_Receive_It</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> Rx_Buffer<span class="token punctuation">,</span><span class="token class-name">uint16_t</span> num<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    p<span class="token operator">=</span>Rx_Buffer<span class="token punctuation">;</span>
    RX_goal_num<span class="token operator">=</span>num<span class="token punctuation">;</span>
    Rx_status<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>中断回调函数内的操作</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token class-name">int8_t</span> <span class="token function">CDC_Receive_FS</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> Buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> <span class="token operator">*</span>Len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">/* USER CODE BEGIN 6 */</span>
  
  <span class="token comment">/* 定义外部变量 */</span>
  <span class="token keyword">extern</span> <span class="token class-name">uint16_t</span> Rx_Date_Num<span class="token punctuation">,</span>RX_goal_num<span class="token punctuation">;</span>
  <span class="token keyword">extern</span> <span class="token class-name">uint8_t</span> UserRxBuffer<span class="token punctuation">[</span>APP_RX_DATA_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">extern</span> <span class="token class-name">uint8_t</span> Rx_status<span class="token punctuation">;</span>
  <span class="token keyword">extern</span> <span class="token class-name">uint8_t</span><span class="token operator">*</span> p<span class="token punctuation">;</span>

  <span class="token comment">/* 保存接收到的数据 */</span>
  <span class="token function">Rx_date_save</span><span class="token punctuation">(</span>Buf<span class="token punctuation">,</span>UserRxBuffer<span class="token punctuation">,</span><span class="token operator">*</span>Len<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* 如果接收到的数据量小于或等于缓冲区大小，增加接收数据的数量 */</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>Rx_Date_Num<span class="token operator">&lt;=</span>APP_RX_DATA_SIZE<span class="token punctuation">)</span>
      Rx_Date_Num<span class="token operator">+=</span><span class="token operator">*</span>Len<span class="token punctuation">;</span>
  <span class="token comment">/* 如果接收到的数据量大于缓冲区大小，将接收数据的数量设置为缓冲区大小 */</span>
  <span class="token keyword">else</span>
      Rx_Date_Num<span class="token operator">=</span>APP_RX_DATA_SIZE<span class="token punctuation">;</span>

  <span class="token comment">/* 如果接收状态为0 */</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>Rx_status<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">/* 如果接收到的数据量大于或等于目标数据量 */</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Rx_Date_Num<span class="token operator">&gt;=</span>RX_goal_num<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token comment">/* 将用户接收缓冲区的数据复制到p指向的位置 */</span>
      <span class="token function">Rx_buffer_copy</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>UserRxBuffer<span class="token punctuation">,</span>RX_goal_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">/* 减少接收数据的数量 */</span>
        Rx_Date_Num<span class="token operator">-=</span>RX_goal_num<span class="token punctuation">;</span>
      <span class="token comment">/* 将接收状态设置为1 */</span>
      Rx_status<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* 设置USB设备的接收缓冲区 */</span>
  <span class="token function">USBD_CDC_SetRxBuffer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hUsbDeviceFS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* 接收USB数据包 */</span>
  <span class="token function">USBD_CDC_ReceivePacket</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hUsbDeviceFS<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* 返回操作结果 */</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>USBD_OK<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE END 6 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="其他相关数据操作函数"><a href="#其他相关数据操作函数" class="headerlink" title="其他相关数据操作函数"></a>其他相关数据操作函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
  * @brief  这个函数用于复制接收缓冲区的内容，并将缓存区数据移位
  * @param  Buffer_get: 获取缓冲区
  * @param  Buffer_put: 放置缓冲区
  * @param  num: 要复制的元素数量
  * @retval 无
  */</span>

<span class="token keyword">void</span> <span class="token function">Rx_buffer_copy</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> Buffer_get<span class="token punctuation">,</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> Buffer_put<span class="token punctuation">,</span><span class="token class-name">uint16_t</span> num<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint16_t</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//复制数据</span>
    <span class="token punctuation">{</span>
        Buffer_get<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>Buffer_put<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Rx_Date_Num<span class="token operator">-</span>num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//剩余数据移位</span>
    <span class="token punctuation">{</span>
        Buffer_put<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>Buffer_put<span class="token punctuation">[</span>i<span class="token operator">+</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
  * @brief  这个函数用于将一个数组的内容复制到另一个数组中，而不会丢失接收数组中的原始数据
  * @param  src: 源数组
  * @param  dest: 目标数组
  * @param  n: 源数组中的元素数量
  * @retval 无
  */</span>
<span class="token keyword">void</span> <span class="token function">Rx_date_save</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> src<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span><span class="token operator">*</span> dest<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint16_t</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>num<span class="token operator">=</span>Rx_Date_Num<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token operator">+</span>n<span class="token operator">&gt;</span>APP_RX_DATA_SIZE<span class="token punctuation">)</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment">//超出缓存区大小，这里直接停止。</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        dest<span class="token punctuation">[</span>i<span class="token operator">+</span>num<span class="token punctuation">]</span><span class="token operator">=</span>src<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
  * @brief  这个函数用于获取USB接收缓存区的数据数量
  * @param  无
  * @retval 返回接收的数据数量
  */</span>

<span class="token class-name">uint16_t</span> <span class="token function">usb_Rx_Get_Num</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> Rx_Date_Num<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">/* USER CODE BEGIN 1 */</span>
    <span class="token class-name">uint8_t</span> Rx_Buffer<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">uint8_t</span> Tx_Buffer<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"灵遨老六\n"</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE END 1 */</span>

  <span class="token comment">/* MCU Configuration--------------------------------------------------------*/</span>

  <span class="token comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>
  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN Init */</span>

  <span class="token comment">/* USER CODE END Init */</span>

  <span class="token comment">/* Configure the system clock */</span>
  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN SysInit */</span>

  <span class="token comment">/* USER CODE END SysInit */</span>

  <span class="token comment">/* Initialize all configured peripherals */</span>
  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">MX_USB_DEVICE_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN 2 */</span>
    <span class="token function">usb_vbc_Receive_It</span><span class="token punctuation">(</span>Rx_Buffer<span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE END 2 */</span>

  <span class="token comment">/* Infinite loop */</span>
  <span class="token comment">/* USER CODE BEGIN WHILE */</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">/* USER CODE END WHILE */</span>

    <span class="token comment">/* USER CODE BEGIN 3 */</span>
      led_GPIO_Port<span class="token operator">-&gt;</span>ODR<span class="token operator">^=</span>led_Pin<span class="token punctuation">;</span>
<span class="token comment">//      time=HAL_GetTick();</span>
<span class="token comment">//      CDC_Transmit_FS((uint8_t*)str, strlen(str));</span>
<span class="token comment">//      if(usb_vbc_Receive(Rx_Buffer,16,500)==0)</span>
<span class="token comment">//          usb_printf("超时:%d\n",HAL_GetTick()-time);</span>
<span class="token comment">//      else</span>
<span class="token comment">//          CDC_Transmit_FS((uint8_t*)Rx_Buffer, 16);</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>Rx_status<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
          <span class="token function">CDC_Transmit_FS</span><span class="token punctuation">(</span>Rx_Buffer<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">usb_vbc_Receive_It</span><span class="token punctuation">(</span>Rx_Buffer<span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token comment">//      CDC_Transmit_FS(Tx_Buffer,strlen((char*)Tx_Buffer));</span>
      <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* USER CODE END 3 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>使用USB虚拟串口，用起来很爽，波特率能跑很高，主要可以应用在同ROS主机通讯上；具体细致学习，可以参考开源Dap-link的代码。</strong></p>
<p><a href="dap-link">dap-link</a></p>
<p><strong>另外想使用DMA的话，F4的还没实现，H7的可以，速度应该可以跑很高。</strong></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>F407</tag>
        <tag>USB</tag>
        <tag>虚拟串口</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 I2C教程</title>
    <url>/2023/10/08/i2c-jiao-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STM32-I2C"><a href="#STM32-I2C" class="headerlink" title="STM32 I2C"></a>STM32 I2C</h1><h2 id="I2C简介"><a href="#I2C简介" class="headerlink" title="I2C简介"></a>I2C简介</h2><p>I2C(Inter－Integrated Circuit，集成电路总线)是一种通用的<a href="https://baike.baidu.com/item/%E6%80%BB%E7%BA%BF/108823">总线</a>协议。由Philips公司（2006年迁移到NXP）在1980年代初开发的一种简单、双线双向的同步串行总线，它利用一根时钟线和一根数据线在连接总线的两个器件之间进行信息的传递，为设备之间数据交换提供了一种简单高效的方法。++每个连接到总线上的器件都有唯一的地址，任何器件既可以作为主机也可以作为从机，但同一时刻只允许有一个主机。++</p>
<h2 id="I2C详解"><a href="#I2C详解" class="headerlink" title="I2C详解"></a>I2C详解</h2><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831376373.png" alt="IIC 总线挂载多个器件"></p>
<p><strong>SCL:</strong> 串行时钟线，用于通信双方时钟的同步。<br><strong>SDA:</strong> 串行数据线，用于收发数据。</p>
<ul>
<li>I2C的特点：<ul>
<li>只需要两条总线；</li>
<li>没有严格的波特率要求，例如使用RS232，主设备生成总线时钟；</li>
<li>所有组件之间都存在简单的主/从关系，连接到总线的每个设备均可通过唯一地址进行软件寻址；</li>
<li>I²C是真正的多主设备总线，可提供仲裁和冲突检测；</li>
<li>传输速度；<ul>
<li>标准模式：Standard Mode = 100 Kbps</li>
<li>快速模式：Fast Mode = 400 Kbps</li>
<li>高速模式： High speed mode = 3.4 Mbps</li>
<li>超快速模式： Ultra fast mode = 5 Mbps</li>
</ul>
</li>
<li>连接到相同总线的 IC 数量受到总线的最大电容 <a href="https://blog.csdn.net/qq_38769551/article/details/105108062">400pF 限制</a>。</li>
</ul>
</li>
</ul>
<h3 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h3><p>I2C的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节。</p>
<ul>
<li><p>I2C 数据在消息中传输，消息被分解为数据帧。</p>
</li>
<li><p>每条消息包含：</p>
<ul>
<li>开始条件</li>
<li>停止条件</li>
<li>读取和写入位</li>
<li>ACK/NACK 位&nbsp;</li>
<li>从机地址</li>
<li>数据帧</li>
</ul>
<p>ACK/NACK:应答信号，由接收设备在每个帧后发送，以向发送方发送信号是否成功接收到数据帧 (ACK) 或未成功接收 (NACK)</p>
</li>
</ul>
<ul>
<li>基本读写过程：<ol>
<li>开始条件</li>
<li>地址传送</li>
<li>数据传送</li>
<li>停止条件</li>
</ol>
</li>
</ul>
<h4 id="开始和停止条件："><a href="#开始和停止条件：" class="headerlink" title="开始和停止条件："></a>开始和停止条件：</h4><p> <img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831429408.png" alt="开始与停止条件"></p>
<ul>
<li><p>开始条件：</p>
<ul>
<li>当主设备将==SDA线从高电平切换到低电平，然后将SCL线从高电平切换到低电平 #EE3F4D==时，传输将开始。</li>
<li>向其他从属设备发出信号，表明传输即将发生。</li>
<li>如果两个主机同时发送启动条件想要获得总线的所有权，那么++谁先将 SDA 拉低，谁就“获胜”++。</li>
</ul>
</li>
<li><p>停止条件：</p>
<ul>
<li>所有数据帧发送完毕后，将发送停止条件。</li>
<li>==SCL线先从低电平切换到高电平，然后SDA线从低电平切换到高电平 #EE3F4D==</li>
<li>在正常数据写入操作期间，++当 SCL 为高电平时，SDA 上的值不应更改++，因为这可能会导致错误停止情况。</li>
</ul>
<p>当两个起始信号之间没有停止信号时，即产生了重复起始信号。主机采用这种方法与另一个从机或相同的从机以不同传输方向进行通信（例如：从写入设备到从设备读出）而不释放总线。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831466261.png" alt="重复起始信号"></p>
</li>
</ul>
<h4 id="地址传送："><a href="#地址传送：" class="headerlink" title="地址传送："></a>地址传送：</h4><ul>
<li><p>开始条件或者重新开始条件后面的帧是地址帧（一个字节），用于指定主机通信的对象地址，在发送停止条件之前，指定的从机一直有效。</p>
</li>
<li><p>I2C 通常有 7 位地址，并且只有 127 个不同的 I2C 设备。然而，实际上，I2C 设备的类型要多得多，并且 ++I2C 设备很有可能在总线上具有相同的地址++。为了克服这一限制，许多器件通过外部配置引脚使用双地址以及 10 位地址方案。</p>
</li>
<li><p>10 位地址方案对普通 I2C 协议有两个影响：</p>
<ul>
<li>地址帧现在有两个字节而不是 1 个字节。</li>
<li>第一个字节的前五个最高有效位用于标识 10 位地址，约定为“11110”。</li>
</ul>
</li>
<li><p>7 位寻址模式：<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831479079.png" alt="7 位寻址"></p>
<ul>
<li>地址帧（++8bit++）的==高 7 位为从机地址 #EE3F4D==，地址帧==第 8 位来决定数据帧传送的方向 #EE3F4D==：++7 位从机地址 + 1位 读/写位++，读/写位控制从机的数据传输方向（++0：写   1：读++）</li>
</ul>
</li>
<li><p>10 位寻址模式：<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831489064.png" alt="10位寻址"></p>
<ul>
<li>地址帧有两字节（两帧），第一帧发送头序列（11110XX0，其中 XX 表示 10 位地址的高两位），然后第二帧发送低八位从机地址。</li>
</ul>
</li>
</ul>
<h4 id="数据传送："><a href="#数据传送：" class="headerlink" title="数据传送："></a>数据传送：</h4><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831497559.png" alt="数据传送"></p>
<ul>
<li>发送地址帧并且主设备从从设备接收到 ACK 位后，将开始传输 8 位长的数据。</li>
<li>当主设备定期生成时钟脉冲时，数据由主设备或从设备根据读/写位在 SDA 上发送。</li>
<li>每个数据帧后面都有一个 ACK/NACK 位，以表明数据是否已成功接收。在发送下一个数据帧之前，主机或从机必须接收到 ACK 位</li>
<li>此过程完成后，主设备将向从设备发送停止条件，从而结束传输。</li>
</ul>
<h4 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h4><p>I2C 使用 SDA 信号线来传输数据，使用 SCL 信号线进行数据同步。见图数据有效性。SDA 数据线在 SCL 的每个时钟周期传输一位数据。传输时，SCL 为高电平的时候 SDA 表示的数据有效，即此时的 SDA 为高电平时表示数据“1”，为低电平时表示数据“0”。当 SCL 为低电平时，SDA的数据无效，一般在这个时候 SDA 进行电平切换，为下一次表示数据做好准备。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831506322.png" alt="数据有效性"><br>每次数据传输都以字节为单位，每次传输的字节数不受限制。</p>
<h3 id="综合如下："><a href="#综合如下：" class="headerlink" title="综合如下："></a>综合如下：</h3><h4 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h4><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831515342.png" alt="读数据"><br>若配置的方向传输位为“读数据”方向，广播完地址，接收到应答信号后，从机开始向主机返回数据，数据包大小也为 8 位，从机每发送完一个数据，都会等待主机的应答信号，重复这个过程，可以返回 N 个数据，这个 N 也没有大小限制。当主机希望停止接收数据时，就向从机返回一个非应答信号，则从机自动停止数据传输。</p>
<h4 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h4><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831527781.png" alt="写数据"><br>若配置的方向传输位为“写数据”方向，广播完地址，接收到应答信号后，主机开始正式向从机传输数据 ，数据包的大小为 8 位，主机每发送完一个字节数据，都要等待从机的应答信号，重复这个过程，可以向从机传输 N 个数据，这个 N 没有大小限制。当数据传输结束时，主机向从机发送一个停止传输信号，表示不再传输数据。</p>
<h4 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h4><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831538709.png" alt="读写数据"><br>除了基本的读写，I2C 通讯更常用的是复合格式，该传输过程有两次起始信号 (S)。一般在第一次传输中，主机通过 SLAVE_ADDRESS 寻找到从设备后，发送一段“数据”，这段数据通常用于表示从设备内部的寄存器或存储器地址 (注意区分它与 SLAVE_ADDRESS 的区别)；在第二次的传输中，对该地址的内容进行读或写。也就是说，第一次通讯是告诉从机读写地址，第二次则是读写的实际内容。</p>
<h3 id="STM32的I2C外设"><a href="#STM32的I2C外设" class="headerlink" title="STM32的I2C外设"></a>STM32的I2C外设</h3><p><strong>本节内容来自CSDN博主iiCube的一篇<a href="https://blog.csdn.net/yli001/article/details/129491477?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E6%A8%A1%E6%8B%9FI2C&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-129491477.142%5Ev94%5Einsert_down1&amp;spm=1018.2226.3001.4187">文章</a>，写的十分详细</strong></p>
<p><strong>在讲硬件I2C之前不得不吐槽一下这个硬件I2C外设，有时候就突然会卡在某个事件的检测，需要关闭电源重新启动才有用，不过虽然可能硬件I2C可能会有问题，可能以后不一定用的到但是我们主要是学习如何用硬件实现I2C协议，对我们以后学别的协议肯定会有帮助。</strong></p>
<ul>
<li><p><strong>硬件 I2C：是指直接<code>利用 STM32 芯片中的硬件 I2C 外设</code>，该硬件 I2C 外设跟 USART串口外设类似，只要配置好对应的寄存器，外设就会产生标准串口协议的时序。<code>使用它的I2C 外设则可以方便地通过外设寄存器来控制硬件I2C外设产生 I2C 协议方式的通讯，而不需要内核直接控制引脚的电平</code>。</strong></p>
</li>
<li><p><strong>软件模拟I2C：即直接使用CPU内核按照 I2C 协议的要求控制GPIO输出高低电平。如控制产生 I2C 的起始信号时，先控制作为 SCL 线的 GPIO 引脚输出高电平，然后控制作为 SDA 线的GPIO引脚在此期间完成由高电平至低电平的切换，最后再控制SCL 线切换为低电平，这样就输出了一个标准的 I2C 起始信号。</strong></p>
</li>
</ul>
<p><strong>硬件 I2C 直接使用外设来控制引脚，可以减轻 CPU 的负担。不过使用硬件I2C 时必须使用某些固定的引脚作为 SCL 和 SDA，软件模拟 I2C 则可以使用任意 GPIO 引脚，相对比较灵活。</strong></p>
<h4 id="I2C外设功能框图（重点）"><a href="#I2C外设功能框图（重点）" class="headerlink" title="I2C外设功能框图（重点）"></a>I2C外设功能框图（重点）</h4><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831561758.png" alt="I2C功能框图"></p>
<h4 id="1-通信引脚"><a href="#1-通信引脚" class="headerlink" title="1.通信引脚"></a>1.通信引脚</h4><p><strong>STM32中有两个I2C外设，硬件I2C必须要使用这些引脚，因为这些引脚才连接到I2C引脚，就比如说PB6与PB7引脚就连接到芯片内部的I2C1外设（正点原子STM32Mini板）</strong>。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831572512.png" alt="引脚图"></p>
<h4 id="2-时钟控制逻辑"><a href="#2-时钟控制逻辑" class="headerlink" title="2.时钟控制逻辑"></a>2.时钟控制逻辑</h4><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831582657.png"><br><strong>时钟控制寄存器</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831597278.png" alt="时钟控制寄存器"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831607308.jpg"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831616280.png"><br><strong>这里解释一下为什么是用Tpclk1,因为I2C1外设是挂载在APB1总线上的</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831624243.png"></p>
<p><strong>这里只是演示一下这么计算寄存器写入的值，用库函数我们只要配置好相应寄存器的参数，库函数会帮我计算自动写入的，不要慌。</strong></p>
<h4 id="3-数据控制逻辑"><a href="#3-数据控制逻辑" class="headerlink" title="3.数据控制逻辑"></a>3.数据控制逻辑</h4><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831634487.png"></p>
<ul>
<li><p><strong>当向外发送数据的时候，数据移位寄存器以“数据寄存器”为数据源，把数据一位一位地通过SDA信号线发送出去；</strong></p>
</li>
<li><p><strong>当从外部接收数据的时候，数据移位寄存器把SDA信号线采样到的数据一位一位地存储到“数据寄存器”中。</strong></p>
</li>
</ul>
<p><strong>然后通过CPU或DMA向数据寄存器写入或者读出数据(一般保存在一个数组当中)。</strong></p>
<p><strong>数据寄存器DR</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831643563.png"><br><strong>自身地址寄存器1</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831652073.png"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831660226.png"></p>
<h4 id="4-整体控制逻辑"><a href="#4-整体控制逻辑" class="headerlink" title="4.整体控制逻辑"></a>4.整体控制逻辑</h4><p><strong>这里挑一些重点的寄存器位，我们只需配置好寄存器就可以让I2C外设硬件逻辑自动控制SDA，SCL总线去产生I2C协议的时序如：起始信号、应答信号、停止信号等等</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831667832.png"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831674397.png"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831680923.png"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831688290.png"><br><strong>接下来就是了解的知识：</strong></p>
<ul>
<li><strong>总线错误(BERR)</strong></li>
</ul>
<p><strong>在一个地址或数据字节传输期间，当I2C接口检测到一个外部的停止或起始条件则产生总线错误。此时：</strong></p>
<p><strong>● BERR位被置位为’1’；如果设置了ITERREN位，则产生一个中断；<br>● 在从模式情况下，数据被丢弃，硬件释放总线：<br>─ 如果是<code>错误的开始条件</code>，从设备认为是一个重启动，并等待地址或停止条件。<br>─ 如果是<code>错误的停止条件</code>，从设备按正常的停止条件操作，同时硬件释放总线。<br>● 在主模式情况下，硬件不释放总线，同时不影响当前的传输状态。此时由软件决定是否要中止当前的传输</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831697644.png"><br>主机模式与从机模式<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831705313.png"></p>
<ul>
<li><strong>应答错误(AF)</strong></li>
</ul>
<p><strong>当STM32检测到一个无应答位时，产生应答错误。此时：</strong></p>
<p><strong>● AF位被置位，如果设置了ITERREN位，则产生一个中断；<br>● 当发送器接收到一个NACK时，必须复位通讯：<br>─ 如果是处于从模式，硬件释放总线。<br>─ 如果是处于<code>主模式，软件必须生成一个停止条件</code>。</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831715371.png"></p>
<ul>
<li><strong>过载/欠载错误(OVR)</strong></li>
</ul>
<p><strong>在从模式下，如果禁止时钟延长，I2C接口正在接收数据时，当它已经接收到一个字节(RxNE=1)，但在DR寄存器中前一个字节数据还没有被读出，则发生过载错误。此时：</strong><br><strong>● 最后接收的数据被丢弃；<br>● 在过载错误时，软件应清除RxNE位，发送器应该重新发送最后一次发送的字节。</strong></p>
<p><strong>在从模式下，如果禁止时钟延长，I2C接口正在发送数据时，在下一个字节的时钟到达之前，新的数据还未写入DR寄存器(TxE=1)，则发生欠载错误。此时：<br>● 在DR寄存器中的前一个字节将被重复发出；<br>● 用户应该确定在发生欠载错时，接收端应丢弃重复接收到的数据。发送端应按I2C总线标准在规定的时间更新DR寄存器。<br>在发送第一个字节时，必须在清除ADDR之后并且第一个SCL上升沿之前写入DR寄存器；如果不能做到这点，则接收方应该丢弃第一个数据</strong></p>
<p><strong>STM32做为从机时写入数据和读出数据时应该连续，取个例子主机要10个字节的数据而你只发5个字节此时就发生欠载错误：在下一个字节的时钟到达之前，新的数据还未写入DR寄存器</strong></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831727020.png"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831735681.png"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831745661.png"></p>
<h4 id="5-STM32的I2C外设通信过程（超级重要）"><a href="#5-STM32的I2C外设通信过程（超级重要）" class="headerlink" title="5.STM32的I2C外设通信过程（超级重要）"></a>5.<a href="https://so.csdn.net/so/search?q=STM32&amp;spm=1001.2101.3001.7020">STM32</a>的I2C外设通信过程（超级重要）</h4><p><strong>I2C模式选择：</strong><br><strong>接口可以下述4种模式中的一种运行：<br>● 从发送器模式<br>● 从接收器模式<br>● 主发送器模式<br>● 主接收器模式</strong><br><strong>该模块默认地工作于从模式。接口在<code>生成起始条件后自动地从从模式切换到主模式</code>；当仲裁丢失或产生停止信号时，则从主模式切换到从模式。允许多主机功能。</strong></p>
<ul>
<li><strong>主模式：STM32作为主机通信(发送器与接收器)</strong></li>
<li><strong>从模式：STM32作为从机通信(发送器与接收器)</strong></li>
</ul>
<p><strong><code>这里我主要将STM32做为主机通信</code></strong></p>
<p>I2C主模式：<br><strong>默认情况下，I2C接口总是工作在从模式。从从模式切换到主模式，需要产生一个起始条件。</strong></p>
<p><strong>在主模式时，I2C接口<code>启动数据传输并产生时钟信号</code>。串行数据传输总是以起始条件开始并以停止条件结束。当<code>通过START位在总线上产生了起始条件，设备就进入了主模式</code>。</strong></p>
<h5 id="主发送器"><a href="#主发送器" class="headerlink" title="主发送器"></a>主发送器</h5><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831755417.png"></p>
<ul>
<li><strong>EV5事件</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831762880.png"></li>
</ul>
<p><strong>起始条件当BUSY=0时，设置START=1，I2C接口将产生一个开始条件并切换至主模式(M/SL位置位)</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831769651.png"><br><strong>一旦发出开始条件，我们需要检测SB是否置1，判断是否成功发送起始信号</strong></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831776548.png"><br><strong>● SB位被硬件置位，如果设置了ITEVFEN位，则会产生一个中断。<br>然后主设备等待读SR1寄存器，紧跟着将从地址写入DR寄存器</strong></p>
<ul>
<li><strong>EV6事件</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831786622.png"></li>
</ul>
<p><strong>从机地址的发送</strong></p>
<p><strong>● 在7位地址模式时，只需送出一个地址字节。<br>一旦该地址字节被送出，<br>─ ADDR位被硬件置位，如果设置了ITEVFEN位，则产生一个中断。<br>随后主设备等待一次读SR1寄存器，跟着读SR2寄存器。</strong></p>
<p><strong><code>根据送出从地址的最低位，主设备决定进入发送器模式还是进入接收器模式</code></strong><br><strong>● 在7位地址模式时，<br>─ 要进入发送器模式，主设备发送从地址时置最低位为’0’。<br>─ 要进入接收器模式，主设备发送从地址时置最低位为’1’</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831796547.png"><br><strong>从机地址发送完成从机应答之后检测EV6事件：</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831804575.png"><br><strong>确保从机应答，之后才传输下一个数据，如果你不检测万一地址发送失败或者从机无应答，直接就开始传输数据那传给谁？？</strong></p>
<ul>
<li><p><strong>EV8_1事件:</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831812809.png"><br><strong>这个检测是地址发送完之后进行检测，其实我们只要检测EV6事件就可以了，因为EV6事件成功之后就已经代表地址（数据）发送出去，而且从机还应答了，地址已经发送完成那肯定数据寄存器，与移位寄存器肯定为空呐，所以不检测也可以。</strong></p>
</li>
<li><p><strong>EV8事件</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831819112.png"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831826529.png"><br><strong>我们在发送完一个数据之后必须判断数据寄存器是否为空，数据寄存器为空（TXE），才能向数据寄存器写入新的数据，不然上一个数据们还没有转移到移位寄存器，CPU又写入一个数据则会覆盖上一个数据。</strong></p>
</li>
</ul>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831836439.png"></p>
<ul>
<li><p><strong>EV8_2事件</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831847153.png"><br><strong>在我们发送完最后一个字节之后我们应该检测EV8_2事件，主要检测BTF位。</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831854049.png"><br><strong>为什么呢，主要是检测数据移位寄存器的数据全部发送完成，则才算最后一个字节全部发送完毕</strong>。</p>
</li>
<li><p><strong>关闭通信</strong></p>
</li>
</ul>
<p><strong>在DR寄存器中写入最后一个字节后，通过设置STOP位产生一个停止条件，然后I2C接口将自动回到从模式(M/S位清除)。</strong></p>
<h5 id="主接收器"><a href="#主接收器" class="headerlink" title="主接收器"></a>主接收器</h5><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831873860.png"><br><strong>因为虽然STM32做为接收器，但是STM32是主机，起始信号与发送从机地址都是必须由主机干的活，所以前面EV5，EV6，EV6_1事件与主接收器是一模一样</strong></p>
<ul>
<li><strong>EV7事件</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831883312.png"><br><strong>主机使能ACK位就可以自动接收完数据产生应答信号。</strong></li>
</ul>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831890500.png"><br>接收数据之前，判断数据寄存器是否有数据，也就数据寄存器非空(RNXE)，CPU就可以读取数据寄存器中的数据啦。</p>
<ul>
<li><strong>EV7_1事件</strong><br><strong>关闭通信</strong><br><code>主设备在从设备接收到最后一个字节后发送一个NACK</code>。接收到NACK后，从设备释放对SCL和SDA线的控制；主设备就可以发送一个停止/重起始条件。<br><strong>● 为了在收到最后一个字节后产生一个NACK脉冲，在读倒数第二个数据字节之后(在倒数第二个RxNE事件之后)必须清除ACK位。<br>● 为了产生一个停止/重起始条件，软件必须在读倒数第二个数据字节之后(在倒数第二个RxNE事件之后)设置STOP/START位。</strong><br><strong>● 只接收一个字节时，刚好在EV6之后(EV6_1时，清除ADDR之后)要关闭应答和停止条件的产生位。在产生了停止条件后，I2C接口自动回到从模式(M/SL位被清除)</strong></li>
</ul>
<p><strong>这里产生一个NACK其实就是清除ACK位，将ACK位置0，后面接收的一个字节不在产生应答就是非应答咯</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831897909.png"><br><strong>然后主机产生停止信号</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831903972.png"><br><strong>然后通过判断EV7事件，CPU向数据寄存器读取最后一个字节数据</strong></p>
<p>硬件I2C写代码必须熟练掌握和理解主发送器和主接收器的过程，只要你理解了写代码还不是信手拈来，简简单单，然后写代码你会发送就是上面的过程一模一样</p>
<h4 id="6-I2C初始化结构体"><a href="#6-I2C初始化结构体" class="headerlink" title="6.I2C初始化结构体"></a>6.I2C初始化结构体</h4><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831910694.png"></p>
<ul>
<li><strong>I2C_ClockSpeed</strong></li>
</ul>
<p><strong>设置I2C的传输速率，我们写入的这个参数值不得高于400KHz。<br>在调用初始化函数时，函数会根据我们输入的数值，以及后面输入的占空比参数，经过运算后把时钟因子写入到I2C的时钟控制寄存器CCR。</strong></p>
<p><strong>CCR寄存器不能写入小数类型的时钟因子，影响到SCL的实际频率可能会低于本成员设置的参数值，这时除了通讯稍慢一点以外，不会对I2C的标准通讯造成其它影响。</strong></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831916893.png"><br><strong>初始化函数</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831923057.png" alt="初始化函数解析"></p>
<ul>
<li><strong>I2C_Mode</strong></li>
</ul>
<p><strong>选择I2C的使用方式，有I2C模式(I2C_Mode_I2C )和SMBus主、从模式(I2C_Mode_SMBusHost、 I2C_Mode_SMBusDevice ) 。</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831931671.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>I2C_DutyCycle</strong></li>
</ul>
<p><strong>设置I 2 C的SCL线时钟的占空比。该配置有两个选择，分别为低电平时间比高电平时间为2：1 ( I2C_DutyCycle_2)和16：9(I2C_DutyCycle_16_9)。</strong><br><strong>这个模式随便选反正区别不大。</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831939005.png"></p>
<ul>
<li><strong>I2C_OwnAddress1</strong></li>
</ul>
<p><strong>配置STM32的I2C设备自己的地址，每个连接到I2C总线上的设备都要有一个自己的地址，作为主机也不例外。</strong></p>
<p><strong>地址可设置为7位或10位，只要该地址是I2C总线上<code>唯一</code>的即可。</strong><br><strong>其实可以有两个地址，这里是设置的第一个地址。</strong></p>
<p><strong>第二个地址要另外用库函数设置而且只能是7位</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831946565.png"></p>
<ul>
<li><strong>I2C_Ack_Enable</strong></li>
</ul>
<p><strong>配置I 2 C应答是否使能，设置为使能则可以发送响应信号。一般配置为允许应答(I2C_Ack_Enable）若STM32接收一个字节数据自动产生应答，必须要使能</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831955299.png"></p>
<ul>
<li><strong>I2C_AcknowledgeAddress</strong></li>
</ul>
<p><strong>选择I2C的寻址模式是7位还是10位地址。这需要根据实际连接到I2C总线上设备的地址进行选择，这个成员的配置也影响到I2C_OwnAddress1成员，只有这里设置成10位模式时，I2C_OwnAddress1才支持10位地址。</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831961703.png"><br><strong>配置完成之后调用一下I2C初始化函数就搞定</strong></p>
<p><strong>记得使能I2C外设</strong><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831967667.png"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696831974957.png"></p>
<h3 id="标准库I2C"><a href="#标准库I2C" class="headerlink" title="标准库I2C"></a>标准库I2C</h3><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*初始化结构体*/</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token class-name">uint32_t</span> I2C_ClockSpeed<span class="token punctuation">;</span> <span class="token comment">/*!&lt; 设置 SCL 时钟频率，此值要低于 400000*/</span>
	<span class="token class-name">uint16_t</span> I2C_Mode<span class="token punctuation">;</span> <span class="token comment">/*!&lt; 指定工作模式，可选 I2C 模式及 SMBUS 模式 */</span>
	<span class="token class-name">uint16_t</span> I2C_DutyCycle<span class="token punctuation">;</span> <span class="token comment">/* 指定时钟占空比，可选 low/high = 2:1 及 16:9 模式*/</span>
	<span class="token class-name">uint16_t</span> I2C_OwnAddress1<span class="token punctuation">;</span> <span class="token comment">/*!&lt; 指定自身的 I2C 设备地址 */</span>
	<span class="token class-name">uint16_t</span> I2C_Ack<span class="token punctuation">;</span> <span class="token comment">/*!&lt; 使能或关闭响应 (一般都要使能) */</span>
	<span class="token class-name">uint16_t</span> I2C_AcknowledgedAddress<span class="token punctuation">;</span> <span class="token comment">/*!&lt; 指定地址的长度，可为 7 位及 10 位 */</span>
<span class="token punctuation">}</span> I2C_InitTypeDef<span class="token punctuation">;</span>
<span class="token comment">/*
I2C初始化函数
参数1：要初始化的I2C
参数2：用于初始化的结构体
*/</span>
<span class="token keyword">void</span> <span class="token function">I2C_Init</span><span class="token punctuation">(</span>I2C_TypeDef<span class="token operator">*</span> I2Cx<span class="token punctuation">,</span> I2C_InitTypeDef<span class="token operator">*</span> I2C_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token comment">/*
I2C状态设置
参数1：要设置的I2C
参数2：目标状态
*/</span>
<span class="token keyword">void</span> <span class="token function">I2C_Cmd</span><span class="token punctuation">(</span>I2C_TypeDef<span class="token operator">*</span> I2Cx<span class="token punctuation">,</span> FunctionalState NewState<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
I2C产生开始信号/停止信号
参数1：要设置的I2C
参数2：目标状态
*/</span>
<span class="token keyword">void</span> <span class="token function">I2C_GenerateSTART</span><span class="token punctuation">(</span>I2C_TypeDef<span class="token operator">*</span> I2Cx<span class="token punctuation">,</span> FunctionalState NewState<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">I2C_GenerateSTOP</span><span class="token punctuation">(</span>I2C_TypeDef<span class="token operator">*</span> I2Cx<span class="token punctuation">,</span> FunctionalState NewState<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
I2C应答设置，收到一个字节后是否给从机应答  
参数1：要设置的I2C
参数2：目标状态
*/</span>
<span class="token keyword">void</span> <span class="token function">I2C_AcknowledgeConfig</span><span class="token punctuation">(</span>I2C_TypeDef<span class="token operator">*</span> I2Cx<span class="token punctuation">,</span> FunctionalState NewState<span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token comment">/*
设置主机地址（STM32当从机使用时配置）
参数1：要设置的I2C
参数2：地址
*/</span>

<span class="token keyword">void</span> <span class="token function">I2C_OwnAddress2Config</span><span class="token punctuation">(</span>I2C_TypeDef<span class="token operator">*</span> I2Cx<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> Address<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
发送数据和接收数据
参数1：要收发数据的I2C
参数2：发送的数据，一个字节

接收函数的返回值即为接收数据
*/</span>          

<span class="token keyword">void</span> <span class="token function">I2C_SendData</span><span class="token punctuation">(</span>I2C_TypeDef<span class="token operator">*</span> I2Cx<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> Data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">uint8_t</span> <span class="token function">I2C_ReceiveData</span><span class="token punctuation">(</span>I2C_TypeDef<span class="token operator">*</span> I2Cx<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
发送从机地址（I2C_SendData也可以发送）
参数1：要发送地址的I2C
参数2：从机地址
参数3：数据方向
*/</span>        
<span class="token keyword">void</span> <span class="token function">I2C_Send7bitAddress</span><span class="token punctuation">(</span>I2C_TypeDef<span class="token operator">*</span> I2Cx<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> Address<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> I2C_Direction<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
检查应答位
参数1：要检查的I2C
参数2：要检查的标志位
*/</span>        
<span class="token keyword">void</span> <span class="token function">I2C_CheckEvent</span><span class="token punctuation">(</span>I2C_TypeDef<span class="token operator">*</span> I2Cx<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> I2C_EVENT<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="模拟I2C"><a href="#模拟I2C" class="headerlink" title="模拟I2C"></a>模拟I2C</h3><p>由于I^2^C占用引脚少，协议相对简单，所以可以++用两个IO口来模拟一个I2C++外设</p>
<p>一、基本接口定义</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;为了提高代码的可移植性和使用方便性，定义了一些宏和结构体，下面介绍一下这些宏和结构体。</p>
<p>1、结构体</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;I2C总线有SDA和SCL两个引脚，所以构造一个结构体来定义表示这两个引脚的基本信息：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> SDA_RCC_APB2Periph<span class="token punctuation">;</span><span class="token comment">// SDA脚时钟</span>
    GPIO_TypeDef<span class="token operator">*</span> SDA_Port<span class="token punctuation">;</span><span class="token comment">//SDA脚Port</span>
    <span class="token class-name">uint16_t</span> SDA_Pin<span class="token punctuation">;</span><span class="token comment">//SDA脚Pin</span>
    
    <span class="token class-name">uint32_t</span> SCL_RCC_APB2Periph<span class="token punctuation">;</span><span class="token comment">//SCL脚时钟</span>
    GPIO_TypeDef<span class="token operator">*</span> SCL_Port<span class="token punctuation">;</span><span class="token comment">//SCL脚Port</span>
    <span class="token class-name">uint16_t</span> SCL_Pin<span class="token punctuation">;</span><span class="token comment">//SCL脚Pin</span>
<span class="token punctuation">}</span> <span class="token class-name">sw_i2c_gpio_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2、宏定义</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_USE_7BIT_ADDR</span> <span class="token comment">//如果使用的从机地址是7Bit模式，则打开这个宏，否则注释掉这个宏</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_DELAY</span>                <span class="token expression"><span class="token number">50</span> </span><span class="token comment">// I2C每个Bit之间的延时时间，延时越小I2C的速率越高</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SW_I2C_SCL_LOW</span>          <span class="token expression"><span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>gpio<span class="token operator">-&gt;</span>SCL_Port<span class="token punctuation">,</span>gpio<span class="token operator">-&gt;</span>SCL_Pin<span class="token punctuation">)</span> </span><span class="token comment">// I2C SCL脚输出0</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SW_I2C_SCL_HIGH</span>         <span class="token expression"><span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>gpio<span class="token operator">-&gt;</span>SCL_Port<span class="token punctuation">,</span>gpio<span class="token operator">-&gt;</span>SCL_Pin<span class="token punctuation">)</span> </span><span class="token comment">// I2C SCL脚输出1</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SW_I2C_SDA_LOW</span>          <span class="token expression"><span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>gpio<span class="token operator">-&gt;</span>SDA_Port<span class="token punctuation">,</span>gpio<span class="token operator">-&gt;</span>SDA_Pin<span class="token punctuation">)</span> </span><span class="token comment">// I2C SDA脚输出0</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SW_I2C_SDA_HIGH</span>         <span class="token expression"><span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>gpio<span class="token operator">-&gt;</span>SDA_Port<span class="token punctuation">,</span>gpio<span class="token operator">-&gt;</span>SDA_Pin<span class="token punctuation">)</span> </span><span class="token comment">// I2C SDA脚输出1</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SW_I2C_SDA_INPUT</span>        <span class="token expression"><span class="token function">sw_i2c_set_sda_input</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span> </span><span class="token comment">// 将SDA脚方向设置为输入</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SW_I2C_SDA_OUTPUT</span>        <span class="token expression"><span class="token function">sw_i2c_set_sda_output</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span> </span><span class="token comment">// 将SDA脚方向设置为输出</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SW_I2C_SDA_STATUS</span>        <span class="token expression"><span class="token function">sw_i2c_sda_status</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span> </span><span class="token comment">// 获取SDA脚输入电平状态  </span></span>
  
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">i2c_delay_us</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">)</span>            <span class="token function">SystemDelayUs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> </span><span class="token comment">// 获取SDA脚输入电平状态</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>一、I2C基本操作实现</p>
<p>1、SDA脚输入输出切换及输入状态读取</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**************************************************************************
***                          读取SDA脚的状态                             ***
***************************************************************************/</span>
<span class="token keyword">static</span> <span class="token class-name">uint8_t</span> <span class="token function">sw_i2c_sda_status</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> sda_status<span class="token punctuation">;</span>
    
    sda_status <span class="token operator">=</span> <span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>gpio<span class="token operator">-&gt;</span>SDA_Port<span class="token punctuation">,</span>gpio<span class="token operator">-&gt;</span>SDA_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token keyword">return</span> sda_status<span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**************************************************************************
***                          设置SDA脚为输入                             ***
***************************************************************************/</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sw_i2c_set_sda_input</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>
    
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> gpio<span class="token operator">-&gt;</span>SDA_Pin<span class="token punctuation">;</span>    
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IN_FLOATING<span class="token punctuation">;</span> <span class="token comment">//浮空输入模式</span>
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>
    <span class="token function">GPIO_Init</span> <span class="token punctuation">(</span>gpio<span class="token operator">-&gt;</span>SDA_Port<span class="token punctuation">,</span> <span class="token operator">&amp;</span> GPIO_InitStructure <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**************************************************************************
***                          设置SDA脚为输出                             ***
***************************************************************************/</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sw_i2c_set_sda_output</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>
    
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> gpio<span class="token operator">-&gt;</span>SDA_Pin<span class="token punctuation">;</span>    
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_OD<span class="token punctuation">;</span>   <span class="token comment">//开漏输出模式</span>
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>
    <span class="token function">GPIO_Init</span> <span class="token punctuation">(</span>gpio<span class="token operator">-&gt;</span>SDA_Port<span class="token punctuation">,</span> <span class="token operator">&amp;</span> GPIO_InitStructure <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2、I2C启动</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sw_i2c_start</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// I2C 开始时序：SCL=1时，SDA由1变成0.</span>
    SW_I2C_SDA_HIGH<span class="token punctuation">;</span>         
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    SW_I2C_SCL_HIGH<span class="token punctuation">;</span>           
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    SW_I2C_SDA_LOW<span class="token punctuation">;</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    SW_I2C_SCL_LOW<span class="token punctuation">;</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>3、I2C停止</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sw_i2c_stop</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// I2C 开始时序：SCL=1时，SDA由0变成1.</span>
    SW_I2C_SDA_LOW<span class="token punctuation">;</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    SW_I2C_SCL_HIGH<span class="token punctuation">;</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    SW_I2C_SDA_HIGH<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>4、等待数据接收方反馈ACK</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token class-name">uint8_t</span> <span class="token function">sw_i2c_wait_ack</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> sda_status<span class="token punctuation">;</span>
    <span class="token class-name">uint8_t</span> wait_time<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">uint8_t</span> ack_nack <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    
    <span class="token comment">//先设置SDA脚为输入</span>
    SW_I2C_SDA_INPUT<span class="token punctuation">;</span>
    <span class="token comment">//等待SDA脚被从机拉低</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>SW_I2C_SDA_STATUS<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        wait_time<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment">//如果等待时间过长，则退出等待</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>wait_time<span class="token operator">&gt;=</span><span class="token number">200</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            ack_nack <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// SCL由0变为1，读入ACK状态</span>
    <span class="token comment">// 如果此时SDA=0，则是ACK</span>
    <span class="token comment">// 如果此时SDA=1，则是NACK</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    SW_I2C_SCL_HIGH<span class="token punctuation">;</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//再次将SCL=0，并且将SDA脚设置为输出</span>
    SW_I2C_SCL_LOW<span class="token punctuation">;</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    SW_I2C_SDA_OUTPUT<span class="token punctuation">;</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ack_nack<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>5、发送ACK给数据发送方</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sw_i2c_send_ack</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 发送ACK就是在SDA=0时，SCL由0变成1</span>
    SW_I2C_SDA_LOW<span class="token punctuation">;</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    SW_I2C_SCL_HIGH<span class="token punctuation">;</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    SW_I2C_SCL_LOW<span class="token punctuation">;</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>6、发送NACK给数据发送方</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sw_i2c_send_nack</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 发送NACK就是在SDA=1时，SCL由0变成1</span>
    SW_I2C_SDA_HIGH<span class="token punctuation">;</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    SW_I2C_SCL_HIGH<span class="token punctuation">;</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    SW_I2C_SCL_LOW<span class="token punctuation">;</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>7、主设备向从设备写一个字节</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sw_i2c_write_byte</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> aByte<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">//先将SCL拉低；</span>
        SW_I2C_SCL_LOW<span class="token punctuation">;</span>
        <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//然后在SDA输出数据</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>aByte<span class="token operator">&amp;</span><span class="token number">0x80</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            SW_I2C_SDA_HIGH<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            SW_I2C_SDA_LOW<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//最后将SCL拉高，在SCL上升沿写入数据</span>
        SW_I2C_SCL_HIGH<span class="token punctuation">;</span>
        <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        aByte <span class="token operator">=</span> aByte<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//数据位移</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//写完一个字节只后要将SCL拉低</span>
    SW_I2C_SCL_LOW<span class="token punctuation">;</span>
    <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>8、主设备从从设备读一个字节</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token class-name">uint8_t</span> <span class="token function">sw_i2c_read_byte</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> i<span class="token punctuation">,</span>aByte<span class="token punctuation">;</span>
    
    <span class="token comment">//先将SDA脚设置为输入</span>
    SW_I2C_SDA_INPUT<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">//数据位移</span>
        aByte <span class="token operator">=</span> aByte <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">//延时等待SDA数据稳定</span>
        <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//SCL=1，锁定SDA数据</span>
        SW_I2C_SCL_HIGH<span class="token punctuation">;</span>
        <span class="token function">i2c_delay_us</span><span class="token punctuation">(</span>I2C_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//读取SDA状态</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>SW_I2C_SDA_STATUS<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            aByte <span class="token operator">|=</span> <span class="token number">0x01</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//SCL=0，解除锁定</span>
        SW_I2C_SCL_LOW<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//读完一个字节，将SDA重新设置为输出</span>
    SW_I2C_SDA_OUTPUT<span class="token punctuation">;</span>
    <span class="token keyword">return</span> aByte<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>二、I2C传输数据函数实现</p>
<p>1、模拟I2C初始化</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sw_i2c_init</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>
 
    <span class="token function">RCC_APB2PeriphClockCmd</span> <span class="token punctuation">(</span> gpio<span class="token operator">-&gt;</span>SCL_RCC_APB2Periph<span class="token punctuation">,</span> ENABLE <span class="token punctuation">)</span><span class="token punctuation">;</span>                                                                
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> gpio<span class="token operator">-&gt;</span>SCL_Pin<span class="token punctuation">;</span>    
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_OD<span class="token punctuation">;</span>   <span class="token comment">//开漏输出模式   </span>
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>
    <span class="token function">GPIO_Init</span> <span class="token punctuation">(</span>gpio<span class="token operator">-&gt;</span>SCL_Port<span class="token punctuation">,</span> <span class="token operator">&amp;</span> GPIO_InitStructure <span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">RCC_APB2PeriphClockCmd</span> <span class="token punctuation">(</span> gpio<span class="token operator">-&gt;</span>SDA_RCC_APB2Periph<span class="token punctuation">,</span> ENABLE <span class="token punctuation">)</span><span class="token punctuation">;</span>                                                                
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> gpio<span class="token operator">-&gt;</span>SDA_Pin<span class="token punctuation">;</span>    
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_OD<span class="token punctuation">;</span>   <span class="token comment">//开漏输出模式  </span>
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>
    <span class="token function">GPIO_Init</span> <span class="token punctuation">(</span>gpio<span class="token operator">-&gt;</span>SDA_Port<span class="token punctuation">,</span> <span class="token operator">&amp;</span> GPIO_InitStructure <span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    SW_I2C_SCL_HIGH<span class="token punctuation">;</span>
    SW_I2C_SDA_HIGH<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2、主设备向从设备写N个字节数据</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sw_i2c_write_nBytes</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> i2c_addr<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span>data<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> j<span class="token punctuation">;</span>
    
    <span class="token comment">//如果使用的是7bit地址，需要左位移一位</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">I2C_USE_7BIT_ADDR</span></span>
    i2c_addr <span class="token operator">=</span> i2c_addr<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    
    <span class="token comment">//启动I2C</span>
    <span class="token function">sw_i2c_start</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//写I2C从机地址，写操作</span>
    <span class="token function">sw_i2c_write_byte</span><span class="token punctuation">(</span>gpio<span class="token punctuation">,</span>i2c_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//如果从机响应ACC则继续，如果从机未响应ACK则停止</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sw_i2c_wait_ack</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    
    <span class="token comment">//开始写n个字节数据</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">sw_i2c_write_byte</span><span class="token punctuation">(</span>gpio<span class="token punctuation">,</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 每写一个字节数据后，都要等待从机回应ACK</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sw_i2c_wait_ack</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">//停止I2C</span>
    err<span class="token operator">:</span>
    <span class="token function">sw_i2c_stop</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>3、主设备从从设备读取N个字节数据</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sw_i2c_read_nBytes</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> i2c_addr<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> j<span class="token punctuation">;</span>
    
    <span class="token comment">//如果使用的是7bit地址，需要左位移一位</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">I2C_USE_7BIT_ADDR</span></span>
    i2c_addr <span class="token operator">=</span> i2c_addr<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    
    <span class="token comment">//启动I2C</span>
    <span class="token function">sw_i2c_start</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//写I2C从机地址，读操作</span>
    <span class="token function">sw_i2c_write_byte</span><span class="token punctuation">(</span>gpio<span class="token punctuation">,</span>i2c_addr<span class="token operator">|</span><span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//如果从机响应ACC则继续，如果从机未响应ACK则停止</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sw_i2c_wait_ack</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    <span class="token comment">//开始读n个字节数据</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        buf<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">sw_i2c_read_byte</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 每读一个字节数据后，都要发送ACK给从机</span>
        <span class="token function">sw_i2c_send_ack</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">//停止I2C</span>
    err<span class="token operator">:</span>
    <span class="token function">sw_i2c_stop</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>4、主设备向从设备16Bit长度的寄存器地址读取N个字节</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sw_i2c_send2read_16bit</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> i2c_addr<span class="token punctuation">,</span><span class="token class-name">uint16_t</span> reg<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> j<span class="token punctuation">;</span>
    
    <span class="token comment">//如果使用的是7bit地址，需要左位移一位</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">I2C_USE_7BIT_ADDR</span></span>
    i2c_addr <span class="token operator">=</span> i2c_addr<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token comment">//启动I2C</span>
    <span class="token function">sw_i2c_start</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//写I2C从机地址，写操作</span>
    <span class="token function">sw_i2c_write_byte</span><span class="token punctuation">(</span>gpio<span class="token punctuation">,</span>i2c_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//如果从机响应ACC则继续，如果从机未响应ACK则停止</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sw_i2c_wait_ack</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    
    <span class="token comment">//写寄存器地址高8位</span>
    <span class="token function">sw_i2c_write_byte</span><span class="token punctuation">(</span>gpio<span class="token punctuation">,</span><span class="token punctuation">(</span>reg<span class="token operator">&gt;&gt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sw_i2c_wait_ack</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    <span class="token comment">//写寄存器地址低8位</span>
    <span class="token function">sw_i2c_write_byte</span><span class="token punctuation">(</span>gpio<span class="token punctuation">,</span>reg<span class="token operator">&amp;</span><span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sw_i2c_wait_ack</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    
    <span class="token comment">//重新启动I2C</span>
    <span class="token function">sw_i2c_start</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//写I2C从机地址，读操作</span>
    <span class="token function">sw_i2c_write_byte</span><span class="token punctuation">(</span>gpio<span class="token punctuation">,</span>i2c_addr<span class="token operator">|</span><span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sw_i2c_wait_ack</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    <span class="token comment">//开始读n个字节数据</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        buf<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">sw_i2c_read_byte</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 每读一个字节数据后，都要发送ACK给从机</span>
        <span class="token function">sw_i2c_send_ack</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//停止I2C</span>
    err<span class="token operator">:</span>
    <span class="token function">sw_i2c_stop</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>5、主设备向从设备8Bit长度的寄存器地址读取N个字节</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sw_i2c_send2read_8bit</span><span class="token punctuation">(</span><span class="token class-name">sw_i2c_gpio_t</span> <span class="token operator">*</span>gpio<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> i2c_addr<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> reg<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> j<span class="token punctuation">;</span>
    
    <span class="token comment">//如果使用的是7bit地址，需要左位移一位</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">I2C_USE_7BIT_ADDR</span></span>
    i2c_addr <span class="token operator">=</span> i2c_addr<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token comment">//启动I2C</span>
    <span class="token function">sw_i2c_start</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//写I2C从机地址，写操作</span>
    <span class="token function">sw_i2c_write_byte</span><span class="token punctuation">(</span>gpio<span class="token punctuation">,</span>i2c_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//如果从机响应ACC则继续，如果从机未响应ACK则停止</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sw_i2c_wait_ack</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    
    <span class="token comment">//写寄存器地址</span>
    <span class="token function">sw_i2c_write_byte</span><span class="token punctuation">(</span>gpio<span class="token punctuation">,</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sw_i2c_wait_ack</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    
    <span class="token comment">//重新启动I2C</span>
    <span class="token function">sw_i2c_start</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//写I2C从机地址，读操作</span>
    <span class="token function">sw_i2c_write_byte</span><span class="token punctuation">(</span>gpio<span class="token punctuation">,</span>i2c_addr<span class="token operator">|</span><span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sw_i2c_wait_ack</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    <span class="token comment">//开始读n个字节数据</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        buf<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">sw_i2c_read_byte</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 每读一个字节数据后，都要发送ACK给从机</span>
        <span class="token function">sw_i2c_send_ack</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//停止I2C</span>
    err<span class="token operator">:</span>
    <span class="token function">sw_i2c_stop</span><span class="token punctuation">(</span>gpio<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32,标准库,I2C</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 Systick定时器延时</title>
    <url>/2023/10/01/systick-ding-shi-qi-yan-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Systick定时器延时"><a href="#Systick定时器延时" class="headerlink" title="Systick定时器延时"></a><strong>Systick定时器延时</strong></h1><h2 id="一、系统定时器"><a href="#一、系统定时器" class="headerlink" title="一、系统定时器"></a>一、系统定时器</h2><hr>
<h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. 目的</h3><p>Systick定时器常用来做延时，或者实时系统的心跳时钟。这样可以节省MCU资源，不用浪费一个定时器。</p>
<h3 id="2-简介"><a href="#2-简介" class="headerlink" title="2. 简介"></a>2. 简介</h3><p>SysTick 叫做系统滴答时钟、系统定时器，属于 Cortex-M4内核中的一个外设(外围设备)，也是属于NVIC的一部分，并且是24bit向下递减的计数器。</p>
<p><strong>==最大计数：==</strong> 2^24-1 （向下计数到0，然后触发中断）</p>
<h3 id="3-SysTick寄存器"><a href="#3-SysTick寄存器" class="headerlink" title="3. SysTick寄存器"></a>3. SysTick寄存器</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">寄存器</th>
<th align="center">名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">CTRL</td>
<td align="center">Systick控制和状态寄存器</td>
<td align="center">使能Systick定时器并设置时钟源</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">LOAD</td>
<td align="center">Systick自动重装载寄存器</td>
<td align="center">当倒数至零时，将被重装载值</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">VAL</td>
<td align="center">Systick当前值寄存器</td>
<td align="center">读取时返回当前倒数值，写它则使之清零</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">CALB</td>
<td align="center">Systick校准值寄存器</td>
<td align="center">不常用</td>
</tr>
</tbody></table>
<h4 id="（1）Systick控制和状态寄存器"><a href="#（1）Systick控制和状态寄存器" class="headerlink" title="（1）Systick控制和状态寄存器"></a>（1）Systick控制和状态寄存器</h4><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696781991874.png" alt="Sys-Tick.png"></p>
<p>==外部时钟==是 HCLK(AHB总线时钟) 的1/8  （stm32f401 是 168/8=21M）<br>==内核时钟==是 HCLK时钟 （stm32f401 是 84M）</p>
<h4 id="（2）Systick自动重装载寄存器"><a href="#（2）Systick自动重装载寄存器" class="headerlink" title="（2）Systick自动重装载寄存器"></a>（2）Systick自动重装载寄存器</h4><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696782004933.png" alt="Sys-Tick.png"></p>
<h4 id="（3）Systick当前值寄存器"><a href="#（3）Systick当前值寄存器" class="headerlink" title="（3）Systick当前值寄存器"></a>（3）Systick当前值寄存器</h4><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696782018281.png" alt="Sys-Tick.png"></p>
<h4 id="（4）Systick校准值寄存器"><a href="#（4）Systick校准值寄存器" class="headerlink" title="（4）Systick校准值寄存器"></a>（4）Systick校准值寄存器</h4><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696782030472.png" alt="Sys-Tick.png"></p>
<h3 id="4-计时原理"><a href="#4-计时原理" class="headerlink" title="4. 计时原理"></a>4. 计时原理</h3><blockquote>
<p><strong>time = 中断次数*一次中断时间</strong><br>重装载次数为n，一次中断时间为t=1/SYSCLK，中断时间为T;<br><strong>T = n * t</strong></p>
</blockquote>
<hr>
<h2 id="二、精准延时函数"><a href="#二、精准延时函数" class="headerlink" title="二、精准延时函数"></a>二、精准延时函数</h2><h3 id="1-固件库函数延时"><a href="#1-固件库函数延时" class="headerlink" title="1. 固件库函数延时"></a>1. 固件库函数延时</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//全局变量</span>
<span class="token keyword">void</span> <span class="token function">SysTick_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span> 
  	<span class="token comment">//uint32_t SystemCoreClock = 84000000;</span>
  	<span class="token comment">//SystemFrequency / 1000     1ms    中断一次</span>
  	<span class="token comment">//SystemFrequency / 100000   10us   中断一次</span>
  	<span class="token comment">//SystemFrequency / 1000000  1us    中断一次</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SysTick_Config</span><span class="token punctuation">(</span>SystemCoreClock<span class="token operator">/</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">/*让系统中断一次耗时1us*/</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">delay_us</span><span class="token punctuation">(</span>__IO u32 nTime<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    n <span class="token operator">=</span>nTime<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">delay_ms</span><span class="token punctuation">(</span>__IO u32 nTime<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    n <span class="token operator">=</span>nTime<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">SysTick_Handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">!=</span><span class="token number">0x00</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        n<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-寄存器延时"><a href="#2-寄存器延时" class="headerlink" title="2. 寄存器延时"></a>2. 寄存器延时</h3><h5 id="寄存器延时比固件库函数写的更精简，推荐使用这种延时。"><a href="#寄存器延时比固件库函数写的更精简，推荐使用这种延时。" class="headerlink" title="寄存器延时比固件库函数写的更精简，推荐使用这种延时。"></a>寄存器延时比固件库函数写的更精简，推荐使用这种延时。</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>     <span class="token macro-name">PLL_m</span>       <span class="token expression"><span class="token number">8</span></span></span>

<span class="token comment">/*----------------Systick微秒级延时----------------*/</span>
<span class="token keyword">void</span> <span class="token function">delay_us</span><span class="token punctuation">(</span>u32 nus<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 u32 temp<span class="token punctuation">;</span>
 
 SysTick<span class="token operator">-&gt;</span>LOAD <span class="token operator">=</span> SystemCoreClock<span class="token operator">/</span>PLL_m<span class="token operator">/</span><span class="token number">1000000</span><span class="token operator">*</span>nus<span class="token punctuation">;</span><span class="token comment">//设置重装载值 = 84000000/8/1000000 * n    (1us中断一次)</span>
 
 SysTick<span class="token operator">-&gt;</span>VAL<span class="token operator">=</span><span class="token number">0X00</span><span class="token punctuation">;</span><span class="token comment">//清空计数器</span>
 SysTick<span class="token operator">-&gt;</span>CTRL<span class="token operator">=</span><span class="token number">0X01</span><span class="token punctuation">;</span><span class="token comment">//使能，减到零是无动作，采用外部时钟源</span>
 <span class="token keyword">do</span>
 <span class="token punctuation">{</span>
  temp<span class="token operator">=</span>SysTick<span class="token operator">-&gt;</span>CTRL<span class="token punctuation">;</span><span class="token comment">//读取当前倒计数值</span>
 <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>temp<span class="token operator">&amp;</span><span class="token number">0x01</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>temp<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待时间到达</span>
 
    SysTick<span class="token operator">-&gt;</span>CTRL<span class="token operator">=</span><span class="token number">0x00</span><span class="token punctuation">;</span> <span class="token comment">//关闭计数器</span>
    SysTick<span class="token operator">-&gt;</span>VAL <span class="token operator">=</span><span class="token number">0X00</span><span class="token punctuation">;</span> <span class="token comment">//清空计数器</span>
<span class="token punctuation">}</span>

<span class="token comment">/*----------------Systick毫秒级延时----------------*/</span>
<span class="token keyword">void</span> <span class="token function">delay_ms</span><span class="token punctuation">(</span>u16 nms<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 u32 temp<span class="token punctuation">;</span>
 SysTick<span class="token operator">-&gt;</span>LOAD <span class="token operator">=</span> SystemCoreClock<span class="token operator">/</span>PLL_m<span class="token operator">/</span><span class="token number">1000</span><span class="token operator">*</span>nms<span class="token punctuation">;</span><span class="token comment">//设置重装载值 = 84000000/8/1000 * n  (1ms中断一次)</span>
 SysTick<span class="token operator">-&gt;</span>VAL<span class="token operator">=</span><span class="token number">0X00</span><span class="token punctuation">;</span><span class="token comment">//清空计数器</span>
 SysTick<span class="token operator">-&gt;</span>CTRL<span class="token operator">=</span><span class="token number">0X01</span><span class="token punctuation">;</span><span class="token comment">//使能，减到零是无动作，采用外部时钟源</span>
 <span class="token keyword">do</span>
 <span class="token punctuation">{</span>
  temp<span class="token operator">=</span>SysTick<span class="token operator">-&gt;</span>CTRL<span class="token punctuation">;</span><span class="token comment">//读取当前倒计数值</span>
 <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>temp<span class="token operator">&amp;</span><span class="token number">0x01</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>temp<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待时间到达</span>
    SysTick<span class="token operator">-&gt;</span>CTRL<span class="token operator">=</span><span class="token number">0x00</span><span class="token punctuation">;</span> <span class="token comment">//关闭计数器</span>
    SysTick<span class="token operator">-&gt;</span>VAL <span class="token operator">=</span><span class="token number">0X00</span><span class="token punctuation">;</span> <span class="token comment">//清空计数器</span>
<span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-软延时"><a href="#3-软延时" class="headerlink" title="3. 软延时"></a>3. 软延时</h3><h5 id="在延时精度要求低的情况下建议采用软延时，减少中断次数。"><a href="#在延时精度要求低的情况下建议采用软延时，减少中断次数。" class="headerlink" title="在延时精度要求低的情况下建议采用软延时，减少中断次数。"></a>在延时精度要求低的情况下建议采用软延时，减少中断次数。</h5><pre class="line-numbers language-none"><code class="language-none">/*----------------软微秒级延时----------------*/
void Delay_us(uint32_t Delay_us)
{    
  volatile unsigned int num;
  volatile unsigned int t;
 
  
  for (num = 0; num &lt; Delay_us; num++)
  {
    t = 11;
    while (t != 0)
    {
      t--;
    }
  }
}
/*----------------软毫秒级延时----------------*/
void Delay_ms(uint16_t Delay_ms)
{    
  volatile unsigned int num;
  for (num = 0; num &lt; Delay_ms; num++)
  {
    Delay_us(1000);
  }
}

/*----------------软I2C延时----------------*/
void I2C_Delay(void)
{
	uint8_t i;

	for (i = 0; i &lt; 100; i++);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="三、编程总结"><a href="#三、编程总结" class="headerlink" title="三、编程总结"></a>三、编程总结</h2><ol>
<li>注意systick的时钟,首先需要先设置systick时钟源。</li>
<li>接着设置重装载寄存器的值。</li>
<li>清除当前数值寄存器的值。</li>
<li>配置控制与状态寄存器。</li>
<li>在main函数中循环调用延时函数实现灯闪烁。</li>
<li>systick延时在之后起着重要作用，许多程序涉及到延时函数的调用，因此写好一个精准的延时函数必不可少！</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>Systick定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32定时器功能介绍</title>
    <url>/2023/10/01/tim/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="TIM定时器"><a href="#TIM定时器" class="headerlink" title="TIM定时器"></a>TIM定时器</h1><p>定时器 (Timer) 最基本的功能就是定时了，比如定时发送USART 数据、定时采集 AD 数据等等。如果把定时器与 GPIO 结合起来使用的话可以实现非常丰富的功能，可以测量输入信号的脉冲宽度，可以生产输出波形。定时器生产 PWM 控制电机状态是工业控制普遍方法，这方面知识非常有必要深入了解。</p>
<p>STM32F103 有众多的定时器，其中包括 2 个基本定时器（TIM6 和 TIM7）、4 个通用定时器（TIM2~TIM5）、2 个高级控制定时器（TIM1 和 TIM8），这些定时器彼此完全独立，不共享任何资源。为了更好的区别各个定时器的特性，我制作了一个表格。</p>
<table>
<thead>
<tr>
<th>定时器类型</th>
<th>定时器</th>
<th>定时器位数</th>
<th>计数模式</th>
<th>预分频系数（整数）</th>
<th>产生DMA 请求</th>
<th>捕获/比较通道</th>
<th>互补输出</th>
</tr>
</thead>
<tbody><tr>
<td>基本定时器</td>
<td>TIM6，TIM7</td>
<td>16</td>
<td>递增</td>
<td>1~65536</td>
<td>可以</td>
<td>0</td>
<td>无</td>
</tr>
<tr>
<td>通用定时器</td>
<td>TIM2，TIM3<br>TIM4，TIM5</td>
<td>16</td>
<td>递增、递减、中央对齐</td>
<td>1~65536</td>
<td>可以</td>
<td>4</td>
<td>无</td>
</tr>
<tr>
<td>高级定时器</td>
<td>TIM1，TIM8</td>
<td>16</td>
<td>递增、递减、中央对齐</td>
<td>1~65536</td>
<td>可以</td>
<td>4</td>
<td>有</td>
</tr>
</tbody></table>
<p>STM32F103C8T6定时器资源：TIM1,TIM2,TIM3,TIM4</p>
<h2 id="基本定时器"><a href="#基本定时器" class="headerlink" title="基本定时器"></a>基本定时器</h2><p>F103c8t6并不含有基本定时器资源，但基本定时器比高级控制定时器和通用定时器功能少，结构简单，理解起来更容易.就功能上来说通用定时器包含所有基本定时器功能，而高级控制定时器包含通用定时器所有功能。所以高级控制定时器功能繁多，但也是最难理解的，本章我们先选择最简单的基本定时器进行讲解。基本定时器主要两个功能，第一就是基本定时功能，生成时基，第二就是专门用于驱动数模转换器(DAC)。驱动DAC部分本文章不做过多描述。</p>
<p>F103有两个基本定时器TIM6和TIM7，功能完全一样，但所用资源彼此都完全独立，可以同时使用。在本章内容中，以TIMx统称基本定时器。</p>
<p>基本上定时器 TIM6 和 TIM7 是一个 16 位向上递增的定时器，当我在自动重载寄存器(TIMx_ARR) 添加一个计数值后并使能 TIMx，计数寄存器 (TIMx_CNT) 就会从 0 开始递增，当TIMx_CNT 的数值与 TIMx_ARR 值相同时就会生成事件并把 TIMx_CNT 寄存器清 0，完成一次循环过程。如果没有停止定时器就循环执行上述过程。这些只是大概的流程，希望大家有个感性认识，下面细讲整个过程。</p>
<h3 id="基本定时器功能框图"><a href="#基本定时器功能框图" class="headerlink" title="基本定时器功能框图"></a>基本定时器功能框图</h3><p>基本定时器的功能框图包含了基本定时器最核心内容，掌握了功能框图，对基本定时器就有一个整体的把握，在编程时思路就非常清晰，见图基本定时器功能框图。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696779146907.png" alt="基本定时器功能框图"></p>
<p>首先先看图基本定时器功能框图 中绿色框内容，第一个是带有阴影的方框，方框内容一般是一个寄存器名称，比如图中主体部分的自动重载寄存器 (TIMx_ARR) 或 PSC 预分频器 (TIMx_PSC)，这里要特别突出的是阴影这个标志的作用，它表示这个寄存器还自带有影子寄存器，在硬件结构上实际是有两个寄存器，源寄存器是我们可以进行读写操作，而影子寄存器我们是完全无法操作的，有内部硬件使用。影子寄存器是在程序运行时真正起到作用的，源寄存器只是给我们读写用的，只有在特定时候 (特定事件发生时) 才把源寄存器的值拷贝给它的影子寄存器。多个影子寄存器一起使用可以到达同步更新多个寄存器内容的目的。<br>接下来是一个指向右下角的图标，它表示一个事件，而一个指向右上角的图标表示中断和 DMA 输出。这个我们把它放在图中主体更好理解。图中的自动重载寄存器有影子寄存器，它左边有一 个带有“U”字母的事件图标，表示在更新事件生成时就把自动重载寄存器内容拷贝到影子寄存 器内，这个与上面分析是一致。寄存器右边的事件图标、中断和 DMA 输出图标表示在自动重载 寄存器值与计数器寄存器值相等时生成事件、中断和 DMA 输出。</p>
<h3 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h3><p>定时器要实现计数必须有个时钟源，基本定时器时钟只能来自内部时钟，高级控制定时器和通用定时器还可以选择外部时钟源或者直接来自其他定时器等待模式。我们可以通过 RCC 专用时钟配置寄存器 (RCC_DCKCFGR) 的 TIMPRE 位设置所有定时器的时钟频率，我们一般设置该位为默认值 0，即 TIMxCLK 为总线时钟的两倍，使得表各个定时器特性 中可选的最大定时器时钟为84MHz，即基本定时器的内部时钟 (CK_INT) 频率为 84MHz。基本定时器只能使用内部时钟，当 TIM6 和 TIM7 控制寄存器 1(TIMx_CR1) 的 CEN 位置 1 时，启动基本定时器，并且预分频器的时钟来源就是 CK_INT。对于高级控制定时器和通用定时器的时钟源可以来找控制器外部时钟、其他定时器等等模式，较为复杂，会在相关教程中详细介绍。</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>基本定时器计数过程主要涉及到三个寄存器内容，分别是计数器寄存器 (TIMx_CNT)、预分频器寄存器 (TIMx_PSC)、自动重载寄存器 (TIMx_ARR)，这三个寄存器都是 16 位有效数字，即可设置值为 0 至 65535。<br>首先我们来看图基本定时器功能框图 中预分频器 PSC，它有一个输入时钟 CK_PSC 和一个输出时钟 CK_CNT。输入时钟 CK_PSC 来源于控制器部分，基本定时器只有内部时钟源所以 CK_PSC 实际等于 CK_INT，即 90MHz。在不同应用场所，经常需要不同的定时频率，通过设置预分频器 PSC的值可以非常方便得到不同的 CK_CNT，实际计算为：fCK_CNT 等于 fCK_PSC/(PSC[15:0]+1)。图基本定时器时钟源分频 是将预分频器 PSC 的值从 1 改为 4 时计数器时钟变化过程。原来是 1 分频，CK_PSC 和 CK_CNT 频率相同。向 TIMx_PSC 寄存器写入新值时，并不会马上更新 CK_CNT输出频率，而是等到更新事件发生时，把 TIMx_PSC 寄存器值更新到影子寄存器中，使其真正产生效果。更新为 4 分频后，在CK_PSC 连续出现 4 个脉冲后 CK_CNT 才产生一个脉冲。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696779163480.png" alt="计数器"></p>
<h3 id="定时器周期计算"><a href="#定时器周期计算" class="headerlink" title="定时器周期计算"></a>定时器周期计算</h3><p>经过上面分析，我们知道定时事件生成时间主要由 TIMx_PSC 和 TIMx_ARR 两个寄存器值决定，这个也就是定时器的周期。比如我们需要一个 1s 周期的定时器，具体这两个寄存器值该如何设置内。假设，我们先设置 TIMx_ARR 寄存器值为 9999，即当 TIMx_CNT 从 0 开始计算，刚好等于 9999 时生成事件，总共计数 10000 次，那么如果此时时钟源周期为 100us 即可得到刚好 1s 的定时周期。<br>接下来问题就是设置 TIMx_PSC 寄存器值使得 CK_CNT 输出为 100us 周期 (10000Hz) 的时钟。预分频器的输入时钟 CK_PSC 为 84MHz，所以设置预分频器值为 (8400-1) 即可满足。</p>
<h3 id="定时器初始化结构体详解"><a href="#定时器初始化结构体详解" class="headerlink" title="定时器初始化结构体详解"></a>定时器初始化结构体详解</h3><p>标 准 库 函 数 对 定 时 器 外 设 建 立 了 四 个 初 始 化 结 构 体， 基 本 定 时 器 只 用 到 其 中 一 个 即TIM_TimeBaseInitTypeDef，该结构体成员用于设置定时器基本工作参数，并由定时器基本初始化配置函数 TIM_TimeBaseInit 调用，这些设定参数将会设置定时器相应的寄存器，达到配置定时器工作环境的目的。这一章我们只介绍 TIM_TimeBaseInitTypeDef 结构体，其他结构体将在相关教程中介绍。<br>初始化结构体和初始化库函数配合使用是标准库精髓所在，理解了初始化结构体每个成员意义基本上就可以对该外设运用自如了。初始化结构体定义在 stm32f4xx_tim.h 文件中，初始化库函数定义在 stm32f4xx_tim.c 文件中，编程时我们可以结合这两个文件内注释使用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token class-name">uint16_t</span> TIM_Prescaler<span class="token punctuation">;</span> <span class="token comment">// 预分频器</span>
	<span class="token class-name">uint16_t</span> TIM_CounterMode<span class="token punctuation">;</span> <span class="token comment">// 计数模式</span>
	<span class="token class-name">uint32_t</span> TIM_Period<span class="token punctuation">;</span> <span class="token comment">// 定时器周期</span>
	<span class="token class-name">uint16_t</span> TIM_ClockDivision<span class="token punctuation">;</span> <span class="token comment">// 时钟分频</span>
	<span class="token class-name">uint8_t</span> TIM_RepetitionCounter<span class="token punctuation">;</span> <span class="token comment">// 重复计算器</span>
<span class="token punctuation">}</span> TIM_TimeBaseInitTypeDef<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>(1) TIM_Prescaler：定时器预分频器设置，时钟源经该预分频器才是定时器时钟，它设定 TIMx_PSC寄存器的值。可设置范围为 0 至 65535，实现 1 至 65536 分频。<br>(2) TIM_CounterMode：定时器计数方式，可是在为向上计数、向下计数以及三种中心对齐模式。基本定时器只能是向上计数，即 TIMx_CNT 只能从 0 开始递增，并且无需初始化。<br>(3) TIM_Period：定时器周期，实际就是设定自动重载寄存器的值，在事件生成时更新到影子寄存器。可设置范围为 0 至 65535。<br>(4) TIM_ClockDivision：时钟分频，设置定时器时钟 CK_INT 频率与数字滤波器采样时钟频率分频比，基本定时器没有此功能，不用设置。<br>(5) TIM_RepetitionCounter：重复计数器，属于高级控制寄存器专用寄存器位，利用它可以非常容易控制输出 PWM 的个数。这里不用设置。<br>虽然定时器基本初始化结构体有 5 个成员，但对于基本定时器只需设置其中两个就可以，想想使用基本定时器就是简单。</p>
<h2 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h2><p>高级控制定时器 (TIM1 和 TIM8) 和通用定时器在基本定时器的基础上引入了外部引脚，可以实现输入捕获和输出比较功能。高级控制定时器比通用定时器增加了可编程死区互补输出、重复计数器、带刹车 (断路) 功能，这些功能都是针对工业电机控制方面。<br>高级控制定时器时基单元包含一个 16 位自动重装载寄存器 ARR，一个 16 位的计数器 CNT，可向上/下计数，一个 16 位可编程预分频器 PSC，预分频器时钟源有多种可选，有内部的时钟、外部时钟。还有一个 8 位的重复计数器 RCR，这样最高可实现 40 位的可编程定时。</p>
<h3 id="高级定时器功能框图"><a href="#高级定时器功能框图" class="headerlink" title="高级定时器功能框图"></a>高级定时器功能框图</h3><p>高级控制定时器功能框图包含了高级控制定时器最核心内容，掌握了功能框图，对高级控制定时器就有一个整体的把握，在编程时思路就非常清晰，见，图中有些寄存器是带影子的，表示其有影子寄存器。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696779182439.png" alt="高级定时器功能框图"></p>
<h4 id="时钟源-1"><a href="#时钟源-1" class="headerlink" title="时钟源"></a>时钟源</h4><p>高级控制定时器有四个时钟源可选：</p>
<ul>
<li>内部时钟源 CK_INT</li>
<li>外部时钟模式 1：外部输入引脚 TIx（x=1,2,3,4）</li>
<li>外部时钟模式 2：外部触发输入 ETR</li>
<li>内部触发输入</li>
</ul>
<h5 id="内部时钟源-CK-INT"><a href="#内部时钟源-CK-INT" class="headerlink" title="内部时钟源 (CK_INT)"></a>内部时钟源 (CK_INT)</h5><p>内部时钟 CK_INT 即来自于芯片内部，等于 168M，一般情况下，我们都是使用内部时钟。当从<br>模式控制寄存器 TIMx_SMCR 的 SMS 位等于 000 时，则使用内部时钟。</p>
<h5 id="外部时钟模式-1"><a href="#外部时钟模式-1" class="headerlink" title="外部时钟模式 1"></a>外部时钟模式 1</h5><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696779210415.png" alt="外部时钟模式1"></p>
<ul>
<li>时钟信号输入引脚<br>   当使用外部时钟模式 1 的时候，时钟信号来自于定时器的输入通道，总共有 4 个，分别为 TI1/2/3/4，即 TIMx_CH1/2/3/4。具体使用哪一路信号，由 TIM_CCMRx 的位 CCxS[1:0] 配置，其中 CCMR1控制 TI1/2，CCMR2 控制 TI3/4。</li>
<li>滤波器<br>如果来自外部的时钟信号的频率过高或者混杂有高频干扰信号的话，我们就需要使用滤波器对信号重新采样，来达到降频或者去除高频干扰的目的，具体的由 TIMx_CCMRx 的位 ICxF[3:0] 配置。</li>
<li>边沿检测<br>边沿检测的信号来自于滤波器的输出，在成为触发信号之前，需要进行边沿检测，决定是上升沿有效还是下降沿有效，具体的由 TIMx_CCER 的位 CCxP 和 CCxNP 配置。</li>
<li>触发选择<br>当使用外部时钟模式 1 时，触发源有两个，一个是滤波后的定时器输入 1（TI1FP1）和滤波后的定时器输入 2（TI2FP2），具体的由 TIMxSMCR 的位 TS[2:0] 配置。</li>
<li>从模式选择<br>选定了触发源信号后，最后我们需把信号连接到 TRGI 引脚，让触发信号成为外部时钟模式 1 的输入，最终等于 CK_PSC，然后驱动计数器 CNT 计数。具体的配置 TIMx_SMCR 的位 SMS[2:0]为 111 即可选择外部时钟模式 1。</li>
<li>使能计数器<br>经过上面的 5 个步骤之后，最后我们只需使能计数器开始计数，外部时钟模式 1 的配置就算完成。使能计数器由 TIMx_CR1 的位 CEN 配置。</li>
</ul>
<h5 id="外部时钟模式-2"><a href="#外部时钟模式-2" class="headerlink" title="外部时钟模式 2"></a>外部时钟模式 2</h5><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696779230823.png" alt="外部时钟模式2"></p>
<ul>
<li>时钟信号输入引脚<br>当使用外部时钟模式 2 的时候，时钟信号来自于定时器的特定输入通道 TIMx_ETR，只有 1 个。</li>
<li>外部触发极性<br>来自 ETR 引脚输入的信号可以选择为上升沿或者下降沿有效，具体的由 TIMx_SMCR 的位 ETP配置。</li>
<li>外部触发预分频器<br>由于 ETRP 的信号的频率不能超过 TIMx_CLK（72M）的 1/4，当触发信号的频率很高的情况下，就必须使用分频器来降频，具体的由 TIMx_SMCR 的位 ETPS[1:0] 配置。</li>
<li>滤波器<br>如果 ETRP 的信号的频率过高或者混杂有高频干扰信号的话，我们就需要使用滤波器对 ETRP 信号重新采样，来达到降频或者去除高频干扰的目的。具体的由 TIMx_SMCR 的位 ETF[3:0] 配置，其中的 fDTS 是由内部时钟 CK_INT 分频得到，具体的由 TIMx_CR1 的位 CKD[1:0] 配置。</li>
<li>从模式选择<br>经过滤波器滤波的信号连接到 ETRF 引脚后，触发信号成为外部时钟模式 2 的输入，最终等于CK_PSC，然后驱动计数器 CNT 计数。具体的配置 TIMx_SMCR 的位 ECE 为 1 即可选择外部时钟模式 2。</li>
<li>使能计数器<br>经过上面的 5 个步骤之后，最后我们只需使能计数器开始计数，外部时钟模式 2 的配置就算完成。使能计数器由 TIMx_CR1 的位 CEN 配置。</li>
</ul>
<h5 id="内部触发输入"><a href="#内部触发输入" class="headerlink" title="内部触发输入"></a>内部触发输入</h5><p>内部触发输入是使用一个定时器作为另一个定时器的预分频器。硬件上高级控制定时器和通用定时器在内部连接在一起，可以实现定时器同步或级联。主模式的定时器可以对从模式定时器执行复位、启动、停止或提供时钟。</p>
<h4 id="时基单元"><a href="#时基单元" class="headerlink" title="时基单元"></a>时基单元</h4><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696779244015.png" alt="时基单元"><br>高级控制定时器时基单元功能包括四个寄存器，分别是计数器寄存器 (CNT)、预分频器寄存器(PSC)、自动重载寄存器 (ARR) 和重复计数器寄存器 (RCR)。其中重复计数器 RCR 是高级定时器独有，通用和基本定时器没有。前面三个寄存器都是 16 位有效，TIMx_RCR 寄存器是 8 位有效。</p>
<ul>
<li>预分频器<br>预分频器 PSC，有一个输入时钟 CK_PSC 和一个输出时钟 CK_CNT。输入时钟 CK_PSC 就是上面时钟源的输出，输出 CK_CNT 则用来驱动计数器 CNT 计数。通过设置预分频器 PSC 的值可以得到不同的 CK_CNT，实际计算为：fCK_CNT 等于 f:sub:CK_PSC/(PSC[15:0]+1)，可以实现 1 至65536 分频。</li>
<li>计数器<br>高级控制定时器的计数器有三种计数模式，分别为递增计数模式、递减计数模式和递增/递减 (中心对齐) 计数模式。<br>(1) 递增计数模式下，计数器从 0 开始计数，每来一个 CK_CNT 脉冲计数器就增加 1，直到计数器的值与自动重载寄存器 ARR 值相等，然后计数器又从 0 开始计数并生成计数器上溢事件，计数器总是如此循环计数。如果禁用重复计数器，在计数器生成上溢事件就马上生成更新事件 (UEV)；如果使能重复计数器，每生成一次上溢事件重复计数器内容就减 1，直到重复计数器内容为 0 时才会生成更新事件。<br>(2) 递减计数模式下，计数器从自动重载寄存器 ARR 值开始计数，每来一个 CK_CNT 脉冲计数器就减 1，直到计数器值为 0，然后计数器又从自动重载寄存器 ARR 值开始递减计数并生成计数器下溢事件，计数器总是如此循环计数。如果禁用重复计数器，在计数器生成下溢事件就马上生成更新事件；如果使能重复计数器，每生成一次下溢事件重复计数器内容就减 1，直到重复计数器内容为 0 时才会生成更新事件。<br>(3) 中心对齐模式下，计数器从 0 开始递增计数，直到计数值等于 (ARR-1) 值生成计数器上溢事件，然后从 ARR 值开始递减计数直到 1 生成计数器下溢事件。然后又从 0 开始计数，如此循环。每次发生计数器上溢和下溢事件都会生成更新事件。</li>
<li>自动重载寄存器ARR<br>自动重载寄存器 ARR 用来存放与计数器 CNT 比较的值，如果两个值相等就递减重复计数器。可以通过 TIMx_CR1 寄存器的 ARPE 位控制自动重载影子寄存器功能，如果 ARPE 位置 1，自动重载影子寄存器有效，只有在事件更新时才把 TIMx_ARR 值赋给影子寄存器。如果 ARPE 位为 0，则修改 TIMx_ARR 值马上有效。</li>
<li>重复计数器RCR<br>在基本/通用定时器发生上/下溢事件时直接就生成更新事件，但对于高级控制定时器却不是这样，高级控制定时器在硬件结构上多出了重复计数器，在定时器发生上溢或下溢事件是递减重复计数器的值，只有当重复计数器为 0 时才会生成更新事件。在发生 N+1 个上溢或下溢事件 (N 为RCR 的值) 时产生更新事件。</li>
</ul>
<h4 id="输出比较"><a href="#输出比较" class="headerlink" title="输出比较"></a>输出比较</h4><p>输出比较就是通过定时器的外部引脚对外输出控制信号，有冻结、将通道 X（x=1,2,3,4）设置为匹配时输出有效电平、将通道 X 设置为匹配时输出无效电平、翻转、强制变为无效电平、强制变为有效电平、PWM1 和 PWM2 这八种模式，具体使用哪种模式由寄存器 CCMRx 的位 OCxM[2:0]配置。其中 PWM 模式是输出比较中的特例，使用的也最多。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696779259997.png" alt="输出比较"></p>
<ul>
<li>比较寄存器<br>当计数器 CNT 的值跟比较寄存器 CCR 的值相等的时候，输出参考信号 OCxREF 的信号的极性就会改变，其中 OCxREF=1（高电平）称之为有效电平，OCxREF=0（低电平）称之为无效电平，并且会产生比较中断 CCxI，相应的标志位 CCxIF（SR 寄存器中）会置位。然后 OCxREF 再经过一系列的控制之后就成为真正的输出信号 OCx/OCxN。</li>
<li>死区发生器<br>在生成的参考波形 OCxREF 的基础上，可以插入死区时间，用于生成两路互补的输出信号 OCx和 OCxN，死区时间的大小具体由 BDTR 寄存器的位 DTG[7:0] 配置。死区时间的大小必须根据与输出信号相连接的器件及其特性来调整。下面我们简单举例说明下带死区的 PWM 信号的应用，我们以一个板桥驱动电路为例。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696779272789.png" alt="死区发生器"><br>在这个半桥驱动电路中，Q1 导通，Q2 截止，此时我想让 Q1 截止 Q2 导通，肯定是要先让 Q1 截止一段时间之后，再等一段时间才让 Q2 导通，那么这段等待的时间就称为死区时间，因为 Q1关闭需要时间（由 MOS 管的工艺决定）。如果 Q1 关闭之后，马上打开 Q2，那么此时一段时间内相当于 Q1 和 Q2 都导通了，这样电路会短路。<br>图带死区插入的互补输出 是针对上面的半桥驱动电路而画的带死区插入的 PWM 信号，图中的死区时间要根据 MOS 管的工艺来调节。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696779290305.png" alt="带死区插入的互补输出"></li>
<li>输出控制<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696779303453.png" alt="输出控制"><br>在输出比较的输出控制中，参考信号 OCxREF 在经过死区发生器之后会产生两路带死区的互补信号 OCx_DT 和 OCxN_DT（通道 1<del>3 才有互补信号，通道 4 没有，其余跟通道 1</del>3 一样），这两路带死区的互补信号然后就进入输出控制电路，如果没有加入死区控制，那么进入输出控制电路的信号就直接是 OCxREF。<br>进入输出控制电路的信号会被分成两路，一路是原始信号，一路是被反向的信号，具体的由寄存器 CCER 的位 CCxP 和 CCxNP 控制。经过极性选择的信号是否由 OCx 引脚输出到外部引脚CHx/CHxN 则由寄存器 CCER 的位 CxE/CxNE 配置。<br>如果加入了断路（刹车）功能，则断路和死区寄存器 BDTR 的 MOE、OSSI 和 OSSR 这三个位会共同影响输出的信号。</li>
<li>输出引脚<br>输出比较的输出信号最终是通过定时器的外部 IO 来输出的，分别为 CH1/2/3/4，其中前面三个通道还有互补的输出通道 CH1/2/3N。更加详细的 IO 说明还请查阅相关的数据手册。</li>
</ul>
<h3 id="输出比较应用"><a href="#输出比较应用" class="headerlink" title="输出比较应用"></a>输出比较应用</h3><ul>
<li>PWM输出模式<br>PWM 输出就是对外输出脉宽（即占空比）可调的方波信号，信号频率由自动重装寄存器 ARR 的值决定，占空比由比较寄存器 CCR 的值决定。<br>PWM 模式分为两种，PWM1 和 PWM2，总得来说是差不多，就看你怎么用而已，具体的区别见表格 PWM1 与 PWM2 模式的区别。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696779321929.png" alt="PWM1和2的区别"><br>下面我们以 PWM1 模式来讲解，以计数器 CNT 计数的方向不同还分为边沿对齐模式和中心对齐模式。PWM 信号主要都是用来控制电机，一般的电机控制用的都是边沿对齐模式，FOC 电机一般用中心对齐模式。我们这里只分析这两种模式在信号感官上（即信号波形）的区别，具体在电机控制中的区别不做讨论，到了你真正需要使用的时候就会知道了。<ul>
<li>PWM边沿对齐模式、<br>在递增计数模式下，计数器从 0 计数到自动重载值（TIMx_ARR 寄存器的内容），然后重新从0开始计数并生成计数器上溢事件<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696779331143.png" alt="边沿对齐"><br>在边沿对齐模式下，计数器 CNT 只工作在一种模式，递增或者递减模式。这里我们以 CNT 工作在递增模式为例，在中，ARR=8，CCR=4，CNT 从 0 开始计数，当 CNT&lt;CCR 的值时，OCxREF为有效的高电平，于此同时，比较中断寄存器 CCxIF 置位。当 CCR=&lt;CNT&lt;=ARR 时，OCxREF为无效的低电平。然后 CNT 又从 0 开始计数并生成计数器上溢事件，以此循环往复。</li>
<li>PWM中心对齐模式<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696779341576.png" alt="中心对齐"><br>在中心对齐模式下，计数器 CNT 是工作做递增/递减模式下。开始的时候，计数器 CNT 从 0 开始计数到自动重载值减 1(ARR-1)，生成计数器上溢事件；然后从自动重载值开始向下计数到 1 并生成计数器下溢事件。之后从 0 开始重新计数。<br>图 PWM1 模式的中心对齐波形 是 PWM1 模式的中心对齐波形，ARR=8，CCR=4。第一阶段计数器 CNT 工作在递增模式下，从 0 开始计数，当 CNT&lt;CCR 的值时，OCxREF 为有效的高电平，当CCR=&lt;CNT«ARR 时，OCxREF 为无效的低电平。第二阶段计数器 CNT 工作在递减模式，从 ARR的值开始递减，当 CNT&gt;CCR 时，OCxREF 为无效的低电平，当 CCR=&gt;CNT&gt;=1 时，OCxREF 为有效的高电平。<br>在波形图上我们把波形分为两个阶段，第一个阶段是计数器 CNT 工作在递增模式的波形，这个阶段我们又分为 ① 和 ② 两个阶段，第二个阶段是计数器 CNT 工作在递减模式的波形，这个阶段我们又分为 ③ 和 ④ 两个阶段。要说中心对齐模式下的波形有什么特征的话，那就是 ① 和 ③ 阶段的时间相等，② 和 ④ 阶段的时间相等。<br>中心对齐模式又分为中心对齐模式 1/2/3 三种，具体由寄存器 CR1 位 CMS[1:0] 配置。具体的区别就是比较中断中断标志位 CCxIF 在何时置 1：中心模式 1 在 CNT 递减计数的时候置 1，中心对齐模式 2 在 CNT 递增计数时置 1，中心模式 3 在 CNT 递增和递减计数时都置 1。</li>
</ul>
</li>
</ul>
<h3 id="定时器初始化结构体"><a href="#定时器初始化结构体" class="headerlink" title="定时器初始化结构体"></a>定时器初始化结构体</h3><h4 id="TIM-TimeBaseInitTypeDef"><a href="#TIM-TimeBaseInitTypeDef" class="headerlink" title="TIM_TimeBaseInitTypeDef"></a>TIM_TimeBaseInitTypeDef</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token class-name">uint16_t</span> TIM_Prescaler<span class="token punctuation">;</span> <span class="token comment">// 预分频器</span>
	<span class="token class-name">uint16_t</span> TIM_CounterMode<span class="token punctuation">;</span> <span class="token comment">// 计数模式</span>
	<span class="token class-name">uint32_t</span> TIM_Period<span class="token punctuation">;</span> <span class="token comment">// 定时器周期</span>
	<span class="token class-name">uint16_t</span> TIM_ClockDivision<span class="token punctuation">;</span> <span class="token comment">// 时钟分频</span>
	<span class="token class-name">uint8_t</span> TIM_RepetitionCounter<span class="token punctuation">;</span> <span class="token comment">// 重复计算器</span>
<span class="token punctuation">}</span> TIM_TimeBaseInitTypeDef<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>(1) TIM_Prescaler：定时器预分频器设置，时钟源经该预分频器才是定时器计数时钟 CK_CNT，它设定 PSC 寄存器的值。计算公式为：计数器时钟频率 (fCK_CNT) 等于 fCK_PSC / (PSC[15:0] + 1)，可实现 1 至 65536 分频。<br>(2) TIM_CounterMode：定时器计数方式，可设置为向上计数、向下计数以及中心对齐。高级控制定时器允许选择任意一种。<br>(3) TIM_Period：定时器周期，实际就是设定自动重载寄存器 ARR 的值，ARR 为要装载到实际自动重载寄存器（即影子寄存器）的值，可设置范围为 0 至 65535。<br>(4) TIM_ClockDivision：时钟分频，设置定时器时钟 CK_INT 频率与死区发生器以及数字滤波器采样时钟频率分频比。可以选择 1、2、4 分频。<br>(5) TIM_RepetitionCounter：重复计数器，只有 8 位，只存在于高级定时器。</p>
<h4 id="TIM-OCInitTypeDef"><a href="#TIM-OCInitTypeDef" class="headerlink" title="TIM_OCInitTypeDef"></a>TIM_OCInitTypeDef</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token class-name">uint16_t</span> TIM_OCMode<span class="token punctuation">;</span> <span class="token comment">// 比较输出模式</span>
	<span class="token class-name">uint16_t</span> TIM_OutputState<span class="token punctuation">;</span> <span class="token comment">// 比较输出使能</span>
	<span class="token class-name">uint16_t</span> TIM_OutputNState<span class="token punctuation">;</span> <span class="token comment">// 比较互补输出使能</span>
	<span class="token class-name">uint32_t</span> TIM_Pulse<span class="token punctuation">;</span> <span class="token comment">// 脉冲宽度</span>
	<span class="token class-name">uint16_t</span> TIM_OCPolarity<span class="token punctuation">;</span> <span class="token comment">// 输出极性</span>
	<span class="token class-name">uint16_t</span> TIM_OCNPolarity<span class="token punctuation">;</span> <span class="token comment">// 互补输出极性</span>
	<span class="token class-name">uint16_t</span> TIM_OCIdleState<span class="token punctuation">;</span> <span class="token comment">// 空闲状态下比较输出状态</span>
	<span class="token class-name">uint16_t</span> TIM_OCNIdleState<span class="token punctuation">;</span> <span class="token comment">// 空闲状态下比较互补输出状态</span>
<span class="token punctuation">}</span> TIM_OCInitTypeDef<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>(1) TIM_OCMode：比较输出模式选择，总共有八种，常用的为 PWM1/PWM2。它设定 CCMRx 寄存器 OCxM[2:0] 位的值。<br>(2) TIM_OutputState：比较输出使能，决定最终的输出比较信号 OCx 是否通过外部引脚输出。它设定 TIMx_CCER 寄存器 CCxE/CCxNE 位的值。<br>(3) TIM_OutputNState: 比较互补输出使能，决定 OCx 的互补信号 OCxN 是否通过外部引脚输出。它设定 CCER 寄存器 CCxNE 位的值。<br>(4) TIM_Pulse：比较输出脉冲宽度，实际设定比较寄存器 CCR 的值，决定脉冲宽度。可设置范围为 0 至 65535。<br>(5) TIM_OCPolarity：比较输出极性，可选 OCx 为高电平有效或低电平有效。它决定着定时器通道有效电平。它设定 CCER 寄存器的 CCxP 位的值。<br>(6) TIM_OCNPolarity：比较互补输出极性，可选 OCxN 为高电平有效或低电平有效。它设定TIMx_CCER 寄存器的 CCxNP 位的值。<br>(7) TIM_OCIdleState：空闲状态时通道输出电平设置，可选输出 1 或输出 0，即在空闲状态(BDTR_MOE 位为 0) 时，经过死区时间后定时器通道输出高电平或低电平。它设定 CR2 寄存器的 OISx 位的值。<br>(8) TIM_OCNIdleState：空闲状态时互补通道输出电平设置，可选输出 1 或输出 0，即在空闲状态(BDTR_MOE 位为 0) 时，经过死区时间后定时器互补通道输出高电平或低电平，设定值必须与TIM_OCIdleState 相反。它设定是 CR2 寄存器的 OISxN 位的值。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696779461894.png" alt="over"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>Tim定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>安装激活keil5</title>
    <url>/2023/10/01/an-zhuang-ji-huo-keil5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="安装激活keil5"><a href="#安装激活keil5" class="headerlink" title="安装激活keil5"></a>安装激活keil5</h1><h1 id="1-Keil-MDK-ARM下载"><a href="#1-Keil-MDK-ARM下载" class="headerlink" title="1. Keil MDK-ARM下载"></a>1. Keil MDK-ARM下载</h1><p>目前（2023年10月）Keil MDK-ARM官方最新版本是V5.38</p>
<p>MDK-ARM安装包下载</p>
<p>官网下载地址：<a href="https://www.keil.com/download/product/">https://www.keil.com/download/product/</a></p>
<p>百度网盘下载地址：<a href="https://download.csdn.net/download/dengjin20104042056/12718973">https://download.csdn.net/download/dengjin20104042056/12718973</a></p>
<h1 id="2-官网下载"><a href="#2-官网下载" class="headerlink" title="2. 官网下载"></a>2. 官网下载</h1><p>进入网址<a href="https://www.keil.com/download/product/">https://www.keil.com/download/product/</a><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826485273.png" alt="Alt text"><br>点击MDK-Arm<br>然后会进入新的界面，并让你填一些信息，这些信息随便填写就行。点击Submit<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826496639.png" alt="Alt text"><br>进入到以一下界面!<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826508191.png" alt="Alt text"><br>点击MDK538A.EXE下载最新版</p>
<h1 id="3-安装Keil5"><a href="#3-安装Keil5" class="headerlink" title="3. 安装Keil5"></a>3. 安装Keil5</h1><p>3.1 双击安装包，进入安装向导界面，点击Next<br>![Alt text]<img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826517257.png" alt="enter description here"><br>3.2 选择同意协议，然后下一步<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826523209.png" alt="Alt text"><br>3.3 选择软件和支持包安装路径（可以默认），点击Next。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826574975.png" alt="Alt text"><br>3.4 填写基本信息，然后选择下一步。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826580262.png" alt="Alt text"><br>3.5 安装过程中，弹出如下窗口，选择安装<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826585149.png" alt="Alt text"><br>3.6 点击Finish，完成安装。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826590369.png" alt="Alt text"><br>安装完成之后弹出的这个界面直接关掉就行<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826596024.png" alt="Alt text"></p>
<h1 id="4-激活Keil5"><a href="#4-激活Keil5" class="headerlink" title="4. 激活Keil5"></a>4. 激活Keil5</h1><p>Keil MDK-ARM是一个收费的软件，官方打击盗版也比较严厉，若你是商业用途，建议购买正版软件。当然，针对个人开发学习的朋友而言，进行非商业用途的使用。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826601898.png" alt="Alt text"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826608294.png" alt="Alt text"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826614185.png" alt="Alt text"><br>复制CID<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826619388.png" alt="Alt text"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826625181.png" alt="Alt text"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826633079.png" alt="Alt text"><br>粘贴序列号在1处，然后点击按钮2<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826640973.png" alt="Alt text"></p>
<h1 id="5-安装芯片包"><a href="#5-安装芯片包" class="headerlink" title="5. 安装芯片包"></a>5. 安装芯片包</h1><h2 id="1-进入官网"><a href="#1-进入官网" class="headerlink" title="1.进入官网"></a>1.进入官网</h2><p>ARM Keil官网链接：(<a href="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826651150.png">https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700826651150.png</a>)</p>
<h2 id="2-进入CMSIS-Packs中选择需要的pack包"><a href="#2-进入CMSIS-Packs中选择需要的pack包" class="headerlink" title="2.进入CMSIS Packs中选择需要的pack包"></a>2.进入CMSIS Packs中选择需要的pack包</h2><p>输入需要的芯片型号后回车能显示出所有相关型号，或者在输入栏下方列表中查找：<br>找到所需安装包后，点击下载<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700827134830.png" alt="Alt text"><br>下载速度慢的话可以在迅雷里面下载，迅雷有镜像源下载速度会很快</p>
<h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3.安装"></a>3.安装</h2><p>双击打开，点Next就可以开始安装<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700827139319.png" alt="Alt text"></p>
<h1 id="6-安装V5编译器"><a href="#6-安装V5编译器" class="headerlink" title="6. 安装V5编译器"></a>6. 安装V5编译器</h1><h2 id="1-安装V5编译器的原因"><a href="#1-安装V5编译器的原因" class="headerlink" title="1.安装V5编译器的原因"></a>1.安装V5编译器的原因</h2><p>直接使用最新版的keil5编译时，发现网上的很多代码编译不过去。原因是以前的代码是ARM Compiler V5做的。然而，现在的KEIL不给预装ARM Compiler V5，如果用v6编译就如下图所示。所以我想办法给KEIL支持ARM Compiler V5。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700827148073.png" alt="Alt text"><br>检查了一下，发现确实没有v5的编译器。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700827157284.png" alt="Alt text"></p>
<h2 id="2-获得ARM-Compiler-V5的安装包"><a href="#2-获得ARM-Compiler-V5的安装包" class="headerlink" title="2. 获得ARM Compiler V5的安装包"></a>2. 获得ARM Compiler V5的安装包</h2><p>国内有很多前辈其实已经把ARM Compiler V5下载下来了，仔细点搜还是搜得到的。但是我这里找到了一个官方的办法。</p>
<p>找到了官方的这个问题说明文档：<a href="https://developer.arm.com/documentation/ka005198/latest">https://developer.arm.com/documentation/ka005198/latest</a></p>
<p>然后顺着去找到下载网址：<a href="https://developer.arm.com/downloads/view/ACOMP5%E3%80%82">https://developer.arm.com/downloads/view/ACOMP5。</a><br>注意的是，这个网站是要登录ARM的账号。如果没有的话去注册一个就好。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700827166455.png" alt="Alt text"><br>这里有两个下载资源。第一个应该是给linux的。如果是keil的话，我们一般是用在Windows上的，所以我们下载第二个。</p>
<h2 id="3-安装-1"><a href="#3-安装-1" class="headerlink" title="3. 安装"></a>3. 安装</h2><p>下载以后，安装。但是注意安装路径一定要放在KEIL\ARM\下面创建的子目录里。我这里用的是KEIL\ARM\ARMCC5。</p>
<h2 id="4-KEIL下引入ARM-Compiler-V5"><a href="#4-KEIL下引入ARM-Compiler-V5" class="headerlink" title="4. KEIL下引入ARM Compiler V5"></a>4. KEIL下引入ARM Compiler V5</h2><p>安装好了以后，点击那个－＞Folder/Extensions.<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700827173569.png" alt="Alt text"><br>点Use ARM Compiler 最右边那个…。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700827178876.png" alt="Alt text"><br>选中安装编译器的文件夹。于是就会出现：<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700827186382.png" alt="Alt text"><br>再点Setup Default ARM Compiler Version<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700827194667.png" alt="Alt text"><br>一路点完确定。</p>
<h2 id="5-确认"><a href="#5-确认" class="headerlink" title="5. 确认"></a>5. 确认</h2><p>点魔法棒，确认一下。已经可以选中ARM Compiler v5了。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1700827201560.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>KEIL5</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu上使用CLion+cubemx+openocd开发STM32</title>
    <url>/2024/07/15/ubuntu-shang-shi-yong-clion-cubemx-openocd-kai-fa-stm32/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Ubuntu-上使用-CLion-cubemx-openocd-开发-STM32"><a href="#Ubuntu-上使用-CLion-cubemx-openocd-开发-STM32" class="headerlink" title="Ubuntu 上使用 CLion+cubemx+openocd 开发 STM32"></a>Ubuntu 上使用 CLion+cubemx+openocd 开发 STM32</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>后面需要在 linux 下学习驱动开发，然后不想玩虚拟机，就直接安装了双系统。用 kde 桌面玩的蛮开心的，就索性把 win 下的开发内容都搬过来吧</p>
<p>在 Linux 下开发 STM32，使用 Clion 和 Cubemx 开发，openocd 调试，关于芯片下载，编译器选项，代码起始内容都需要自行通过工程的配置文件修改，不依靠 keil5 的 IDE 选项界面，用起来虽然说麻烦了点，但对于整个单片机系统启动、运行、配置的相关内容来说，学习起来会更深入些。</p>
<h2 id="环境版本"><a href="#环境版本" class="headerlink" title="环境版本"></a>环境版本</h2><ul>
<li>操作系统: Kubuntu22.04.3</li>
<li>Clion: CLion 2023.2.2</li>
<li>CubeMX: CubeMX 6.9.2</li>
<li>Openocd: Openocd 0.12.0</li>
<li>试验板子： Art-pi ——STM32H750XBH6</li>
<li>仿真器： STlink-v2</li>
</ul>
<h2 id="下载-Clion"><a href="#下载-Clion" class="headerlink" title="下载 Clion"></a>下载 Clion</h2><p><a href="https://www.jetbrains.com/clion/">官网链接</a></p>
<p>clion 是 jetbrains 全家桶里的一个，收费，可以试用一个月</p>
<ul>
<li>学生可以免费使用，只需要提供校园邮箱或者学信网学籍证明注册一个账号即可。</li>
<li>下载完成后解压，找到目录里的安装脚本即可（clion.sh）</li>
<li>安装完成后，可以在软件目录里找到 Clion，向桌面添加即可，或者使用软链接到桌面，也可以自行创建.desktop 文件，输入相关内容。</li>
</ul>
<h2 id="下载-CubeMX"><a href="#下载-CubeMX" class="headerlink" title="下载 CubeMX"></a>下载 CubeMX</h2><p><a href="https://www.st.com/zh/development-tools/stm32cubemx.html">官网链接</a></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/UCRVdt.png" alt="选择下载"></p>
<ul>
<li>下载后解压，执行解压目录下的可执行文件，选择默认安装位置即可</li>
<li>添加桌面快捷方式：这个我在软件目录里没有找到，就在桌面创建了个 CubeMX.desktop 文件，用于快捷访问 CubeMX。</li>
</ul>
<p>CubeMX.desktop 文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env xdg-open</span>
<span class="token punctuation">[</span>Desktop Entry<span class="token punctuation">]</span>
<span class="token assign-left variable">Name</span><span class="token operator">=</span>STM32CubeMX
<span class="token assign-left variable">Exec</span><span class="token operator">=</span>/home/augety/STM32CubeMX/STM32CubeMX
<span class="token assign-left variable">Terminal</span><span class="token operator">=</span>false
<span class="token assign-left variable">Type</span><span class="token operator">=</span>Application
<span class="token assign-left variable">Icon</span><span class="token operator">=</span>/home/augety/Pictures/Icon/cubemx.png
<span class="token assign-left variable">StartupWMClass</span><span class="token operator">=</span>STM32CubeMX
<span class="token assign-left variable">Categories</span><span class="token operator">=</span>Development<span class="token punctuation">;</span>IDE<span class="token punctuation">;</span>
<span class="token assign-left variable">Comment</span><span class="token operator">=</span>STM32CubeMX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/CUBb8Q.jpg"></p>
<h2 id="下载-openocd"><a href="#下载-openocd" class="headerlink" title="下载 openocd"></a>下载 openocd</h2><h3 id="apt-直接安装"><a href="#apt-直接安装" class="headerlink" title="apt 直接安装"></a>apt 直接安装</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openocd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#github下载</span>
<span class="token function">git</span> clone git://git.code.sf.net/p/openocd/code openocd
<span class="token comment">#安装依赖</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> build-essential pkg-config autoconf automake libtool libusb-dev libusb-1.0-0-dev libhidapi-dev libtool libsysfs-dev
<span class="token comment">#引导生成环境</span>
./bootstrap
<span class="token comment">#配置</span>
./configure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#执行版本查询命令</span>
openocd <span class="token parameter variable">-version</span>
<span class="token comment">#输出版本信息</span>
Open On-Chip Debugger <span class="token number">0.12</span>.0+dev-00344-gf76c8de91 <span class="token punctuation">(</span><span class="token number">2023</span>-10-05-02:13<span class="token punctuation">)</span>
Licensed under GNU GPL v2
For bug reports, <span class="token builtin class-name">read</span>
        http://openocd.org/doc/doxygen/bugs.html
openocd: invalid option -- <span class="token string">'e'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="安装-stlink-驱动"><a href="#安装-stlink-驱动" class="headerlink" title="安装 stlink 驱动"></a>安装 stlink 驱动</h2><p><a href="https://github.com/stlink-org/stlink/releases">下载链接</a></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/JkxfEc.jpg" alt="选择下载"></p>
<p>下载后安装 deb 包</p>
<h2 id="安装-arm-编译器"><a href="#安装-arm-编译器" class="headerlink" title="安装 arm 编译器"></a>安装 arm 编译器</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> gcc-arm-none-eabi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="配置-clion"><a href="#配置-clion" class="headerlink" title="配置 clion"></a>配置 clion</h2><ul>
<li>打开设置&gt;构建、执行、部署&gt;嵌入式开发</li>
</ul>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/hbycIt.jpg" alt="打开设置"></p>
<ul>
<li><p>配置相关工具路径，点击测试。</p>
</li>
<li><p>新建项目，注意项目命名<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/ZVKpkn.jpg" alt="新建嵌入式项目"></p>
</li>
<li><p>会自动运行 CubeMX 并且配置出一个 F030 的工程。</p>
</li>
</ul>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/v6BBaS.jpg" alt="自动配置"></p>
<ul>
<li>这里 clion 会自动将目标型号芯片的配置文件复制到工程里 选择 复制到项目并使用<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/VJ9fEW.jpg" alt="选择复制到项目并使用"></li>
<li>我们选择点击工程目录里的.ioc 文件，选择 通过 STM3CubeMX 打开</li>
<li>打开后修改相关内容即可</li>
<li>注意最后工程名字，并配置为 STM32CubeIDE</li>
</ul>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/XVrhjo.jpg" alt="生成工程配置"></p>
<ul>
<li>生成文件后，更新工程，在左边目录里进入用户代码。</li>
<li>点击右上角编译，点击运行下载，点击调试进行调试</li>
</ul>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/87cqLB.jpg" alt="相关内容"></p>
<p>其他具体操作可以自行尝试，包括汉化插件、主题、添加自定义文件夹等等。</p>
<h2 id="相关小操作"><a href="#相关小操作" class="headerlink" title="相关小操作"></a>相关小操作</h2><p>官方提供的配置文件里有些小问题</p>
<ul>
<li><p>openocd 下载的代码不能自动复位，需要手动复位，这里修改.cfg 的 21 行</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/LLMSya.jpg" alt="复位操作"></p>
</li>
<li><p>添加自定义文件，直接在目录里添加即可，添加相关依赖时，选择默认即可</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/T8VHXK.jpg" alt="添加文件"></p>
</li>
<li><p>然后直接编译会报错，需要删除 CMakeLists.txt 里的一些新内容。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/AlKrcx.jpg" alt="删掉即可"></p>
</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_41115751/article/details/121439534">ubuntu 使用 clion 搭建 stm32 开环境使用 stlink 下载调试</a></p>
<p><a href="https://blog.csdn.net/baidu_36482169/article/details/81005060">Linux 上 openocd 的安装和使用</a></p>
<p><a href="https://blog.csdn.net/qq_40839071/article/details/114700646">Ubuntu 下 OpenOCD+GDB 的安装、编译及使用</a></p>
<p>欢迎访问<a href="https://sparkle-now.cn/">我的博客</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>Ubuntu</tag>
        <tag>CLion</tag>
      </tags>
  </entry>
  <entry>
    <title>在clion平台使用openocd工具向STM32H7外置flash下载代码并调试</title>
    <url>/2023/08/20/zai-clion-ping-tai-shi-yong-openocd-gong-ju-xiang-stm32h7-wai-zhi-flash-xia-zai-dai-ma-bing-diao-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="使用clion向STM32H7外置flash下载代码"><a href="#使用clion向STM32H7外置flash下载代码" class="headerlink" title="使用clion向STM32H7外置flash下载代码"></a>使用clion向STM32H7外置flash下载代码</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>根据安福莱的STM32H7教程，H7单片机的QSPI外设是直接连到芯片内核上的，地址是0X90000000；QSPI外设可以设置为内存映射模式，由此执行代码，达到扩展stm32flash的效果，一般移植lvgl都需要外扩flash。</strong></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1721605742489.png" alt="STM3H7单片机矩阵架构"><br>相关操作在keil5上比较简单，配置点东西就行；可以参考安福莱教程。</p>
<p>这里要介绍的是在linux环境下没有keil5 IDE的情况下，如何使用clion+openocd实现</p>
<ul>
<li>将大体积代码下载到外置flash并执行</li>
<li>对外置flash执行的代码进行仿真</li>
</ul>
<h2 id="代码配置"><a href="#代码配置" class="headerlink" title="代码配置"></a>代码配置</h2><h3 id="修改系统配置文件"><a href="#修改系统配置文件" class="headerlink" title="修改系统配置文件"></a>修改系统配置文件</h3><p>STM32的代码都是有起始地址的，每一句代码，编译为相关机器码执行时，都有对应地址的；对于一般情况的代码，起始地址都是0X8000000；</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1721605792831.png" alt="工程FLASH配置文件"><br>该文件中详细的配置了单片机所使用的flash大小，ram大小，地址等信息。</p>
<p>由于采用外置flash启动，我们需要将flash地址配置为QSPI地址，并修改LENGTH为我们的flash芯片大小。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">MEMORY
<span class="token punctuation">{</span>
  <span class="token function">FLASH</span> <span class="token punctuation">(</span>rx<span class="token punctuation">)</span>     <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x90000000</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">8192</span>K
  <span class="token function">DTCMRAM</span> <span class="token punctuation">(</span>xrw<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x20000000</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">128</span>K
  <span class="token function">RAM_D1</span> <span class="token punctuation">(</span>xrw<span class="token punctuation">)</span>   <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x24000000</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">512</span>K
  <span class="token function">RAM_D2</span> <span class="token punctuation">(</span>xrw<span class="token punctuation">)</span>   <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x30000000</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">288</span>K
  <span class="token function">RAM_D3</span> <span class="token punctuation">(</span>xrw<span class="token punctuation">)</span>   <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x38000000</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">64</span>K
  <span class="token function">ITCMRAM</span> <span class="token punctuation">(</span>xrw<span class="token punctuation">)</span>  <span class="token operator">:</span> ORIGIN <span class="token operator">=</span> <span class="token number">0x00000000</span><span class="token punctuation">,</span> LENGTH <span class="token operator">=</span> <span class="token number">64</span>K
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="修改系统初始化函数"><a href="#修改系统初始化函数" class="headerlink" title="修改系统初始化函数"></a>修改系统初始化函数</h3><p>STM32单片机启动时会先执行汇编启动文件，先定义中断向量表，再执行复位，设置栈顶指针，再执行系统初始化函数，再跳转main函数。</p>
<p>其中系统初始化函数中需要修改SCB-&gt;VTOR的值。<br>==SCB-&gt;VTOR为Cortex内核的中断向量表的基地址，一般为程序执行的初始地址。 #12AA9C==<br>关于该变量理解，<a href="https://dgvy.gitee.io/2021/STM32%E4%B8%ADSCB-VTOR%E7%9A%84%E7%90%86%E8%A7%A3/">参考链接</a></p>
<p>这里需要修改为我们程序启动的地址0X90000000。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1721605816210.png" alt="SCB->VTOR地址修改"></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>点击编译，即可制作一个运行在外部flash的代码，下载到外置flash中，引导运行即可。</p>
<p>那么现在出现两个问题：</p>
<ul>
<li>如何下载到外置flash</li>
<li>如何从外置flash中启动</li>
</ul>
<h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2><h3 id="使用CubeProgramer工具下载"><a href="#使用CubeProgramer工具下载" class="headerlink" title="使用CubeProgramer工具下载"></a>使用CubeProgramer工具下载</h3><p>使用ST提供的下载工具下载；<br>需要：</p>
<ul>
<li>对应板子的下载算法文件</li>
<li>烧录器</li>
<li>能够运行在外置flash的代码</li>
</ul>
<p>刚才已经成功编译了外置执行代码，烧录器咱也有，而烧录算法呢，推荐看安福莱的相关教程。<br><a href="https://blog.csdn.net/Simon223/article/details/110133013">相关教程</a></p>
<h3 id="使用Clion下载"><a href="#使用Clion下载" class="headerlink" title="使用Clion下载"></a>使用Clion下载</h3><p>这个是我主要想讲的，在一个编辑器里完成编译、下载、调试，嘿嘿</p>
<p>先解决下载问题。</p>
<p>我们知道，STM32下载代码时会先执行一个配置程序，该程序运行在RAM中，会初始化部分关于下载代码的外设。</p>
<p>使用keil5时，我们会使用一个.flm文件下载代码，该文件就是下载引导程序，其制作流程安福莱里讲的有。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1721605834906.png" alt="反客的keil5下载教程"></p>
<p>同样，在正常下载的时候也会有一个keil5官方提供的.flm文件，这些文件就储存在官方目录里。</p>
<p>对于CubeMX而言，也有相应的文件，</p>
<p>所以，我们使用的openocd工具也是有的，在我们的工程目录里，有一些配置文件，都具有各自相应的功能。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1721605850131.png" alt="clion工程目录"><br>在stm32h750b-disco.cfg文件中，初始化了芯片时钟，和部分必要的下载外设；</p>
<p>在19行、23行：跳转到了其他配置文件中，执行具体的操作</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># enable stmqspi</span>
<span class="token keyword">if</span> <span class="token punctuation">{</span><span class="token operator">!</span><span class="token punctuation">[</span>info exists QUADSPI<span class="token punctuation">]</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
	<span class="token builtin class-name">set</span> QUADSPI <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token builtin class-name">source</span> <span class="token punctuation">[</span>find target/stm32h7x.cfg<span class="token punctuation">]</span>

reset_config srst_only

<span class="token builtin class-name">source</span> <span class="token punctuation">[</span>find board/stm32h7x_dual_qspi.cfg<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这里，代码定义了QUADSPI为1，即会在stm32h7x_dual_qspi.cfg中执行该外设的初始化；</p>
<p>但是，这里该外设的初始化是以STM32官方出的板子的引脚定义的，不一定适合我们，而且实操下来，该文件改来改去效果不大，而且我觉得不建议跳到人家官方配置文件里修修改改，这里我们直接在该配置语句下面执行我们板子的配置代码；</p>
<pre class="line-numbers language-dsconfig" data-language="dsconfig"><code class="language-dsconfig"># ART_Pi qspi.

# QUADSPI initialization
proc qspi_init {  } {
    global a
    mmw 0x580244E0 0x000007FF 0             ;# RCC_AHB4ENR |= GPIOAEN-GPIOKEN (enable clocks)
    mmw 0x580244D4 0x00004000 0             ;# RCC_AHB3ENR |= QSPIEN (enable clock)
    sleep 1                                 ;# Wait for clock startup

    # PF10:AF09:H, PF09:AF10:H, PF08:AF10:H, PF07:AF09:H, PF06:AF09:H, PG06:AF10:H

    # Port F: PF10:AF09:H, PF09:AF10:H, PF08:AF10:H, PF07:AF09:H, PF06:AF09:H
    mmw 0x58021400 0x002AA000 0x00155000    ;# MODER
    mmw 0x58021408 0x002AA000 0x00155000    ;# OSPEEDR
    mmw 0x5802140C 0x00000000 0x003FF000    ;# PUPDR
    mmw 0x58021420 0x99000000 0x66000000    ;# AFRL
    mmw 0x58021424 0x000009AA 0x00000655    ;# AFRH
    # Port G: PG06:AF10:H
    mmw 0x58021800 0x00002000 0x00001000    ;# MODER
    mmw 0x58021808 0x00002000 0x00001000    ;# OSPEEDR
    mmw 0x5802180C 0x00000000 0x00003000    ;# PUPDR
    mmw 0x58021820 0x0A000000 0x05000000    ;# AFRL

    # correct FSIZE is 0x16, however, this causes trouble when
    # reading the last bytes at end of bank in *memory mapped* mode

    # for single flash mode w25q64jv
                                            ;# 010101010000000000000 0 011000
    mww 0x52005000 0x05500018               ;# QUADSPI_CR: PRESCALER=5, APMS=1, FTHRES=1, FSEL=0, DFM=0, SSHIFT=1, TCEN=1
    mww 0x52005004 0x00160500               ;# QUADSPI_DCR: FSIZE=0x16, CSHT=0x05, CKMODE=0
                                            ;# FSIZE flash的大小。

    mww 0x52005030 0x00001000               ;# QUADSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full
                                            ;# 11010000000000 10 010100000011
    mww 0x52005014 0x0D002503               ;# QUADSPI_CCR: FMODE=0x3, DMODE=0x1, DCYC=0x0, ADSIZE=0x2, ADMODE=0x1, IMODE=0x1
    mmw 0x52005000 0x00000001 0             ;# QUADSPI_CR: EN=1

    # Exit QPI mode
    #mmw 0x52005000 0x00000002 0            ;# QUADSPI_CR: ABORT=1
    #mww 0x52005014 0x000003F5              ;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x3, INSTR=Exit QPI
    sleep 1

    # reset flash
    mmw 0x52005000 0x00000002 0             ;# QUADSPI_CR: ABORT=1
    mww 0x52005014 0x00000166               ;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x1, INSTR=0x66
    mww 0x52005014 0x00000199               ;# QUADSPI_CCR: FMODE=0x0, DMODE=0x0, DCYC=0x0, ADSIZE=0x0, ADMODE=0x0, IMODE=0x1, INSTR=0x99

    # memory-mapped read mode with 3-byte addresses
    mmw 0x52005000 0x00000002 0             ;# QUADSPI_CR: ABORT=1
                                            ;# 11 11 0 00100 00 11 10 11 01 11101011
    mww 0x52005014 0x0F10EDEB               ;# QUADSPI_CCR: FMODE=0x3, DMODE=0x3, DCYC=0x4, ADSIZE=0x2, ADMODE=0x3, IMODE=0x1, INSTR=READ
    ;mww 0x52005014 0x0D002503
}

$_CHIPNAME.cpu0 configure -event reset-init {
    global QUADSPI

    mmw 0x52002000 0x00000004 0x0000000B    ;# FLASH_ACR: 4 WS for 192 MHZ HCLK

    mmw 0x58024400 0x00000001 0x00000018    ;# RCC_CR: HSIDIV=1, HSI on
    mmw 0x58024410 0x10000000 0xEE000007    ;# RCC_CFGR: MCO2=system, MCO2PRE=8, HSI as system clock
    mww 0x58024418 0x00000040               ;# RCC_D1CFGR: D1CPRE=1, D1PPRE=2, HPRE=1
    mww 0x5802441C 0x00000440               ;# RCC_D2CFGR: D2PPRE2=2, D2PPRE1=2
    mww 0x58024420 0x00000040               ;# RCC_D3CFGR: D3PPRE=2
    mww 0x58024428 0x00000040               ;# RCC_PPLCKSELR: DIVM3=0, DIVM2=0, DIVM1=4, PLLSRC=HSI
    mmw 0x5802442C 0x0001000C 0x00000002    ;# RCC_PLLCFGR: PLL1RGE=8MHz to 16MHz, PLL1VCOSEL=wide
    mww 0x58024430 0x01070217               ;# RCC_PLL1DIVR: 192 MHz: DIVR1=2, DIVQ=8, DIVP1=2, DIVN1=24
    mmw 0x58024400 0x01000000 0             ;# RCC_CR: PLL1ON=1
    sleep 1
    mmw 0x58024410 0x00000003 0             ;# RCC_CFGR: PLL1 as system clock
    sleep 1

    adapter speed 24000

    if { $QUADSPI } {
        qspi_init
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>改代码中主要就初始化了QSPI外设的GPIO，并配置了QSPI外设，使用的板子是ART-Pi；</p>
<p>使用的GPIO是： PF10,PF09,PF08,PF07,PF06,PG06.</p>
<p>相关外设初始化主要时钟匹配自己的芯片速度。</p>
<p>这里主要参考链接：</p>
<p><a href="https://github.com/suguguan/EmbeddedProjectTemplates/blob/main/BootLoader_Application/Application/STM32H750VBTX_RAM.ld">在CLion上实现STM32H750VBT6的Bootloader</a></p>
<p><a href="https://club.rt-thread.org/ask/article/95a03d2494e01ada.html">使用openOCD擦写ART_Pi外部qspi_flash</a></p>
<p>两个教程都很全面，并且将代码文件、配置文件都开源了，去点星星咯。</p>
<p>大家可以根据自己的板子的引脚定义进行修改相关寄存器即可。</p>
<p>到这里，基本完成了配置，可以实现在clion中通过openocd实现向单片机外置flash下载代码，并进行仿真调试了。</p>
<h2 id="从外置flash中启动代码"><a href="#从外置flash中启动代码" class="headerlink" title="从外置flash中启动代码"></a>从外置flash中启动代码</h2><p>不管上面如何下载代码，都需要从外置flash启动，前面也简略提到了——我们需要在单片机的内置flash中下载一个bootloader代码，用于从外置flash启动。</p>
<p>这个代码比较简单，就初始化一点点外设，主要还是QSPI，然后关闭Cache、MPU，对外置flash进行内存映射，并启动。具体内容可以参考安福莱教程。</p>
<p><a href="https://blog.csdn.net/Simon223/article/details/109903301">硬汉嵌入式的bootloader教程</a></p>
<p>我的是修改的反客科技的bootloader代码，将其QSPI外设的引脚改成我的板子的就可以用了。是之前用keil5写的，也可以自己用cubemx生成一个，添加应用代码即可。比较简单。</p>
<p><a href="https://github.com/augetyz/stm32/tree/master/H750XBH6%E4%B8%8B%E8%BD%BD%E7%AE%97%E6%B3%95">适配ART-Pi的下载算法和bootloader</a></p>
<p>另外，从外置flash引导的代码，受flash限制，运行速度并不快，不如芯片内部的flash，对此，我们参考安福莱教程，使用MPU配置外置flash内存，用Cache预存取指令，提高代码运行速度。相关配置：<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1721605878766.png" alt="Cubemx配置"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">MPU_Region_InitTypeDef MPU_InitStruct <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/* Disables the MPU */</span>
<span class="token function">HAL_MPU_Disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/** Initializes and configures the Region and the memory to be protected
*/</span>
MPU_InitStruct<span class="token punctuation">.</span>Enable <span class="token operator">=</span> MPU_REGION_ENABLE<span class="token punctuation">;</span>
MPU_InitStruct<span class="token punctuation">.</span>Number <span class="token operator">=</span> MPU_REGION_NUMBER0<span class="token punctuation">;</span>
MPU_InitStruct<span class="token punctuation">.</span>BaseAddress <span class="token operator">=</span> <span class="token number">0x90000000</span><span class="token punctuation">;</span>
MPU_InitStruct<span class="token punctuation">.</span>Size <span class="token operator">=</span> MPU_REGION_SIZE_8MB<span class="token punctuation">;</span>
MPU_InitStruct<span class="token punctuation">.</span>SubRegionDisable <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>
MPU_InitStruct<span class="token punctuation">.</span>TypeExtField <span class="token operator">=</span> MPU_TEX_LEVEL1<span class="token punctuation">;</span>
MPU_InitStruct<span class="token punctuation">.</span>AccessPermission <span class="token operator">=</span> MPU_REGION_FULL_ACCESS<span class="token punctuation">;</span>
MPU_InitStruct<span class="token punctuation">.</span>DisableExec <span class="token operator">=</span> MPU_INSTRUCTION_ACCESS_ENABLE<span class="token punctuation">;</span>
MPU_InitStruct<span class="token punctuation">.</span>IsShareable <span class="token operator">=</span> MPU_ACCESS_NOT_SHAREABLE<span class="token punctuation">;</span>
MPU_InitStruct<span class="token punctuation">.</span>IsCacheable <span class="token operator">=</span> MPU_ACCESS_CACHEABLE<span class="token punctuation">;</span>
MPU_InitStruct<span class="token punctuation">.</span>IsBufferable <span class="token operator">=</span> MPU_ACCESS_BUFFERABLE<span class="token punctuation">;</span>

<span class="token function">HAL_MPU_ConfigRegion</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>MPU_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Enables the MPU */</span>
<span class="token function">HAL_MPU_Enable</span><span class="token punctuation">(</span>MPU_PRIVILEGED_DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>MPU配置代码。</p>
<p>相关教程：</p>
<p><a href="https://blog.csdn.net/as480133937/article/details/123663197?spm=1001.2014.3001.5506">理论学习，详细好理解</a></p>
<p><a href="https://blog.csdn.net/Simon223/article/details/90690541?spm=1001.2014.3001.5506">硬汉哥的MPU教程</a></p>
<p><a href="https://blog.csdn.net/Simon223/article/details/124649487?spm=1001.2014.3001.5506">硬汉哥的实战教程，超级好用</a></p>
<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>在clion使用openocd仿真的话，为了查看各个寄存器的值，需要添加寄存器配置文件，一般keil5安装目录里有，我把我的上传到Github上了，欢迎下载。</p>
<p><a href="https://github.com/augetyz/STM32_svd_file">SVD文件</a></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1721605892344.png" alt="仿真视图"></p>
<p>欢迎访问<a href="https://sparkle-now.cn/">我的博客</a>
    </p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>CLion</tag>
        <tag>QSPI</tag>
        <tag>openocd</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式学习简介</title>
    <url>/2023/07/23/qian-ru-shi-xue-xi-jian-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="嵌入式学习方向介绍"><a href="#嵌入式学习方向介绍" class="headerlink" title="嵌入式学习方向介绍"></a>嵌入式学习方向介绍</h1><h2 id="视频简介"><a href="#视频简介" class="headerlink" title="视频简介"></a>视频简介</h2><iframe src="//player.bilibili.com/player.html?aid=378089584&amp;bvid=BV1Hf4y1w7BH&amp;cid=410341156&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="400px" height="300px"> </iframe>

<h2 id="嵌入式系统简介"><a href="#嵌入式系统简介" class="headerlink" title="嵌入式系统简介"></a>嵌入式系统简介</h2><p><strong>在我的两年学习经历中，嵌入式对我而言即是兴趣也是未来发展的方向。</strong></p>
<p><strong>在我看来，嵌入式就是设计合适的能够完成目标任务需求的电子装置。在其中，我们会使用电气知识设计适用的电路板，在其中添加计算机控制单元——MCU，我们使用C语言（主要）或者其他编程语言对单片机进行编程，实现控制需求。</strong></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%BB%8B%E7%BB%8D/ART-Pi.jpg" alt="1.单片机图"></p>
<p>比较正式的说法：<em><strong>嵌入式即嵌入式系统，IEEE（美国电气和电子工程师协会）对其定义是用于控制、监视或者辅助操作机器和设备的装置，是一种专用的计算机系统；国内普遍认同的嵌入式系统定义是以应用为中心，以计算机技术为基础，软硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗等严格要求的专用计算机系统；从应用对象上加以定义来说，嵌入式系统是软件和硬件的综合体，还可以涵盖机械等附属装置。</strong></em></p>
<p>嵌入式同时设计软件和硬件，在实际开发中，会专精一个方向，另一个辅修——嵌入式硬件工程师和嵌入式软件工程师，像我的话，主要是偏向软件方向，但我也会了解使用电路知识，PCB设计工具；认识的一个在公司里的硬件工程师大佬，就主攻硬件电路，软件方面主要使用STM32实现控制，会部署一些中间件在其中方便实现控制功能；</p>
<h2 id="科创中心嵌入式小组"><a href="#科创中心嵌入式小组" class="headerlink" title="科创中心嵌入式小组"></a>科创中心嵌入式小组</h2><p><strong>在大学生科创中心，开设有嵌入式学习小组，每年会招收新成员进入培训，指导学习STM32、PCB设计、运动控制、FreeRtos、物联网等技术知识，会有学长带领学员设计机器人、无人机、智能小车等嵌入式系统集成设备，在实践中学习，在学习中探索未来，提高工科生的自我认知。</strong></p>
<p>在实践学习中，科创中心的嵌入式小组主要发展为多个方向：</p>
<p><strong>无人机组</strong> ：</p>
<p><strong>工程小车组</strong>：</p>
<p><strong>物联网开发组</strong>：</p>
<p><strong>Ros机器人组</strong> ：</p>
<p><strong>有趣的作品分享</strong>:</p>
<iframe src="//player.bilibili.com/player.html?aid=226936627&amp;bvid=BV1Uh41137Th&amp;cid=1078338627&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="400px" height="300px"> </iframe>


<iframe src="//player.bilibili.com/player.html?aid=420981979&amp;bvid=BV12341117rG&amp;cid=421416333&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="400px" height="300px"> </iframe>   


<iframe src="//player.bilibili.com/player.html?aid=677612560&amp;bvid=BV1zm4y197Py&amp;cid=467867782&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="400px" height="300px"> </iframe>


]]></content>
  </entry>
  <entry>
    <title>STM32串口学习</title>
    <url>/2023/10/01/chuan-kou-xue-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="串口学习"><a href="#串口学习" class="headerlink" title="串口学习"></a>串口学习</h2><h4 id="用到新器件："><a href="#用到新器件：" class="headerlink" title="用到新器件："></a>用到新器件：</h4><p>USB转TTL</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923473260.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">USB 转 TTL 模块 GND</th>
<th align="left">单片机 GND 口</th>
</tr>
</thead>
<tbody><tr>
<td align="left">USB 转 TTL 模块 TXD</td>
<td align="left">PA10</td>
</tr>
<tr>
<td align="left">USB 转 TTL 模块 RXD</td>
<td align="left">PA9</td>
</tr>
<tr>
<td align="left">USB 转 TTL 模块 USB 口</td>
<td align="left">电脑 USB</td>
</tr>
</tbody></table>
<ol>
<li>并行通信和串行通信 所谓通信，其实说白了就是处理器与外部设备之间的交流，就像电脑连接键盘、鼠标或打印机之类。计算机领域的通信一般有两种方式，即并行通信和串行通信。这两种方式的优缺点对比如下：</li>
</ol>
<p>并行通信<br>&nbsp;&nbsp; -传输原理：数据各个位同时传输。</p>
<p>&nbsp;&nbsp; -优点：速度快</p>
<p>&nbsp;&nbsp; -缺点：占用引脚资源多</p>
<p>串行通信<br>&nbsp;&nbsp; -传输原理：数据按位顺序传输。</p>
<p>&nbsp;&nbsp; -优点：占用引脚资源少</p>
<p>&nbsp;&nbsp; -缺点：速度相对较慢</p>
<ol>
<li><p>串行通信的分类</p>
<p>按照数据的传送方向可以分为：</p>
</li>
</ol>
<p>单工：数据传输只支持数据在一个方向上传输<br>半双工：允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；<br>全双工：允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。</p>
<p>关于 UART 和 USART：</p>
<p>UART 串口通信协议全称叫做通用异步收发传输器 （Universal Asynchronous Receiver/Transmitter）、</p>
<p>USART 串口通信协议全称叫做通用同步异步收发传输器（universal synchronous asynchronous receiver and transmitter）</p>
<p>一般的单片机 UART 和 USART 使用方式是一样的，都使用异步模式，所以我们 初期学习 stm32 串口的使用，学的就是 uart 类型的异步串口通信。</p>
<p>TTL：TTL 电平信号规定，+5V 等价于逻辑“1”，0V 等价于逻辑“0”(采用二进制来表示数据时)。这样的数据通信及电平规定方式，被称做 TTL（晶体管-晶体管逻辑电 平）信号系统。TTL 设备使用的电压水平普遍为 5V 或 3.3V，目前咱们学习单片机TTL电压是3.3V，故把跳线帽中 VCC和3.3连一起。</p>
<p>.在使用前要安装上CH340驱动。</p>
<p>TXD 发送数据 Transmit(tx) Data 简写形式 RXD 接受数据 Receive(rx) Data 简写形式 TXD 和 TX，RXD 和 RX 其实是一个意思。所以要这样交叉连，TTL 模块的 TXD就相当于电脑的发送接口，那当然就要连 STM32 的接收接口，也就是 RX，一 端发送，另一端接收。 另一条线路同理。</p>
<p>现在咱们了解一下波特率：</p>
<p>波特率(Baud Rate)单位 bps – 每秒传送的二进制位数 bit Per Second.。9600bps 就是每秒传输 9600 位。 因为一个字节是 8 个 bit，而一个字节通常可以表达一个 ASCII 码，比如一个英 文字母，所以：9600 的波特率的信道（信号的传递通道），理论上每秒可以传 输 9600/8 个英文字母的数据量，也就是 1200 个字节，大约 1.2KB。 （1 字节=1B=8 位=8bit）。</p>
<p>p.s. 如果 1.2KB/s 的网速，可以想象通信有多慢，所以 uart 通信并不是高速通信。</p>
<p>相关寄存器：</p>
<p>USART_SR状态寄存器<br>USART_DR数据寄存器<br>USART_BRR波特率寄存器</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923486356.png" alt="image"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923493806.png" alt="image"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923517843.png" alt="image"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923526205.png" alt="image"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923532868.png" alt="image"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uart_init</span><span class="token punctuation">(</span>u32 bound<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token comment">//GPIO端口设置   PA9--TXD  PA10--RXD</span>
GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>
USART_InitTypeDef USART_InitStructure<span class="token punctuation">;</span>
NVIC_InitTypeDef NVIC_InitStructure<span class="token punctuation">;</span>
<span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_USART<span class="token operator">|</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//使USART1，GPIOA时钟</span>

<span class="token comment">//USART1_TX   GPIOA.9---输出</span>
GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_9<span class="token punctuation">;</span> <span class="token comment">//PA.9</span>
GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>
GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_AF_PP<span class="token punctuation">;</span>	<span class="token comment">//复用推挽输出</span>
<span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化GPIOA.9</span>

<span class="token comment">//USART1_RX	  GPIOA.10初始化---输入</span>
GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_10<span class="token punctuation">;</span><span class="token comment">//PA10</span>
GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IN_FLOATING<span class="token punctuation">;</span><span class="token comment">//浮空输入</span>
<span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化GPIOA.10  </span>

<span class="token comment">//Usart1 NVIC 配置     串口接收信息时会频繁进入串口接受中断，为了不影响其他程序正常运行，一般把中断两位优先级调最低。</span>
NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannel <span class="token operator">=</span> USART1_IRQn<span class="token punctuation">;</span>
NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelPreemptionPriority<span class="token operator">=</span><span class="token number">3</span> <span class="token punctuation">;</span><span class="token comment">//抢占优先级3</span>
NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelSubPriority <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>		<span class="token comment">//子优先级3</span>
NVIC_InitStructure<span class="token punctuation">.</span>NVIC_IRQChannelCmd <span class="token operator">=</span> ENABLE<span class="token punctuation">;</span>			<span class="token comment">//IRQ通道使能</span>
<span class="token function">NVIC_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>NVIC_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//根据指定的参数初始化VIC寄存器</span>
<span class="token comment">//USART 初始化设置</span>
    USART_InitStructure<span class="token punctuation">.</span>USART_BaudRate <span class="token operator">=</span> bound<span class="token punctuation">;</span><span class="token comment">//串口波特率</span>
    USART_InitStructure<span class="token punctuation">.</span>USART_WordLength <span class="token operator">=</span> USART_WordLength_8b<span class="token punctuation">;</span><span class="token comment">//字长为8位数据格式   还有九位，一般用八位。</span>
    USART_InitStructure<span class="token punctuation">.</span>USART_StopBits <span class="token operator">=</span> USART_StopBits_1<span class="token punctuation">;</span><span class="token comment">//一个停止位</span>
    USART_InitStructure<span class="token punctuation">.</span>USART_Parity <span class="token operator">=</span> USART_Parity_No<span class="token punctuation">;</span><span class="token comment">//无奇偶校验位</span>
    USART_InitStructure<span class="token punctuation">.</span>USART_HardwareFlowControl <span class="token operator">=</span> USART_HardwareFlowControl_None<span class="token punctuation">;</span><span class="token comment">//无硬件数据流控制   --一般没用过</span>
    USART_InitStructure<span class="token punctuation">.</span>USART_Mode <span class="token operator">=</span> USART_Mode_Rx <span class="token operator">|</span> USART_Mode_Tx<span class="token punctuation">;</span>	<span class="token comment">//收发模式</span>

<span class="token function">USART_Init</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>USART_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化串口1</span>
<span class="token function">USART_ITConfig</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> USART_IT_RXNE<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启串口接受中断</span>
<span class="token function">USART_Cmd</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//使能串口1</span>
<span class="token punctuation">}</span>

<span class="token comment">//重定义fputc函数 ---重定向printf，直接复制即可</span>
<span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">,</span> FILE <span class="token operator">*</span>f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>      
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR<span class="token operator">&amp;</span><span class="token number">0X40</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//循环发送,直到发送完毕   </span>
    USART1<span class="token operator">-&gt;</span>DR <span class="token operator">=</span> <span class="token punctuation">(</span>u8<span class="token punctuation">)</span> ch<span class="token punctuation">;</span>      
	<span class="token keyword">return</span> ch<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*如果使用多个串口只需修改USART1即可,
ps .USART1-&gt;USART3    */</span>
<span class="token comment">//故如果要打印自己姓名只需在main中printf即可</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>









]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>串口</tag>
      </tags>
  </entry>
  <entry>
    <title>工创赛总结与改进-方案分享</title>
    <url>/2024/07/20/gong-chuang-sai-zong-jie-yu-gai-jin-fang-an-fen-xiang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="工创赛总结与改进——方案分享"><a href="#工创赛总结与改进——方案分享" class="headerlink" title="工创赛总结与改进——方案分享"></a>工创赛总结与改进——方案分享</h1><h2 id="biubiu小队方案开源"><a href="#biubiu小队方案开源" class="headerlink" title="biubiu小队方案开源"></a>biubiu小队方案开源</h2><p><a href="https://github.com/augetyz/Logistics-handling-robot">项目开源链接</a></p>
<h3 id="元件方案"><a href="#元件方案" class="headerlink" title="元件方案"></a>元件方案</h3><table>
<thead>
<tr>
<th align="left">元件</th>
<th>型号</th>
<th>数量</th>
<th>单价</th>
<th align="left">总价</th>
<th>淘宝链接</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">电机</td>
<td>直流减速电机-光电编码器</td>
<td>4</td>
<td>53</td>
<td align="left">212</td>
<td><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-22559033097.25.44df5429FgPwn6&amp;id=654189188705">驰海电机光电编码器直流有刷减速电机</a></td>
<td>50减速比12V光电编码器</td>
</tr>
<tr>
<td align="left">麦轮</td>
<td>70mm麦克纳姆轮*4</td>
<td>1</td>
<td>356</td>
<td align="left">356</td>
<td><a href="https://item.taobao.com/item.htm?spm=a21n57.1.item.2.4b28523cGvMwaI&amp;priceTId=2147813817199835120061823efa7c&amp;utparam=%7B%22aplus_abtest%22:%2219e07871792c9085a39f501b3647cf48%22%7D&amp;id=565314058762&amp;ns=1&amp;abbucket=2">天府之土麦克纳姆轮四个356</a></td>
<td>6mm联轴器</td>
</tr>
<tr>
<td align="left">关节电机</td>
<td>HP8-U45-M</td>
<td>3</td>
<td>295</td>
<td align="left">894</td>
<td><a href="https://item.taobao.com/item.htm?spm=a1z10.1-c.w5003-24492893941.5.69356d6b5E3F9w&amp;ft=t&amp;id=600130669485&amp;scene=taobao_shop">fashionstar伺服总线舵机45kg 低压 360度磁编码器</a></td>
<td>单轴，低压</td>
</tr>
<tr>
<td align="left">关节电机</td>
<td>HA8-U25</td>
<td>2</td>
<td>95</td>
<td align="left">190</td>
<td><a href="https://item.taobao.com/item.htm?spm=pc_detail.29232929/evo365560b447259.guessitem.d0.7d707dd6Y7grYC&amp;id=612208687596&amp;skuId=5488690653175">25KG总线伺服舵机</a></td>
<td>单轴，双轴各一个，一个用在物料台，一个用在爪子；和45kg的是一家的，协议相同。</td>
</tr>
<tr>
<td align="left">摄像头</td>
<td>USB免驱摄像头</td>
<td>1</td>
<td>125</td>
<td align="left">125</td>
<td><a href="https://item.taobao.com/item.htm?spm=a21n57.1.item.3.7f29523c3lKImb&amp;priceTId=214781b017199840207307034e921a&amp;utparam=%7B%22aplus_abtest%22:%22806cfe1c9bebc0d7ccf05936586bf52c%22%7D&amp;id=608890578560&amp;ns=1&amp;abbucket=2&amp;skuId=4590741982799">1080P150度线长1.5m</a></td>
<td>1080P150超广角</td>
</tr>
<tr>
<td align="left">主控</td>
<td>STM32F407VET6</td>
<td>1</td>
<td>50</td>
<td align="left">50</td>
<td><a href="https://item.taobao.com/item.htm?id=581847252103&amp;spm=a21xtw.29178619/evo565760b742010">反客科技板子</a></td>
<td>无</td>
</tr>
<tr>
<td align="left">图像处理模块</td>
<td>旭日X3派V1.2</td>
<td>1</td>
<td>329</td>
<td align="left">329</td>
<td><a href="https://detail.tmall.com/item.htm?spm=a21n57.1.item.50.4b57523cHKuvR0&amp;priceTId=213e367317199843920893644ed32a&amp;utparam=%7B%22aplus_abtest%22:%221433271ce593c081c7068056213ddf36%22%7D&amp;id=675925264685&amp;ns=1&amp;abbucket=2&amp;skuId=5036279679561">老版本好像找不到了，这个是V2.0版本，都差不多</a></td>
<td>RDK X3就是新版本，不影响。</td>
</tr>
<tr>
<td align="left">电池</td>
<td>疾风3s锂电池</td>
<td>1</td>
<td>105</td>
<td align="left">105</td>
<td><a href="https://item.taobao.com/item.htm?spm=a21n57.1.item.2.3a93523cbLkXbV&amp;priceTId=213e36aa17199845169426203e8c59&amp;utparam=%7B%22aplus_abtest%22:%223e68ffdafb8ac8ceeda574c04f3ff18b%22%7D&amp;id=527326501663&amp;ns=1&amp;abbucket=2&amp;skuId=5076199582403">疾风锂电池</a></td>
<td>3s T型头 5200mah 40C</td>
</tr>
<tr>
<td align="left">二维码扫描</td>
<td>优信电子家的二维码识别模块</td>
<td>1</td>
<td>95</td>
<td align="left">95</td>
<td><a href="https://item.taobao.com/item.htm?spm=a1z10.3-c-s.w4002-24706531953.9.7ef46a4bvC7Nn7&amp;id=567857929280">二维码识别模块</a></td>
<td></td>
</tr>
<tr>
<td align="left">陀螺仪</td>
<td>HWT101</td>
<td>1</td>
<td>337</td>
<td align="left">337</td>
<td><a href="https://detail.tmall.com/item.htm?spm=a21n57.1.item.3.f8c9523cf7W9I7&amp;priceTId=2147bfe817199850086942652ebd4d&amp;utparam=%7B%22aplus_abtest%22:%22e008b761d9f12406719dc2a5b768e64c%22%7D&amp;id=597962220436&amp;ns=1&amp;abbucket=2&amp;skuId=4166570152578">单轴水晶陀螺仪</a></td>
<td>没必要</td>
</tr>
<tr>
<td align="left">总计</td>
<td></td>
<td></td>
<td></td>
<td align="left">2595</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>再加上耗材，线材，PCB元件之类的，应该3000左右，尽管便宜，但并不好，电机不是很好，图像处理够用，但一边调试一边图像处理会很卡，陀螺仪性能过剩了，关节电机略贵，我建议可以整步进电机，又准又便宜，不会写代码就用FOC模块</strong></p>
<h3 id="建议元件更迭"><a href="#建议元件更迭" class="headerlink" title="建议元件更迭"></a>建议元件更迭</h3><table>
<thead>
<tr>
<th align="left">元件</th>
<th>型号</th>
<th>数量</th>
<th>单价</th>
<th align="left">总价</th>
<th>淘宝链接</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">电机</td>
<td>42步进电机</td>
<td>4</td>
<td>35</td>
<td align="left">140</td>
<td><a href="https://item.taobao.com/item.htm?spm=a21n57.1.item.4.1e53523cmZI0ax&amp;priceTId=2147bfb317199855784775748e86e1&amp;utparam=%7B%22aplus_abtest%22:%227607bc6fb736f94d43f822fcc9ad0c45%22%7D&amp;id=682797640293&amp;ns=1&amp;abbucket=2&amp;skuId=5057239338766">张大头42步进电机</a></td>
<td>长度48mm</td>
</tr>
<tr>
<td align="left">闭环控制器</td>
<td>EMM42_V5.0_Can通信</td>
<td>4</td>
<td>57</td>
<td align="left">228</td>
<td><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-23494047132.12.7cad2d7e3XHTle&amp;id=673302946671">张大头步进电机伺服控制器</a></td>
<td>CAN总线通信或者485通信都行，级连的话注意通信速度够不够，好多电机呢，可能要加can总线扩展板。</td>
</tr>
<tr>
<td align="left">机械臂关节电机</td>
<td>也用步进电机最好</td>
<td></td>
<td></td>
<td align="left"></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">主控+陀螺仪</td>
<td>大疆A板或者达妙的DM-MC02（H723）</td>
<td>1</td>
<td>199（达妙）</td>
<td align="left">199</td>
<td><a href="https://item.taobao.com/item.htm?spm=a1z10.1-c-s.w137644-23556904997.41.349028f6E2GmXx&amp;id=767305853444&amp;skuId=5440731611044">达妙电机控制板</a></td>
<td>大疆的A板也可以，代码很多，达妙的DM-MC02是H7主控，MC01是F4，MC01没有板载陀螺仪，我更喜欢DM-MC02，H7真好玩</td>
</tr>
</tbody></table>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>选什么元件，要根据题目需求，自己的需求定，你要使用什么样的机械臂，什么样的运动方式，定了之后，再去选择相应的元件。</p>
<p><strong>这里给大家分享一个提高车车运行速度，也很有用的设计点。</strong></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/03/17199866903404.jpg" alt="在这里，花费时间最长"></p>
<p><strong>这个地方，因为转盘运动，绝大部分队伍都是选择在这里使用摄像头监视，“等待”目标物料转到自己面前</strong></p>
<p>物料更迭的速度最快也要6s，所以在这个地方，按照我们大多数队伍的方案，最多需要花费：12s+12s+12s=36s，最少也需要12s；而且往往我们写代码并不会看到就抓，因为我们不知道下一秒物料是不是就转走了，我们可能会放弃第一次看到物料就是目标物料而去抓的机会，因为这绝大多数抓了就寄。自己实践就知道了。</p>
<p>有些大佬，以及我的队友徐狗蛋，想到了一种方法，<strong>我们不再原地等待，我们用摄像头扫描整个转盘，或者扫描两个物料，就可以获得原料区物料随时间变化各个颜色物料的位置状态，然后我们的机器人不再等待目标物料来到跟前再去抓，我们使用有效范围更长的机械臂，在物料停稳定后，机械臂伸出去，直接去拿我们想要的，化被动为主动</strong>。这样每次都可以控制在15s左右拿完物料；甚至更低，不用等它停稳，直接抓，能做到的队那么他们的机械臂控制绝对相当牛逼，那么后面的环节，放置物料什么的更不在话下。</p>
<p>而且，因为这个方案点，我们给机器人扩展了一种新的摄像头运用方式，扫描物料台；如果我们队在2023年，使用了这个方案，那么面对决赛题目，就不会那么无力了，因为这个方法可以解决决赛题目最难的两个点位；</p>
<p>2023年徐总提了这个方案，我没用，否了，原因很简单，2023比赛题目中规定了机器人以及机器人投影不能出界，不是压到黄色地区，而是直接说了不能出界，原料区的转盘有一半在场地外；郑州省赛上很多模糊不清的规则大都直接判犯规了，好不容易进国赛了，我不愿意冒险；还有一个原因当时我没给徐说，我们的机械臂结构根本做不到，我不想拆不想改，时间不够了。</p>
<p>但2025年不一样了，比赛文件中直接说了机械臂只要符合规定，随便去哪里。随意读到这个总结的学弟学妹们，一定要认真思考一下面对这种转盘式的物料台，需不需要制定这样的化被动为主动的方案，如果决定做了，对机械臂设计，摄像头位置，都有很大影响。</p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>工创赛总结与改进-比赛解读</title>
    <url>/2024/07/20/gong-chuang-sai-zong-jie-yu-gai-jin-bi-sai-jie-du/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="工创赛总结与改进——比赛解读"><a href="#工创赛总结与改进——比赛解读" class="headerlink" title="工创赛总结与改进——比赛解读"></a>工创赛总结与改进——比赛解读</h1><p>这里附2023年工创赛题目文件链接，重点是国赛决赛规则和初赛规则的对比。</p>
<p><a href="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/2023%E5%B9%B4%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%88%9B%E6%96%B0%E8%83%BD%E5%8A%9B%E5%A4%A7%E8%B5%9B.pdf">2023年中国大学生工程实践与创新能力大赛.pdf</a></p>
<p><a href="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/2023%E5%B7%A5%E5%88%9B%E8%B5%9B%E5%9B%BD%E8%B5%9B%E5%86%B3%E8%B5%9B%E9%A2%98%E7%9B%AE.pdf">2023工创赛国赛决赛题目.pdf</a></p>
<blockquote>
<p>2025年规则我大致看了下，和2023年区别不是特别大，所以我直接用2025年规则给大家分享一下我注意到的坑，然后再说一下国赛决赛规则上的坑。</p>
</blockquote>
<blockquote>
<p>标注使用Notability软件，上传图片和PDF，大家凑合看。</p>
</blockquote>
<h2 id="2025初赛规则简单标注分享"><a href="#2025初赛规则简单标注分享" class="headerlink" title="2025初赛规则简单标注分享"></a>2025初赛规则简单标注分享</h2><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/02/17199004546877.jpg"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/02/17199004767668.jpg"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/02/17199004857173.jpg"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/02/17199004937326.jpg"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/02/17199005009835.jpg"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/02/17199005365467.jpg"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/02/17199005434304.jpg"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/02/17199005510948.jpg"></p>
<h2 id="2023年国赛决赛规则简单分析"><a href="#2023年国赛决赛规则简单分析" class="headerlink" title="2023年国赛决赛规则简单分析"></a>2023年国赛决赛规则简单分析</h2><p><strong>看完也别觉得太难，难才有意思，放这个是让大家思考，准备的更加全面，时间还长，大半年的准备，根据我们提供的教程，信息，认真做的话，最后成果肯定暴打去年我们队</strong></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/02/17199151757886.jpg"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/02/17199151828043.jpg"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/02/17199151911374.jpg"></p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>工创赛总结与改进-历程分享</title>
    <url>/2024/07/20/gong-chuang-sai-zong-jie-yu-gai-jin-li-cheng-fen-xiang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="工创赛总结与改进——历程分享"><a href="#工创赛总结与改进——历程分享" class="headerlink" title="工创赛总结与改进——历程分享"></a>工创赛总结与改进——历程分享</h1><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我们队是从2023年寒假开始准备的，我是做嵌入式软件的，那时候找了两个队友，机械Z和硬件Q，都是寒假前联系的，准备在寒假多学习一些相关内容，开学开干；寒假时，硬件Q联系不上了，队里缺画板子的，我寒假玩FreeRtos玩一半，开始学习硬件设计；整个寒假没有准备什么和工创赛相关的，只是烧了六七块板子。<br>开学后，联系了个22级嵌入式学的最好的学弟，拉他入伙，还差一个人，找了我的老搭档CZW，本来他是做嵌入式的，来队里后，被我忽悠着，去学了K210和V831，后续版本更新，又整了树莓派，转行玩视觉了。四个人齐了，开干。</p>
<h2 id="105调车"><a href="#105调车" class="headerlink" title="105调车"></a>105调车</h2><p>三月份开始准备，东拼西凑了点钱，启动资金2000块，刚开始不会做，哪里有人教呀，就会玩个编码器电机和舵机，也没钱，匆匆搭了一辆车，代码调了很多次，能跑能动；<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/06/30/17197458838877.png" alt="biubiu一号"><br>看着很low吧，是这样的，因为什么都不太会，所以只能早点干了，而且这个图好像是四五月份拍的了，我们学校当时说五月中旬校赛，慌得一批，使劲调，结果最后延期啦哈哈哈哈。</p>
<h2 id="611调车"><a href="#611调车" class="headerlink" title="611调车"></a>611调车</h2><p>这辆车车设备不咋地，精度很差，而且最关键的是，我们实验室太小了，就在进门口搭了一块地图，还展不开，人来人往的踩来踩去，学院没给批实验室，找老师从学生会的宿舍活动室扣了一块地，那是他们用来放杂物的，在宿舍顶楼，五六月份，没有空调，顶楼朝阳，我嘞个热呀，没办法，在那里调试了一个月左右，才找到新地方。</p>
<h2 id="310调车"><a href="#310调车" class="headerlink" title="310调车"></a>310调车</h2><p>快要校赛的时候（还是延期），学校还没搭好场地，我联系了比赛负责老师，跟他说想要帮忙搭建校赛场地，主动请缨，抓住机会，在创新创业学院弄了个场地，有空调，有电，有水，有厕所，活了🥹。<br>地图是自己根据文件画的，转盘是自己搓的，粗加工区也是，原料区位置画的远了，语文不好，数据读错了，但问题不大；加了围栏是因为比赛规则文件上画的就有围栏，几把我们队一直是以有围栏环境做的车车，我们用了俩激光测距做定位，日了，第一年改规则害人呀草。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/06/30/17197467835375.jpg" alt="当时搭的地图"><br>我们学校不久开始了第一次校赛（一共整了三次，主要是大家做的都不是太好，老师用校赛跟进，催进度）<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/06/30/17197471426985.jpg" alt="第一次校赛"><br>中间车车做出来能跑了之后，找了我的学业指导老师做比赛指导老师，老师真的好，买东西基本都同意，2000多元以下都OK的，我们换了总线舵机，天府之土麦轮，树莓派，大电池。<br>这期间队友机械Z总是生病，来来回回去医院好多次，我开始学AutoCAD，画亚克力，他搞solidworks画3维结构件。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/06/30/17197475253667.jpg" alt="biubiu小队"><br>大二下学期整了一学期工创赛，学习成绩拉的一批，但东西是做出来了，尽管不咋地，但也一直是校赛第一。暑假我去深圳实习了，找了个嵌软实习生，队友在学校调车，基本硬件不大改的话，学弟能调的过来，进度在推进。<br>我的队友机械Z彻底病倒了，肺炎去医院躺着了，而且因为是大二下学期，被迫留级了。我找了新的负责机械的队友机械W。</p>
<h2 id="403调车"><a href="#403调车" class="headerlink" title="403调车"></a>403调车</h2><p>2023年下半年开学，创院领导换届，我们队整个被赶到工训中心了，很偏，创院在学校中心位置，工训在学校角落里，来来回回很远，没办法，还好房间够大，我们在这里铺设了新场地，我的两个学弟，我实验室哥们，我们队，一共四个队在403调车车，除了偏，其他都还好，一伙人咋咋唬唬的在一起调车，蛮好玩的，时不时来把三国杀哈哈哈。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/06/30/17197486683390.jpg" alt="403场地调车"></p>
<h2 id="郑州省赛"><a href="#郑州省赛" class="headerlink" title="郑州省赛"></a>郑州省赛</h2><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/06/30/17197487085896.jpg" alt="biubiu大队出发合影"><br>搁郑州华北水利水电大学省赛，首先省赛没有围栏（我省赛前几天改了），省赛灯光很差，主办老师很凶🥹，没有什么调试时间，交车之后就去玩三国杀了。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/01/17197637859985.jpg" alt="省赛物流搬运大队"><br>比赛分初赛和决赛，河南省整体实力不高的，有不少双胞胎，三胞胎，中原工学院的很厉害，第一是他们，我们队初赛好像是第五，决赛第八，比赛过程中机械臂把舵机电源和通信线压到了，导致机械臂会在执行几个动作的时候寄掉。这里也算是个经验吧，做东西线材一定要规范，出现问题一定要仔细检查，就咱写的那点代码，不会有啥玄学事件的，大多都是硬件问题。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/01/17197644093429.jpg" alt="省赛合影"><br>最后喜提省一谢幕。</p>
<h2 id="313调车"><a href="#313调车" class="headerlink" title="313调车"></a>313调车</h2><p>赛后反思，反思了个毛蛋，搞了大半年，累都累死了，给学弟们交代了些事，准备把团队交给他们，后面去做别的比赛，我去玩板子嘿嘿。<br>然后反转来了，河南省名额比去年多，七八个，我们队刚好压着最后一名进国赛了；当时正在上课，老师给我打电话，心情激荡。<br>给我的队友通知了一圈，结果学弟不愿意打了，可能是对省赛结果不满意吧，付出与回报不成正比，不愿意再做技术类竞赛了，我只好拉了我哥们进队。<br>通知下来后，距离国赛还有一个月，幸好没拆车哈哈哈。老师给我们提供了新的场地，搬到了创院313，学校也开始提供资金，购买材料，开启了新的调车之旅。<br>我们更换了新的舵机，新的机械臂结构，添加了电源板，按键板，补光灯，并且重构了机械臂执行思路，做了机械臂正逆运动解算，对控制逻辑代码做了整合，本来想更换电机的，奈何第一次买的电机有问题，商家扯皮，而且我电路板用的TB6612电流不够新电机满功率，时间不多了，不敢上，害。<br>调了，一个多月吧，课啥的基本又都没上，这里再次批评，最后效果还不错，比省赛好了太多了，但还是比不过群里的大佬。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/01/17197656626544.jpg" alt="最终成品"></p>
<h2 id="长春国赛"><a href="#长春国赛" class="headerlink" title="长春国赛"></a>长春国赛</h2><p>先吐槽，学校规定不准给学生报销飞机票，明确规定，不论飞机票便宜与否，都不准给学生报销机票；于是我们队去的时候坐了6，7个小时的高铁，比飞机贵了一倍吧大概，回来的时候坐的接近20个小时硬卧，无语。<br>国赛很精彩，大佬很多，过程很刺激，结局也还不错，初赛二三十名吧大概，决赛第五，摄像头数据的延时处理没做好，扫描有些问题，时间太紧张了，很极限了；结局蛮好的。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/01/17197660798456.jpg" alt="biubiu小队合影"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这比赛的这个项目蛮有意思的，也没人在比赛中做到满分，甚至决赛的时候，能跑完第一圈的就是前十，第一圈得分越高，排名越前，没人跑完。<br>我做这个比赛，感觉，过程颠沛流离，结局也还可以，学到了很多东西，见到了很多大佬，特别在此做个总结，办法总比困难多，这件事难，大家都难，个人的努力和团队的实力，是可以主导结局的走向，运气会影响一部分，但当机会到来时，只有有准备有实力的人才能抓得住。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/01/17198356504015.jpg" alt="对不起徐总，我还是把这张图贴上去了，太符合我们当时的心态了">                              </p>
<h2 id="国赛初赛视频链接"><a href="#国赛初赛视频链接" class="headerlink" title="国赛初赛视频链接"></a>国赛初赛视频链接</h2><p><a href="https://www.bilibili.com/video/BV1Wj411s7hJ/?share_source=copy_web&amp;vd_source=58144939e34acbbb38e3f36c750e8498">点击这里跳转bilibili</a></p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&amp;aid=452124160&amp;bvid=BV1Wj411s7hJ&amp;cid=1361902160&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>工创赛总结与改进</title>
    <url>/2024/07/15/gong-chuang-sai-zong-jie-yu-gai-jin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="工创赛总结与改进"><a href="#工创赛总结与改进" class="headerlink" title="工创赛总结与改进"></a>工创赛总结与改进</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>记录一下我们biubiu小队参加2023年中国大学生工程实践与创新能力大赛“智能+物流搬运”赛项的过程，然后对比赛中发生的问题做个记录和总结，并传递一下我们对这个赛项的经验与坑，主要包括：</p>
<blockquote>
<p><a href="https://sparkle-now.cn/2024/07/20/gong-chuang-sai-zong-jie-yu-gai-jin-li-cheng-fen-xiang">历程分享——我们的参赛经历，过程艰辛，跌宕起伏，几经反转；</a></p>
</blockquote>
<blockquote>
<p><a href="https://sparkle-now.cn/2024/07/20/gong-chuang-sai-zong-jie-yu-gai-jin-bi-sai-jie-du/">比赛解读——主要讲一下我们对这个规则的理解；</a></p>
</blockquote>
<blockquote>
<p><a href="https://sparkle-now.cn/2024/07/20/gong-chuang-sai-zong-jie-yu-gai-jin-xuan-xing-jian-yi/">选型经验——主要讲做比赛选元件，用东西的坑和经验</a></p>
</blockquote>
<blockquote>
<p><a href="https://sparkle-now.cn/2024/07/20/gong-chuang-sai-zong-jie-yu-gai-jin-fang-an-fen-xiang/">方案建议——主要说我们队的方案和改进，供大家参考；</a></p>
</blockquote>
<blockquote>
<p>队长经验——作为队长，讲一下比赛中团队管理，项目进展推进，人员管理之类的；</p>
</blockquote>
<blockquote>
<p>电控总结——分享一下比赛中电控选手的注意事项；</p>
</blockquote>
<blockquote>
<p>结构总结——分享一下比赛中负责机械部分的内容；</p>
</blockquote>
<blockquote>
<p>硬件总结——分享一下比赛中电路板设计的注意事项；</p>
</blockquote>
<blockquote>
<p>视觉总结——分享一下物料识别，色环识别，以及补光；</p>
</blockquote>
<blockquote>
<p>决赛分享——决赛就是团队实力的绝对体现；</p>
</blockquote>
<blockquote>
<p><a href="https://github.com/augetyz/Logistics-handling-robot">项目所有文件全开源</a></p>
</blockquote>
<h2 id="国赛初赛视频分享"><a href="#国赛初赛视频分享" class="headerlink" title="国赛初赛视频分享"></a>国赛初赛视频分享</h2><p><a href="https://www.bilibili.com/video/BV1Wj411s7hJ/?share_source=copy_web&amp;vd_source=58144939e34acbbb38e3f36c750e8498">工创赛国赛初赛视频bilibili</a></p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&amp;aid=452124160&amp;bvid=BV1Wj411s7hJ&amp;cid=1361902160&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>工创赛总结与改进-选型建议</title>
    <url>/2024/07/20/gong-chuang-sai-zong-jie-yu-gai-jin-xuan-xing-jian-yi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>@:</p>
<h1 id="工创赛总结与改进——选型建议"><a href="#工创赛总结与改进——选型建议" class="headerlink" title="工创赛总结与改进——选型建议"></a>工创赛总结与改进——选型建议</h1><h2 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h2><ol>
<li>扫描二维码</li>
<li>平面移动定位</li>
<li>拿取物料</li>
<li>色环定位</li>
<li>放置物料</li>
</ol>
<p>比赛总体只有这么些执行要点，每个部分都需要重视，随着序号顺序其重要性降序！最重要的就是扫二维码和移动以及拿物料，一步步进行，才能得分，根据顺序执行，哪个部分寄掉，后面的环节大概率也要寄。<br>下面对每个环节所需要的主要器件选型做介绍和建议。</p>
<h2 id="扫描二维码方案"><a href="#扫描二维码方案" class="headerlink" title="扫描二维码方案"></a>扫描二维码方案</h2><p><strong>这个环节即是最简单的，也是最重要的，也是绝对不能出问题的！一定要稳定！不能出问题！不能依靠运气，在长春国赛，初赛有不少强队因为这个寄了没进决赛，决赛也有不少队因为无法适应位置修改了的二维码板而寄了，这里扫不到数据，后面所有环节全完蛋！一分都没！</strong></p>
<p>这里我分享两种思路：</p>
<h3 id="1-使用二维码扫描模块直接扫描。"><a href="#1-使用二维码扫描模块直接扫描。" class="headerlink" title="1. 使用二维码扫描模块直接扫描。"></a>1. 使用二维码扫描模块直接扫描。</h3><p>就用这种淘宝几十块钱的二维码模块，以前都是用在超市收银机的，需要用一个串口驱动，这也是我们队国赛的方案。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1703076883875.png" alt="GM65"></p>
<p><strong>优点</strong>：</p>
<ul>
<li>方便</li>
<li>使用简单</li>
<li>只要在合适角度，扫描稳定</li>
<li>数据简单</li>
<li>扫描距离远</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>慢</li>
<li>扫描角度小</li>
<li>需要占用一个串口</li>
<li>必须要停下来扫描，行走扫描不一定能扫的到</li>
</ul>
<blockquote>
<p>我们队用这个，没在二维码上出过问题！（前提是车车要走到二维码板前）走到了，就能扫到，扫到了数据就有，而这个模块自带补光，可以通过指令开启扫描时补光。这里需要注意国赛初赛规则上写了，不准向场外补光，这里我也不知道向二维码板上补光算不算犯规，所以国赛的时候我用#define修改了扫描指令，没加补光，依然稳定。</p>
</blockquote>
<h3 id="2-使用K210或者openmv之类的摄像头模组"><a href="#2-使用K210或者openmv之类的摄像头模组" class="headerlink" title="2.使用K210或者openmv之类的摄像头模组"></a>2.使用K210或者openmv之类的摄像头模组</h3><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1703077103725.png" alt="V831"></p>
<p><strong>优点</strong></p>
<ul>
<li>可编程，可控性强</li>
<li>可视角度大，可以换镜头</li>
<li>识别速度快，可以跑着扫描</li>
<li>可扩展其他功能，不仅用来扫二维码</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>贵</li>
<li>可能会出问题，不稳定</li>
<li>需要自己写代码</li>
<li>其实没啥缺点</li>
</ul>
<blockquote>
<p>我们队三四月份的时候用的就是V831，有一说一，快！稳定性还行，但我听群里说有人国赛扫描摄像头的时候因为国赛场馆灯光问题，扫不到二维码，我的评价是，哥们没加补光以及代码没调太好可能是，二维码这玩意库那么多，我觉得应该蛮好操作的。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用啥都行，只要会用。我们队采用的是GM65-二维码扫描模块，稳定，容易更换，排错误，出问题，基本不会去查看该模块的问题。唯一的地方就是，在二维码识别那里，比别的队慢2s，因为我们车车需要停下来扫描。我建议，如果没有别的需求，还是采用GM65就行，如果对自己实力比较有信心，代码稳定，图快的话，可以采用V831或者树莓派。</p>
<blockquote>
<p>补充，可以看一下下面两个场地的区别，如果是使用了机械臂上的摄像头功能复用扫描二维码（有的是两个摄像头），需要专门设计一个动作执行二维码扫描，而在决赛的时候，二维码位置变换，在另一侧：我们队是直接把GM65模块（双面胶粘的）拔下来，放在车车的另一侧，保证车车总体运行方向不变；如果用机械臂的话，要么重新设计一个动作，要么修改车车运行方向，决赛发布规则到准备时间结束一共只有五个小时，要对自己的能力有正确的认识。</p>
</blockquote>
<h2 id="平面移动方案"><a href="#平面移动方案" class="headerlink" title="平面移动方案"></a>平面移动方案</h2><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1703077532860.png" alt="初赛场地"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1703077562386.png" alt="决赛场地"></p>
<p>两个场地的运动方向是相反的，具体可以看规则————即在决赛需要在五个小时内写一套新的定位移动代码；</p>
<p>比赛场地是分很多个区域的，如果不能准确到达每个区域，就不能得分，甚至会因为碰到黄色区域导致比赛提前结束。</p>
<p>所以，在这个比赛中，电控选手最重要的任务之一就是平面移动和精确定位，车车跑得快，车车跑的准，才能算好。这里我们团队采用的思路是，底盘运动控制粗略定位，视觉识别精确定位。</p>
<p>这里主要分享底盘运动控制粗略定位的电机选型，轮子选型以及视觉识别精确定位的摄像头，板子选型。</p>
<h3 id="底盘运动控制粗略定位"><a href="#底盘运动控制粗略定位" class="headerlink" title="底盘运动控制粗略定位"></a>底盘运动控制粗略定位</h3><p>这里直接使用编码器记录车车行走的距离，配合陀螺仪，实现定向定距离移动，考虑到场地打滑，机械结构误差，编码器误差累计等多种影响因素，这种方法会在多次移动、刹车、拐弯之后，出现较大误差；在短距离移动中，使用这种定位方式，可以达到1cm的定位精度，在刹车、拐弯、起步大概5-8次之后，会出现较大误差，不能保证重复定位精度，所以单纯依靠这种方法是行不通的，需要配合视觉定位实现精确定位和累计误差消除。</p>
<h4 id="底盘电机"><a href="#底盘电机" class="headerlink" title="底盘电机"></a>底盘电机</h4><p>底盘电机有多种选择</p>
<ul>
<li>直流有刷电机</li>
<li>直流步进电机</li>
<li>无刷伺服电机</li>
</ul>
<p>我们队采用的方案是：直流有刷电机+齿轮减速器+光电型编码器</p>
<p>看到国赛场上好多队采用的都是：步进电机+磁编码器+FOC闭环控制器</p>
<p>也有用无刷电机的。</p>
<p>各个选择的个人看法：</p>
<h5 id="直流有刷电机"><a href="#直流有刷电机" class="headerlink" title="直流有刷电机"></a>直流有刷电机</h5><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1703079260948.png" alt="直流光电编码器有刷减速电机"><br><strong>优点</strong></p>
<ul>
<li>便宜</li>
<li>控制简单</li>
<li>容易更换</li>
<li>刚入门学习用的多</li>
<li>上手快</li>
<li>配合高精度光电编码器，定位精度还行</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>精度不够，空程大</li>
<li>建议采用行星减速器</li>
<li>采用的是电压控制速度，在低速情况下，不能稳定控制扭矩，导致扭矩不够，精度低</li>
</ul>
<p> 我们队用这种电机全然因为是代码更迭下来一直用的是这种电机，代码不好改，或者说是懒，后面用了别的方法来弥补这种电机导致的精度不够，强烈建议使用行星减速器，但最好不要用直流有刷电机，因为这个电机有个致命问题，这个电机是采用降低电压也就是减低功率来减低转速的，在需要低速的情况下，电机扭矩会不够，导致运行不稳定！非常坑！</p>
<h5 id="步进电机"><a href="#步进电机" class="headerlink" title="步进电机"></a>步进电机</h5><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1703079305093.png" alt="步进电机+闭环驱动器"><br><strong>优点</strong></p>
<ul>
<li>便宜</li>
<li>控制简单</li>
<li>进度高</li>
<li>高速也还行，能跑的蛮快的</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>高速状态下会丢步</li>
<li>比较重</li>
<li>别的也没啥</li>
</ul>
<p>相当建议采用步进电机，然后配合张大头的步进电机闭环驱动器，可以实现简单控制，稳定控制，精确控制。国赛上好多人用这个方案，连PID都不用写了。<br>这里需要提到一个点，就是步进电机在使用时，功率是恒定的，高速和低速情况下，功率都差不多，可以解决有刷电机的低速下扭矩不够的问题，但步进电机在高速下可能会丢步，所以需要采用磁编码器来实现闭环。一般买的闭环驱动器上都会有磁编码器，和电流闭环。所以用步进电机就会很简单，实际操作起来效果也会很好。</p>
<h5 id="无刷电机"><a href="#无刷电机" class="headerlink" title="无刷电机"></a>无刷电机</h5><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1703079360075.png" alt="随便找的，能用在车车上的大概300块能解决"><br><strong>优点</strong></p>
<ul>
<li>稳定</li>
<li>准</li>
<li>速度快</li>
<li>劲大</li>
<li>好用<br><strong>缺点</strong></li>
<li>贵</li>
<li>对嵌入式电控选手要求有点高，得会用</li>
<li>如果直接上了伺服电机（驱动一体的那种）上一个选项可以忽略</li>
</ul>
<p>建议采用无刷电机，真的好用，刹车快，起步快，配合FOC驱动器，嘎嘎好用，换向丝滑，学会使用了连机械臂也解决了。而且这玩意还准！</p>
<p>唯一的问题就是贵，一个电机大概499，好一点的随便上千，有钱的真的可以试试。</p>
<h4 id="麦克纳姆轮"><a href="#麦克纳姆轮" class="headerlink" title="麦克纳姆轮"></a>麦克纳姆轮</h4><p>这个比赛车车好像用的都是麦克纳姆轮，说实话，如果机械臂自由度足够的话，车车应该是不需要转向的，一个方向走完全场，控制起来也舒服。当然，这里主要是总结下轮子的选择。<br>国赛的时候，有不少队反映场地打滑，导致自己成绩不好：我觉得吧，工程赛题，尽管看起来就像个小游戏，但实际工程上场地环境各种情况都有，打滑都是小问题，设计产品和设备的时候就要充分考虑这些情况，国赛主办方也提供了场地图纸，大家也都在实验室测试过的，基本摩擦系数应该是差不多的。国赛场地和我们队的测试场地差异就在国赛的场地是体育馆改的，有几个地图可能不是特别平，稍微有些颠簸。车车上加个悬挂系统就基本解决很多问题，再写一些算法检测打滑和偏向纠正，基本就能解决问题；题外话，这仅仅只是个不到6平米的小场地，如果放到实际物流仓储仓库做自动搬运机器人，那环境岂不是更加复杂。</p>
<p>麦轮的选择上：</p>
<blockquote>
<p>首先是结实，承重要好，车车越重，摩擦力越大，越不易打滑，当然重量要合适，不然太重就跑不动啦；</p>
</blockquote>
<blockquote>
<p>轮径要大一些，在不超高的情况下，轮径越大跑的越快，都知道移动速度=电机转速*轮子周长。当然电机功率是一定的，轮子直径大了，力臂会长，扭矩不够的电机可能带不起来。但基本上咱这个赛题上，用42步进电机功率都能带动。</p>
</blockquote>
<p>仔细看我们车车视频能看到，我们初赛没跑完，最后一个码垛没码完时间就结束了，总结就是跑的比较慢：50减速比的直流有刷电机+天府之土70mm轮子跑的还是太慢了</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>有钱的就整无刷电机，没钱的就整步进电机，嫌自己事情少的，就整有刷电机。车轮上建议用天府之土轮子或者轮径大一些的，我看到几个队跑的飞快，轮子直径大概是100mm，建议可以搜一下，只要扭矩足够，精度足够，越快越好。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/01/17198154451502.jpg" alt="左边的是刚搜的，右边是我们用的"></p>
<h3 id="视觉识别控制精确定位"><a href="#视觉识别控制精确定位" class="headerlink" title="视觉识别控制精确定位"></a>视觉识别控制精确定位</h3><p>我们国赛用的是旭日派x3+USB摄像头+opencv识别圆环，视觉队友阿伟组队前跟我一样是玩stm32的，跟我一起后现学的机械视觉，总结就是，从省赛到国赛，视觉没出过问题，稳得一批。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/01/17198158391246.jpg" alt="视觉识别和机械臂都准结果才能准"></p>
<p>具体视觉代码分享在后续文章，这里只谈元件使用。</p>
<p><strong>用板载计算机还是嵌入式视觉</strong><br>板载计算机就是 NUC，树莓派，香橙派一类的能够跑机械视觉，神经网络的Linux计算机，我建议用一个你会用的，速度快一点的，资料多的，Linux板子；例如：树莓派5，香橙派的RK3588，ROCK5系列的板子，这些SOC性能都足够了，便宜点的也够用，方便调试，移植代码的就行。</p>
<p>嵌入式视觉，openmv，K210之类的，都不推荐；K210识别二维码还可以，队里资金紧张的话，用到省赛也没问题，在河南省用K210到国赛也问题不大，稍微累点，后面到国赛的话麻烦些换个方案就行；openmv就更不推荐了，这价格，疫情涨价就算了，疫情之后，H7芯片的价格都这样了，还卖五六百😆，性价比太低。也别想着这玩意开源代码多，看看420元的树莓派5和499元的RK3588s吧。</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>用RK3588或者树莓派5就OK的，配一个100块的USB摄像头就能识别OK了。</p>
<p>树莓派5+USB摄像头和起来也就520块。😆😆😆😆😆</p>
<h2 id="物料拿取和放置"><a href="#物料拿取和放置" class="headerlink" title="物料拿取和放置"></a>物料拿取和放置</h2><p>对物料的拿取和放置，主要依赖机械臂的设计。多自由度的机械臂拿取就更灵活，但控制会比较难；自由度低的机械臂设计，控制起来简单高效，但题目更换后，不好适应，而且上限摆在那了。</p>
<p>今年看到好多升降式的机械臂，很准，但我们队没用，原因是觉得自由度不高，针对性很强，一旦更换题目，就没招了，而且，运作模式固定了。</p>
<p>我们队采用了连杆式机械臂，类似下图这种，驱动电机用的是fashionstar的磁编码器无刷舵机，三百块一个</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1703080225272.png" alt="连杆式"></p>
<p>@:<br>省赛的时候是这种，舵机用的就是图中这款，100块一个。<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/01/17198315585735.jpg" alt="一节接着一节式"></p>
<p>省赛的时候用的是数组存储动作，在特定位置实行规定动作就行了，一个是机械精度问题，一个是定位精度问题，最低三环（运气好一环二环），如果没出幺蛾子的话，稳定120分，时间不限制的情况哈哈哈哈。</p>
<p>国赛用了机械臂逆运动学解算，还是粗略走过去，视觉精确定位，这个时候用动作组的车队会执行动作组进行放置，仍然会有误差，不会特别准。我们这个时候用摄像头识别色环中心位置，并线性变化到机械臂的坐标系，转化为空间XYZ坐标，再逆运动解算为电机角度，拿取物料，执行放置；我们的机械臂自由度低，有唯一解，我是直接拿着平板和游标卡尺算的，不是特别严谨，一堆三角函数，但效果很好，计算直接在单片机里算的，国赛一共放置了9次色环，印象里是六个一环，三个二环。</p>
<p>这里简单说一下，电机的话，用舵机或者步进电机或者无刷电机都行，一定要精准的，一般都贵，推荐上步进电机，步进电机真的很准很准，用张大头的闭环控制器，一个关节90块能搞定，车车底盘也可以用这个方案。</p>
<p>所以这里主要的来自机械结构误差，选择什么样的结构很影响准确性和控制方案，我的建议是按照我国赛的那种结构设计机械臂。最后再贴一张来自工创赛赞助商为决赛题目做的demo截图，决赛没人拿满分，而且可能连一半分都没人能拿完，毕竟时间太紧了，赛后官方发了个视频，他们做了一版，也是连杆式机械臂，四自由度，视觉识别可能是K210之类的，有个小屏幕，没有做逆运动解算应该，用中心的色环定位后直接放的。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/01/17198327088061.png" alt="国赛官方范例"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/2024/07/01/17198329643136.jpg" alt="感觉他这个视频是不是剪辑了哈哈"></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>3D打印材料</strong><br>最好都用一种颜色，不然花里胡哨的跟我省赛一样，会很丑，建议全黑色或者全白色，也见识过好多个彩色车车，可惜我不会设计。<br><strong>线材</strong><br>最好都用硅胶线，整理线材方便。<br><strong>悬挂</strong><br>整个摆式悬挂就够了，车身太重，刚度不够的，可以用铝板做地板，注意绝缘。<br><strong>摄像头</strong><br>USB摄像头，1080P，150广角，500万像素。我用的是。<br>配置可以低点，用不到这么高，广角也不需要那么高。<br><strong>电池</strong><br>2023年要求电压不超过12v，建议整3S锂电池，大容量，平时超过12v没事，比赛的时候带个放电器以防万一。<br><strong>烧录器</strong><br>！！！！很重要！！！不要用无线烧录器！！赛场上人多，好多家伙都用无线烧录器，比赛的时候会烧录不进去的，建议整有线的，平时调试用无线的可以，不用整正点原子那个，我看立创有个佬开源了一款esp32做的，速度跟有线的差不多，淘宝开卖了，一个39，两个才80，当个都可以当有线的用。<br><strong>imu</strong><br>我们队用的是维特的单轴陀螺仪，学校批钱买的，用着还行吧，二三百一个，跟之前用超核电子的HI229效果差不太多；这里没啥推荐的，用成品模块也好，自己写滤波也好，只要稳定就OK的，我推荐的话，维特一般的陀螺仪就OK的，几十块就OK。有钱整那啥啥单轴水晶陀螺仪也可以。<br><strong>爪子</strong><br>建议学一下用TPU做爪子，决赛那个物料，一般爪子抓不住，我们队学弟设计的TPU爪子还没阿伟兄弟硬，根本抓不了，我们灵光一闪，用的两块亚克力错齿叠放做的爪子，舵机加大力矩的话，能抓住，比较稳。<br><strong>工具</strong><br>带齐全，方便的话，建议带副麻将或者纸牌，最好带件法器，赛场蛮紧张的，我看决赛入场的时候，好多队都在敲木鱼，我们队没有真家伙，整了个电子木鱼。<br><strong>女孩子</strong><br>队里要有个女孩子，最好是那种能力强还很温柔漂亮的，可以一边摆一边赢，我看好几个队都是女孩子写代码，调车，男的在一旁看着，好羡慕🥹🥹</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>这里仅仅是推荐选型，看完之后方案基本定了差不多了，确定控制思路后，机械已经可以开始设计了；具体控制思路呀，结构设计呀，运动规划呀，视觉方案呀，硬件方案呀，我这里会放到后面一块块的分享，保证咱学弟学妹们少走弯路，不走弯路，并且很多地方我没做过，会跟大家讲清楚，对这些大家可以自由思考自由创新。阅读学长的比赛记录帖子，不是让你照着学长的做，而是告诉你，哪些方案在哪些情况下会有大问题，是告诉你坑在哪，你不要再跳了，我的车车上坑那么多，你照着我这玩意做，指不定有多难受。我只希望，下一届国赛决赛上，咱实验室里能够更创佳绩，不要连决赛1/4分都拿不到，那真的是太捞了，我就是捞货一枚。很多地方可以创新，后面会一一给大家分享，希望大家能够勇夺高分，biubiu强。</p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>开源项目链接记录</title>
    <url>/2024/07/20/kai-yuan-lian-jie-ji-lu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="开源学习链接记录"><a href="#开源学习链接记录" class="headerlink" title="开源学习链接记录"></a>开源学习链接记录</h1><h2 id="QueueForMcu"><a href="#QueueForMcu" class="headerlink" title="QueueForMcu"></a>QueueForMcu</h2><p><a href="https://github.com/xiaoxinpro/QueueForMcu">项目地址</a></p>
<p>基于单片机实现的队列功能模块，主要用于8位、16位、32位非运行RTOS的单片机应用，兼容大多数单片机平台。</p>
<ul>
<li>动态创建队列对象</li>
<li>动态设置队列数据缓冲区</li>
<li>静态指定队列元素数据长度</li>
<li>采用值传递的方式保存队列数据</li>
</ul>
<h2 id="Cpost"><a href="#Cpost" class="headerlink" title="Cpost"></a>Cpost</h2><p>Cpost是一个c语言编写的，用于c语言程序上下文切换和解耦的工具</p>
<blockquote>
<p>cpost包含cpost和cevent两个工具，cpost用于c语言的上下文切换，cevent用于程序模块之间的解耦</p>
</blockquote>
<blockquote>
<p>cpost借鉴了Android的Handler机制，在c语言环境中，可以通过调用cpost接口，将函数抛出到另外的线程(上下文)中运行，对于某些场景，尤其是嵌入式编程无操作系统环境下的中断延迟处理</p>
</blockquote>
<blockquote>
<p>cevent借鉴了Android的广播机制，在c语言环境中，当程序运行至相应的位置，可以通过cevent接口抛出一个事件，其他模块可以通过注册的方式，监听这个事件，当事件发生时，调用注册的函数，能很大程度上实现模块间的解耦</p>
</blockquote>
<p><a href="https://github.com/NevermindZZT/cpost">cpost 项目地址</a></p>
<h2 id="mOTA-v2-0"><a href="#mOTA-v2-0" class="headerlink" title="mOTA v2.0"></a>mOTA v2.0</h2><p>本开源工程是一款专为 32 位 MCU 开发的 OTA 组件，组件包含了 <a href="https://gitee.com/DinoHaw/mOTA/tree/master/source"><strong>bootloader</strong></a> <strong>、固件打包器</strong> <strong>(</strong><a href="https://gitee.com/DinoHaw/firmware_packager"><strong>Firmware_Packager</strong></a><strong>)</strong> <strong>、固件发送器</strong> 三部分。</p>
<p><a href="https://gitee.com/DinoHaw/mOTA">(Dino)/mOTA 项目地址</a></p>
<p> mOTA 中的 m 可意为 mini, micro, MCU (Microcontroller Unit)，而 OTA (Over-the-Air Technology)，即空中下载技术，根据<a href="https://gitee.com/link?target=https://zh.m.wikipedia.org/wiki/%25E7%25A9%25BA%25E4%25B8%25AD%25E7%25BC%2596%25E7%25A8%258B">维基百科</a>的定义， OTA 是一种为设备分发新软件、配置，乃至更新加密密钥（为例如移动电话、数字视频转换盒或安全语音通信设备——加密的双向无线电）的方法。 OTA 的一项重要特征是，一个中心位置可以向所有用户发送更新，其不能拒绝、破坏或改变该更新，并且该更新为立即应用到频道上的每个人。用户有可能“拒绝” OTA 更新，但频道管理者也可以将其踢出频道。由此可得出 OTA 技术几个主要的特性：</p>
<ol>
<li>一个中心可向多个设备分发更新资料（固件）；</li>
<li>更新资料一旦发送便不可被更改；</li>
<li>设备可以拒绝更新；</li>
<li>中心可以排除指定的设备，使其不会接收到更新资料。</li>
</ol>
<p>本工程仅实现 OTA 更新资料的部分技术，即上文列出的 OTA 技术几个主要的特性，而不关心中心分发资料中间采用何种传输技术。</p>
<h2 id="SFUD-Serial-Flash-Universal-Driver-串行-Flash-通用驱动库"><a href="#SFUD-Serial-Flash-Universal-Driver-串行-Flash-通用驱动库" class="headerlink" title="SFUD (Serial Flash Universal Driver) 串行 Flash 通用驱动库"></a>SFUD (Serial Flash Universal Driver) 串行 Flash 通用驱动库</h2><p>SFUD是一款开源的串行 SPI Flash 通用驱动库。由于现有市面的串行 Flash 种类居多，各个 Flash 的规格及命令存在差异， SFUD 就是为了解决这些 Flash 的差异现状而设计，让我们的产品能够支持不同品牌及规格的 Flash，提高了涉及到 Flash 功能的软件的可重用性及可扩展性，同时也可以规避 Flash 缺货或停产给产品所带来的风险。</p>
<blockquote>
<p>主要特点：支持 SPI/QSPI 接口、面向对象（同时支持多个 Flash 对象）、可灵活裁剪、扩展性强、支持 4 字节地址</p>
</blockquote>
<blockquote>
<p>资源占用<br>标准占用：RAM:0.2KB ROM:5.5KB<br>最小占用：RAM:0.1KB ROM:3.6KB</p>
</blockquote>
<blockquote>
<p>设计思路：<br><strong>什么是 SFDP</strong> ：它是JEDEC （固态技术协会）制定的串行 Flash 功能的参数表标准，最新版 V1.6B。该标准规定了，每个 Flash 中会存在一个参数表，该表中会存放 Flash 容量、写粒度、擦除命令、地址模式等 Flash 规格参数。目前，除了部分厂家旧款 Flash 型号会不支持该标准，其他绝大多数新出厂的 Flash 均已支持 SFDP 标准。所以该库在初始化时会优先读取 SFDP 表参数。</p>
</blockquote>
<blockquote>
<p><strong>不支持 SFDP 怎么办</strong> ：如果该 Flash 不支持 SFDP 标准，SFUD 会查询配置文件中提供的 <strong>Flash 参数信息表</strong> 中是否支持该款 Flash。如果不支持，则可以在配置文件中添加该款 Flash 的参数信息。获取到了 Flash 的规格参数后，就可以实现对 Flash 的全部操作。</p>
</blockquote>
<p><a href="https://github.com/armink/SFUD">SFUD项目地址</a></p>
<h2 id="Hope-board"><a href="#Hope-board" class="headerlink" title="Hope board"></a>Hope board</h2><p><a href="https://github.com/clientttt/HOPE--GUI/tree/main">HOPE–GUI 项目地址</a></p>
<p>一款基于stm32f401的开发版，带有屏幕，蓝牙，rgb，USB等功能，屏幕UI蛮好看的，主要学习其菜单系统的实现。板子小小的，很可爱。</p>
<h2 id="轮腿机器人开源控制算法"><a href="#轮腿机器人开源控制算法" class="headerlink" title="轮腿机器人开源控制算法"></a>轮腿机器人开源控制算法</h2><p>深圳科技大学 杨松坪 20级 参加robomaster负责平衡步兵机器人，写的开源控制代码</p>
<p><a href="https://github.com/ysp-021228/wheel_leg_chassis_public">wheel_leg_chassis_public 项目地址</a></p>
<h2 id="Qt开源项目demo和教程"><a href="#Qt开源项目demo和教程" class="headerlink" title="Qt开源项目demo和教程"></a>Qt开源项目demo和教程</h2><p><a href="https://gitee.com/feiyangqingyun">飞扬青云 项目地址</a></p>
<p>这哥们写了不少，全开源了，赞👍</p>
<h2 id="wokwi仿真平台"><a href="#wokwi仿真平台" class="headerlink" title="wokwi仿真平台"></a>wokwi仿真平台</h2><p>在线仿真平台，主要是Arduino环境，可以在网页，vs code，clion上运行。</p>
<p><a href="https://wokwi.com/">Wokwi - Online ESP32, STM32, Arduino Simulator</a></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32编码器速度采集</title>
    <url>/2023/10/01/dian-ji-bian-ma-qi-ce-su/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="电机编码器测速"><a href="#电机编码器测速" class="headerlink" title="电机编码器测速"></a>电机编码器测速</h1><h2 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h2><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923381345.png" alt="效果图"></p>
<h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h3><p>电机转动时，测出电机的实时转速，进而对电机进行控制。</p>
<h3 id="2-简介"><a href="#2-简介" class="headerlink" title="2.简介"></a>2.简介</h3><p>以光电式增量编码器为例：</p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>•Encoder Interface 编码器接口</p>
<p>•编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度</p>
<p>•每个高级定时器和通用定时器都拥有1个编码器接口</p>
<p>•两个输入引脚借用了输入捕获的通道1和通道2</p>
<p>图片中有一个圆盘，右边是个小红外灯（发光元件），一直照向左边的光敏元件。这个圆盘上有一圈齿，光线正好可以透过小齿的空隙照到光敏元件，随着圆盘 的转动，小齿转走了，又马上挡住光，紧接着下一个小齿…     按照上面的说法，圆盘一直转，光敏元件就能得到一个如下图 A 相那样的波， 通过统计波形所有高电平的数量我们就能算出来这个盘一共转了多少刻度。并 且 也 能 推 算 出 盘 转 到 了 什 么 位 置 。 并且，通过实时计算波的频率，我们就可以测速了。 但是这样有个问题，不知道盘转的方向，正转反转都是这样一个波。 解决方法就是在小齿的内圈再刻上一圈与外圈错开 90°的小齿！就可以得到下 图 B 相的波形，这样就可分辨方向了。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923393976.png" alt="image"></p>
<p>A 和 B 两组脉冲相位差 90º，可以判断出旋转方向和旋转速度。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923403055.png" alt="image"></p>
<p>通过观察上面 AB 相的波我们发现，圆盘向某个方向一直旋转，AB 两相就是这四个状态周而复始。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923410954.png" alt="image"></p>
<p>其次我们看一下编码器的线数：</p>
<p>我们使用的电机后面带的霍尔编码器就是 13ppr，也就是 13 线。也就是电机每转一圈 A 或 B 相的脉冲数。 也就是电机转一圈 A 相和 B 相就分别有 13 个脉冲。</p>
<ul>
<li>GMR编码器  500ppr</li>
<li>霍尔编码器   13ppr</li>
</ul>
<p>如果我们购买的电机为减速电机的话，那么他会有一个减速比；</p>
<p>一圈脉冲总数=13*减速比（减速比：电机输出转速/电机输入转速）</p>
<p>例：减速比为1：50，则一圈脉冲总数=13*50=650。</p>
<p>通过上述分析，用 STM32 的正交解码库函数就能搞定编码器。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923418590.png" alt="image"></p>
<p>TIM_EncoderMode_TI1 代表仅 TI1 计数；</p>
<p> TIM_EncoderMode_TI2 代表仅 TI2 计数； </p>
<p>TIM_EncoderMode_TI12 代表 TI1 TI2 都计数。</p>
<p> TI1 就是输入通道 1，就是编码器 A 相，TI2 同理。</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923425986.png" alt="image"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923432204.png" alt="image"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923439695.png" alt="image"></p>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>流程图：</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/markdown_img/1696923448216.png" alt="image"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Encoder_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//开启时钟</span>
	<span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_TIM3<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//TIM3  CH1、CH2</span>
	GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>
	GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IPU<span class="token punctuation">;</span>
	GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_6 <span class="token operator">|</span> GPIO_Pin_7<span class="token punctuation">;</span>
	GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>
	<span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//定时器配置</span>
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure<span class="token punctuation">;</span>
	TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_ClockDivision <span class="token operator">=</span> TIM_CKD_DIV1<span class="token punctuation">;</span>
	TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_CounterMode <span class="token operator">=</span> TIM_CounterMode_Up<span class="token punctuation">;</span>
	TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> <span class="token number">65536</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>		<span class="token comment">//ARR</span>
	TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>		<span class="token comment">//PSC</span>
	TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_RepetitionCounter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_TimeBaseInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//输入捕获</span>
	TIM_ICInitTypeDef TIM_ICInitStructure<span class="token punctuation">;</span>
	<span class="token function">TIM_ICStructInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//给结构体附上初值</span>
	TIM_ICInitStructure<span class="token punctuation">.</span>TIM_Channel <span class="token operator">=</span> TIM_Channel_1<span class="token punctuation">;</span>   <span class="token comment">//通道一</span>
	TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICFilter <span class="token operator">=</span> <span class="token number">0xF</span><span class="token punctuation">;</span>    <span class="token comment">//滤波抗噪音（0-0xf值越大效果越好）</span>
	<span class="token function">TIM_ICInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//写入结构体</span>
	TIM_ICInitStructure<span class="token punctuation">.</span>TIM_Channel <span class="token operator">=</span> TIM_Channel_2<span class="token punctuation">;</span>
	TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICFilter <span class="token operator">=</span> <span class="token number">0xF</span><span class="token punctuation">;</span>
	<span class="token function">TIM_ICInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">TIM_EncoderInterfaceConfig</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span>TIM_EncoderMode_TI12<span class="token punctuation">,</span> TIM_ICPolarity_Rising<span class="token punctuation">,</span> TIM_ICPolarity_Rising<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//TI12极性配置</span>
	
	<span class="token function">TIM_Cmd</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//得到CNT当前值</span>
<span class="token class-name">int16_t</span> <span class="token function">Encoder_Get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token class-name">int16_t</span> Temp<span class="token punctuation">;</span>
	Temp <span class="token operator">=</span> <span class="token function">TIM_GetCounter</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">TIM_SetCounter</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> Temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">//main</span>

<span class="token class-name">int16_t</span> Speed<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">OLED_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Timer_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Encoder_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">OLED_ShowString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Speed:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">OLED_ShowSignedNum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> Speed<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//TIM定时器可以有效给speed赋值，有两种选择：1.进中断次数多不溢出，且速度延迟低（当前）   2.溢出</span>
<span class="token keyword">void</span> <span class="token function">TIM2_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TIM_GetITStatus</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> TIM_IT_Update<span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		Speed <span class="token operator">=</span> <span class="token function">Encoder_Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">TIM_ClearITPendingBit</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> TIM_IT_Update<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样就可以对电机进行速度测量了。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>直流电机</tag>
        <tag>编码器</tag>
      </tags>
  </entry>
  <entry>
    <title>科学上网简单教程</title>
    <url>/2024/07/12/ke-xue-shang-wang-jian-dan-jiao-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="科学上网教程"><a href="#科学上网教程" class="headerlink" title="科学上网教程"></a>科学上网教程</h1><blockquote>
<p>科学上网：大陆建设有外网屏蔽，保护本国舆论与网络安全，但很多资料尤其是科研资料与学习资料需要参考国外优秀内容，所以需要越过大陆屏蔽，科学上网，而且一般大学校园网和公司Wi-Fi对国外部分资料网站都有加速（专线），但对于个人研究来说，掌握科学上网是学习过程中基础的一环。</p>
</blockquote>
<hr>
<h3 id="科学上网原理简介"><a href="#科学上网原理简介" class="headerlink" title="科学上网原理简介"></a>科学上网原理简介</h3><p>科学上网是一种关于翻墙的巧妙称呼，主要是指通过技术手段访问被国内屏蔽的网站和服务。谈到翻墙，肯定少不了提及 GFW 防火长城，下面是维基百科关于防火长城的介绍。</p>
<p>防火长城（英语：Great Firewall，常用简称：GFW），中文也称中国国家防火墙，通常简称为墙、防火墙等，中国国家互联网信息办公室称为数据跨境安全网关 ，是中华人民共和国政府监控和过滤国际互联网出口内容的软硬件系统集合，用于通过技术手段，阻断不符合政府要求的互联网内容传输，由北京邮电大学前校长方滨兴主持设计。方滨兴因此也被网民称之为“中国防火墙之父”。</p>
<p>随着防火长城逐渐为人熟知，“墙”一词有时也被用作动词，“被墙”即指网站内容被防火长城所屏蔽。“翻墙”、“挂梯子”也被引申为突破网络审查浏境外被屏蔽的网站或使用服务的行为。</p>
<p>在国内使用VPN翻墙，显然是一种”落后“的方式了，因为VPN协议十分容易被识别，阻断和干扰都是常态。即使是 ExpressVPN 这种海外知名大厂，在中国的VPN节点也仅仅有4~5个能用，并且还不稳定。</p>
<p>很多在国内能用的VPN，其本质也并非VPN协议，而是 Shadowsocks 等专用代理协议的套壳，只是有和VPN软件一样的客户端而已。</p>
<p>当前常用的翻墙协议有 Shadowsocks、V2ray（vmess）、Trojan，常见于各类「<a href="https://clashforios.com/">机场</a>」服务，使用VPS自建翻墙节点的使用 Shadowsocks 并不多了，更多的是 vmess、Trojan 以及其他更新兴的协议。</p>
<p>———来自<a href="https://clashforios.com/principles-of-scientific-internet-access">https://clashforios.com/principles-of-scientific-internet-access</a></p>
<h2 id="科学上网步骤"><a href="#科学上网步骤" class="headerlink" title="科学上网步骤"></a>科学上网步骤</h2><h3 id="一、测试"><a href="#一、测试" class="headerlink" title="一、测试"></a>一、测试</h3><p>访问下列网站，没翻墙的情况下应该是访问不了的，翻墙了应该就可以。连校园网或者公司Wi-Fi也可以访问。</p>
<p><a href="https://poe.com/">Just a moment…</a></p>
<p><a href="http://ustic.top/">科创中心</a></p>
<p><a href="https://blog.17lai.site/">夜法之书</a></p>
<h3 id="二、获取加速节点"><a href="#二、获取加速节点" class="headerlink" title="二、获取加速节点"></a>二、获取加速节点</h3><p>访问外网的话，首先需要有一个加速节点。下图是我在iPad上通过小火箭使用我自己购买的宝贝云机场为我提供的加速节点，翻墙时，只需要选择一个速度延时合适的节点，就可以通过客户端实现翻墙，选择哪个节点，那么你的IP地址相应的也会改到哪里。</p>
<p><img src="https://res.craft.do/user/full/acb27c06-6568-c1dc-2fad-17c27c23c9c1/doc/44D2BF19-40AC-4F34-BB57-8769D2C3205B/FA8D4FC2-6604-4432-8A6A-6ABC543CF1A9_2/yCCg7z2VyBB3ei83HdO8TIRrucn9EIFRlMViuzhycHEz/Image.heic" alt="Image"></p>
<p>这里我推荐使用宝贝云的机场，好用不贵。可以看自己需求购买，有的套餐是有效期一个月，流量贼多，有的是流量有限，有效期无限。根据自己情况选择，我是购买的600G流量，大半年了，用的也不是很频繁，消耗不是很大，还剩400多个G。</p>
<p>机场链接：</p>
<p><a href="https://9.234456.xyz/abc.html?t=638156797079021431">XYZ</a></p>
<p><a href="https://bby008.com/#/">宝贝云</a></p>
<h3 id="三、windows下翻墙"><a href="#三、windows下翻墙" class="headerlink" title="三、windows下翻墙"></a>三、windows下翻墙</h3><p>在win下翻墙，这里推荐使用Clash for windows 客户端。好用，简单，方便。</p>
<p><a href="https://clashxhub.com/clash-backup-download/?amp=1">2024最新Clash版本全家桶（包含Windows、Mac、Android）备份下载​ – Clash 官网导航</a></p>
<p><a href="https://clashxhub.com/clash-for-windows/?amp=1">2024最新 Clash for Windows 官网下载及使用教程​​(含备份下载) – Clash 官网导航</a></p>
<p>下载后安装即可。</p>
<p>然后在宝贝云或者别的平台购买节点，导入节点数据。</p>
<p>在宝贝云复制节点订阅地址，然后打开clash for windows，在Profiles选项里添加即可，如下图操作。</p>
<p><img src="https://res.craft.do/user/full/acb27c06-6568-c1dc-2fad-17c27c23c9c1/doc/44D2BF19-40AC-4F34-BB57-8769D2C3205B/585537BD-E0D3-416E-85C8-CF3E3A0DEED3_2/Et24b20y9V6OD7W94599mxxzxhAaPD9OmXHqyhOIraEz/Image.png" alt="Image.png"></p>
<p><img src="https://res.craft.do/user/full/acb27c06-6568-c1dc-2fad-17c27c23c9c1/doc/44D2BF19-40AC-4F34-BB57-8769D2C3205B/FB47EC8E-E1BE-41B3-84E9-BD24BE81514A_2/HWOBIsnWbt1PYoEtxeJ6UVPbycIcgCcyPxZ9n4ymcvcz/Image.jpeg" alt="Image.jpeg"></p>
<p>添加地址后，设置软件全局代理；然后在Proxies选项里选择网速合适的节点即可。</p>
<p><img src="https://res.craft.do/user/full/acb27c06-6568-c1dc-2fad-17c27c23c9c1/doc/44D2BF19-40AC-4F34-BB57-8769D2C3205B/DA3ADC0F-DE5A-4BBA-AB38-4DFEB3FB8879_2/KoHtK6SmvdRG1r6PhGyNRKP55NFE7gRb2WjCeulixAkz/Image.heic" alt="Image"></p>
<p><img src="https://res.craft.do/user/full/acb27c06-6568-c1dc-2fad-17c27c23c9c1/doc/44D2BF19-40AC-4F34-BB57-8769D2C3205B/C76D786A-3B21-4626-9AC6-C006E5D3587A_2/ipOdWKogjNjcWx6xazmRItnBNw71IttkluR92qQLbXQz/IMG_0195.png" alt="IMG_0195.png"></p>
<p>然后你的电脑就可以访问外网了。可以去前面的测试网站测试一下。</p>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>翻墙</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32F407一般外设IO分配</title>
    <url>/2024/08/13/stm32f407-yin-jiao-fen-pei/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>stm32f407主要通信外设的io分配和复用预览。之前做工创赛整理的，又用AI处理了一下，方便查看。</p>
<h2 id="引脚复用一览"><a href="#引脚复用一览" class="headerlink" title="引脚复用一览"></a>引脚复用一览</h2><h3 id="串口-USART"><a href="#串口-USART" class="headerlink" title="串口 (USART)"></a>串口 (USART)</h3><table>
<thead>
<tr>
<th>USART</th>
<th>TX 引脚</th>
<th>RX 引脚</th>
<th>复用功能 (AF)</th>
</tr>
</thead>
<tbody><tr>
<td>USART1</td>
<td>PA9, PB6</td>
<td>PA10, PB7</td>
<td>AF7</td>
</tr>
<tr>
<td>USART2</td>
<td>PA2, PD5</td>
<td>PA3, PD6</td>
<td>AF7</td>
</tr>
<tr>
<td>USART3</td>
<td>PB10, PD8</td>
<td>PB11, PD9</td>
<td>AF7</td>
</tr>
<tr>
<td>UART4</td>
<td>PA0, PC10</td>
<td>PA1, PC11</td>
<td>AF8</td>
</tr>
<tr>
<td>UART5</td>
<td>PC12</td>
<td>PD2</td>
<td>AF8</td>
</tr>
<tr>
<td>USART6</td>
<td>PC6, PG14</td>
<td>PC7, PG9</td>
<td>AF8</td>
</tr>
</tbody></table>
<h3 id="定时器-TIM"><a href="#定时器-TIM" class="headerlink" title="定时器 (TIM)"></a>定时器 (TIM)</h3><table>
<thead>
<tr>
<th>定时器</th>
<th>通道</th>
<th>引脚</th>
<th>复用功能 (AF)</th>
</tr>
</thead>
<tbody><tr>
<td>TIM1</td>
<td>CH1</td>
<td>PA8</td>
<td>AF1</td>
</tr>
<tr>
<td>TIM1</td>
<td>CH2</td>
<td>PA9</td>
<td>AF1</td>
</tr>
<tr>
<td>TIM1</td>
<td>CH3</td>
<td>PA10</td>
<td>AF1</td>
</tr>
<tr>
<td>TIM1</td>
<td>CH4</td>
<td>PA11</td>
<td>AF1</td>
</tr>
<tr>
<td>TIM2</td>
<td>CH1</td>
<td>PA0, PA5</td>
<td>AF1</td>
</tr>
<tr>
<td>TIM2</td>
<td>CH2</td>
<td>PA1</td>
<td>AF1</td>
</tr>
<tr>
<td>TIM2</td>
<td>CH3</td>
<td>PA2</td>
<td>AF1</td>
</tr>
<tr>
<td>TIM2</td>
<td>CH4</td>
<td>PA3</td>
<td>AF1</td>
</tr>
<tr>
<td>TIM3</td>
<td>CH1</td>
<td>PA6, PB4</td>
<td>AF2</td>
</tr>
<tr>
<td>TIM3</td>
<td>CH2</td>
<td>PA7, PB5</td>
<td>AF2</td>
</tr>
<tr>
<td>TIM3</td>
<td>CH3</td>
<td>PB0, PC8</td>
<td>AF2</td>
</tr>
<tr>
<td>TIM3</td>
<td>CH4</td>
<td>PB1, PC9</td>
<td>AF2</td>
</tr>
<tr>
<td>TIM4</td>
<td>CH1</td>
<td>PB6, PD12</td>
<td>AF2</td>
</tr>
<tr>
<td>TIM4</td>
<td>CH2</td>
<td>PB7, PD13</td>
<td>AF2</td>
</tr>
<tr>
<td>TIM4</td>
<td>CH3</td>
<td>PB8, PD14</td>
<td>AF2</td>
</tr>
<tr>
<td>TIM4</td>
<td>CH4</td>
<td>PB9, PD15</td>
<td>AF2</td>
</tr>
</tbody></table>
<h3 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h3><table>
<thead>
<tr>
<th>I2C</th>
<th>SCL 引脚</th>
<th>SDA 引脚</th>
<th>复用功能 (AF)</th>
</tr>
</thead>
<tbody><tr>
<td>I2C1</td>
<td>PB6, PB8</td>
<td>PB7, PB9</td>
<td>AF4</td>
</tr>
<tr>
<td>I2C2</td>
<td>PB10, PF1</td>
<td>PB11, PF0</td>
<td>AF4</td>
</tr>
<tr>
<td>I2C3</td>
<td>PA8</td>
<td>PC9</td>
<td>AF4</td>
</tr>
</tbody></table>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><table>
<thead>
<tr>
<th>SPI</th>
<th>SCK 引脚</th>
<th>MISO 引脚</th>
<th>MOSI 引脚</th>
<th>NSS 引脚</th>
<th>复用功能 (AF)</th>
</tr>
</thead>
<tbody><tr>
<td>SPI1</td>
<td>PA5, PB3</td>
<td>PA6, PB4</td>
<td>PA7, PB5</td>
<td>PA4, PA15</td>
<td>AF5</td>
</tr>
<tr>
<td>SPI2</td>
<td>PB10, PB13</td>
<td>PC2, PB14</td>
<td>PC3, PB15</td>
<td>PB9, PB12</td>
<td>AF5</td>
</tr>
<tr>
<td>SPI3</td>
<td>PC10, PB3</td>
<td>PC11, PB4</td>
<td>PC12, PB5</td>
<td>PA4, PA15</td>
<td>AF6</td>
</tr>
</tbody></table>
<h3 id="CAN"><a href="#CAN" class="headerlink" title="CAN"></a>CAN</h3><table>
<thead>
<tr>
<th>CAN</th>
<th>TX 引脚</th>
<th>RX 引脚</th>
<th>复用功能 (AF)</th>
</tr>
</thead>
<tbody><tr>
<td>CAN1</td>
<td>PA12, PB9</td>
<td>PA11, PB8</td>
<td>AF9</td>
</tr>
<tr>
<td>CAN2</td>
<td>PB13</td>
<td>PB12</td>
<td>AF9</td>
</tr>
</tbody></table>
<h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><table>
<thead>
<tr>
<th>USB</th>
<th>引脚</th>
<th>复用功能 (AF)</th>
</tr>
</thead>
<tbody><tr>
<td>USB_FS</td>
<td>PA11 (DM), PA12 (DP)</td>
<td>AF10</td>
</tr>
<tr>
<td>USB_HS</td>
<td>PA11 (DM), PA12 (DP)</td>
<td>AF10</td>
</tr>
</tbody></table>
<h3 id="SDIO"><a href="#SDIO" class="headerlink" title="SDIO"></a>SDIO</h3><table>
<thead>
<tr>
<th>SDIO</th>
<th>引脚</th>
<th>复用功能 (AF)</th>
</tr>
</thead>
<tbody><tr>
<td>SDIO</td>
<td>PC8 (D0), PC9 (D1), PC10 (D2), PC11 (D3), PC12 (CLK), PD2 (CMD)</td>
<td>AF12</td>
</tr>
</tbody></table>
<h2 id="单片机引脚调用"><a href="#单片机引脚调用" class="headerlink" title="单片机引脚调用"></a>单片机引脚调用</h2><table>
<thead>
<tr>
<th>引脚</th>
<th>功能</th>
<th>引脚</th>
<th>功能</th>
<th>引脚</th>
<th>功能</th>
<th>引脚</th>
<th>功能</th>
<th>引脚</th>
<th>功能</th>
<th>引脚</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>PA0</td>
<td>编码器4-A</td>
<td>PB0</td>
<td></td>
<td>PC0</td>
<td></td>
<td>PD0</td>
<td></td>
<td>PE0</td>
<td></td>
<td>PF0</td>
<td></td>
</tr>
<tr>
<td>PA1</td>
<td>编码器4-B</td>
<td>PB1</td>
<td></td>
<td>PC1</td>
<td></td>
<td>PD1</td>
<td></td>
<td>PE1</td>
<td></td>
<td>PF1</td>
<td></td>
</tr>
<tr>
<td>PA2</td>
<td>2-TX</td>
<td>PB2</td>
<td></td>
<td>PC2</td>
<td></td>
<td>PD2</td>
<td>5-RX</td>
<td>PE2</td>
<td></td>
<td>PF2</td>
<td></td>
</tr>
<tr>
<td>PA3</td>
<td>2-RX</td>
<td>PB3</td>
<td>编码器1-B</td>
<td>PC3</td>
<td></td>
<td>PD3</td>
<td></td>
<td>PE3</td>
<td></td>
<td>PF3</td>
<td></td>
</tr>
<tr>
<td>PA4</td>
<td></td>
<td>PB4</td>
<td>编码器2-A</td>
<td>PC4</td>
<td></td>
<td>PD4</td>
<td></td>
<td>PE4</td>
<td></td>
<td>PF4</td>
<td></td>
</tr>
<tr>
<td>PA5</td>
<td>编码器1-A</td>
<td>PB5</td>
<td>编码器2-B</td>
<td>PC5</td>
<td></td>
<td>PD5</td>
<td></td>
<td>PE5</td>
<td>PWM7</td>
<td>PF5</td>
<td></td>
</tr>
<tr>
<td>PA6</td>
<td>PWM1</td>
<td>PB6</td>
<td>编码器3-A</td>
<td>PC6</td>
<td>6-TX</td>
<td>PD6</td>
<td></td>
<td>PE6</td>
<td>PWM8</td>
<td>PF6</td>
<td></td>
</tr>
<tr>
<td>PA7</td>
<td>PWM2</td>
<td>PB7</td>
<td>编码器3-B</td>
<td>PC7</td>
<td>6-RX</td>
<td>PD7</td>
<td></td>
<td>PE7</td>
<td></td>
<td>PF7</td>
<td></td>
</tr>
<tr>
<td>PA8</td>
<td></td>
<td>PB8</td>
<td>PWM3</td>
<td>PC8</td>
<td></td>
<td>PD8</td>
<td>MOTOR1-A</td>
<td>PE8</td>
<td></td>
<td>PF8</td>
<td></td>
</tr>
<tr>
<td>PA9</td>
<td>1-TX</td>
<td>PB9</td>
<td>PWM4</td>
<td>PC9</td>
<td></td>
<td>PD9</td>
<td>MOTOR1-B</td>
<td>PE9</td>
<td>PWM9_M1</td>
<td>PF9</td>
<td></td>
</tr>
<tr>
<td>PA10</td>
<td>1-RX</td>
<td>PB10</td>
<td>3-TX</td>
<td>PC10</td>
<td>4-TX</td>
<td>PD10</td>
<td>MOTOR2-A</td>
<td>PE10</td>
<td></td>
<td>PF10</td>
<td></td>
</tr>
<tr>
<td>PA11</td>
<td></td>
<td>PB11</td>
<td>3-RX</td>
<td>PC11</td>
<td>4-RX</td>
<td>PD11</td>
<td>MOTOR2-B</td>
<td>PE11</td>
<td>PWM10_M2</td>
<td>PF11</td>
<td></td>
</tr>
<tr>
<td>PA12</td>
<td></td>
<td>PB12</td>
<td></td>
<td>PC12</td>
<td>5-TX</td>
<td>PD12</td>
<td>MOTOR3-A</td>
<td>PE12</td>
<td></td>
<td>PF12</td>
<td></td>
</tr>
<tr>
<td>PA13</td>
<td></td>
<td>PB13</td>
<td></td>
<td>PC13</td>
<td></td>
<td>PD13</td>
<td>MOTOR3-B</td>
<td>PE13</td>
<td>PWM11_M3</td>
<td>PF13</td>
<td></td>
</tr>
<tr>
<td>PA14</td>
<td></td>
<td>PB14</td>
<td>PWM5</td>
<td>PC14</td>
<td></td>
<td>PD14</td>
<td>MOTOR4-A</td>
<td>PE14</td>
<td>PWM12_M4</td>
<td>PF14</td>
<td></td>
</tr>
<tr>
<td>PA15</td>
<td></td>
<td>PB15</td>
<td>PWM6</td>
<td>PC15</td>
<td></td>
<td>PD15</td>
<td>MOTOR4-B</td>
<td>PE15</td>
<td></td>
<td>PF15</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>和小宝在开封</title>
    <url>/2024/08/14/he-xiao-bao-zai-kai-feng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="去开封玩喽"><a href="#去开封玩喽" class="headerlink" title="去开封玩喽"></a>去开封玩喽</h1><hr>
<p>这是一次计划很久的见面</p>
<p>(这里的内容是不是不要密码<br>在封面就可以看到哇<br>就不让你看<br>保密)</p>
<p>自从小宝毕业后<br>小宝就不能天天黏着大宝了<br>突然多了些许的不适应<br>但也可能是毕业计划考证书<br>压力太大<br>很快投入了备考中<br>并且考点在郑州<br>这样还可以再见一面</p>
<p>有所期待<br>日子也便不难熬了</p>
<p>小宝和大宝也就八月份见了一面，还是因为小宝考试，由于时间原因，两个人也没有出去玩</p>
<p>时隔四个月<br>小宝终于结束了研究生考试<br>考完一身疲惫<br>腰疼的抵不住<br>在家休息一天<br>26 号出发<br>找大宝喽</p>
<p>这次我们选择去开封<br>开封之旅——回忆版</p>
<h1 id="2023-12-26"><a href="#2023-12-26" class="headerlink" title="2023-12-26"></a><strong>2023-12-26</strong></h1><p>小宝依旧早起赶大巴<br>六点五十抵达车站<br>出发~</p>
<p>到达开封就已经下午一点多啦<br>大宝也快到了<br>小宝站在原地等大宝打车过来<br>回到民宿收拾收拾</p>
<p>猜一猜<br>谁先亲亲的<br>嘿嘿</p>
<p>两点多出发吃好吃的啦<br>因为实在太饿了<br>在等饭的时候<br>大宝一直在和我分享他们比赛的事情<br>不得不说大宝老厉害了<br>给大宝点个赞赞</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723618357775.png" alt="开封菜"><br>包子好吃，菜就一般般啦<br>小宝记得最后没有吃完</p>
<p>不记得下午去干嘛了<br>估计去逛商场？买零食去了？<br>因为小宝记得那几天晚上都有吃零食和水果</p>
<h1 id="2023-12-27"><a href="#2023-12-27" class="headerlink" title="2023-12-27"></a><strong>2023-12-27</strong></h1><p>两个小懒猪 ，睡到大中午才起床，磨磨蹭蹭，快一点才出发，也是饿的不行了</p>
<p>大宝在美团上找呀找，终于找到了一家火锅店，可不是一般的火锅哦，是铜锅涮肉</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723618545653.png" alt="涮肉"><br>得到了大宝小宝的一致好评<br>肉香味很浓<br>量非常大<br>主打一个原汁原味<br>大宝小宝都吃撑了</p>
<h2 id="第一站：清明上河园"><a href="#第一站：清明上河园" class="headerlink" title="第一站：清明上河园"></a><strong>第一站：清明上河园</strong></h2><p>服了呀，小宝突然想起来，前一段时间，亲戚问小宝，去没去清明上河园<br>小宝说的没去<br>呜呜，其实去了，不过是白天去的，而且看起来和张择端的清明上河图不太一样，可能是身在其中感受不到吧</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723618831876.png" alt="门票"><br>清明上河园，我们来了<br>入园就是张择端手拿画卷的雕像<br>也是人们的打卡留恋区</p>
<p><strong>表演</strong><br>园区很大，由于是下午来的，很多表演都结束了，而且不知道具体位置，小宝和大宝就主打随意，毕竟重要的是过程，如果为了看表演而忽略了途中美景，忘记享受陪伴身边人就不好玩了</p>
<p>没走几步<br>就让大宝和小宝看见了表演<br>真是得来全不费功夫<br>==<em>斗鸡</em> #12AA9C==<br>猜猜是什么<br>当然是经典的<br>斗鸡！<br>然后围观群众下“赌注”<br>俩宝凑个热闹<br>也在猜哪个最厉害</p>
<p>不得不说<br>斗鸡这个表演<br>这几天的游玩中看到两三次了<br>==<em>战马</em> #12AA9C==<br>战马<br>就是做了很高大的机械马<br>有六到七个工作人员操作<br>他们穿的像刺客一样<br>很酷<br>==<em>舞狮子</em> #12AA9C==<br>好久没见舞狮子了<br>两只狮子<br>四个人<br>两两配合<br>在独立桩上跳来跳去<br>很佩服狮子下面的人<br>小宝和大宝一边吃薯片一边为他们呐喊<br>==<em>考状元</em> #12AA9C==<br>就是演员抽几个幸运观众<br>上台答题<br>然后选出状元<br>刚好碰上小学生研习<br>遇到一个小胖孩<br>黑黑的<br>长得太像大宝的朋友了<br>哈哈哈<br>==<em>击鼓</em> #12AA9C==<br>击鼓是最后的表演啦<br>刚好到出口的时候碰到的<br>敲鼓<br>转换队形<br>武枪<br>看起来很厉害<br>表情也很到位<br>看的小宝手痒痒<br>也想上去玩一会</p>
<p>但是这个时候已经六点了<br>冬天天黑的早<br>大宝小宝一圈走下来<br>脚都累痳了</p>
<p>准备出发找吃的了<br>哎哎哎，别急，看看小宝和大宝拍的美美照片</p>
<p><strong>快乐的痕迹</strong></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723619392564.png" alt="开心的小宝"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723619443873.png" alt="开心的大宝"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723620664582.png" alt="好像一位女诗人"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723620717330.png" alt="女诗人的小助理"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723620774975.png" alt="好开心呀"><br>美美哒</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723620843224.png" alt="正常的合照"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723620953647.png" alt="看什么看"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723620985305.png" alt="再看就把你吃掉"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723620868313.png" alt="吃到了！报吃"></p>
<p>STOP！<br>够了<br>真的饿了<br>觅食去</p>
<h2 id="第二站：河南大学西门夜市"><a href="#第二站：河南大学西门夜市" class="headerlink" title="第二站：河南大学西门夜市"></a><strong>第二站：河南大学西门夜市</strong></h2><p>人太多了，马家焖烤鸡腿的队排的老长了，大宝小宝分头行动，买了好多好吃的<br>回民宿喽</p>
<p>==突发事件 #CC5595==<br>小宝妈妈查岗<br>好在当时大宝小宝分头买吃的去了，小宝一个人应付过来了，问题不大</p>
<p>大宝导员查岗<br>晚上看电影的时候，大宝导员突然查寝，是的，大宝不在寝室，大宝直接硬气的说我现在通知你，我在外面玩。哈哈哈，太勇敢了</p>
<h1 id="2023-12-28"><a href="#2023-12-28" class="headerlink" title="2023-12-28"></a><strong>2023-12-28</strong></h1><h2 id="第三站：万岁山武侠城"><a href="#第三站：万岁山武侠城" class="headerlink" title="第三站：万岁山武侠城"></a><strong>第三站：万岁山武侠城</strong></h2><p>万岁山去的时候稍微有点晚，不知道俩宝在墨迹什么，再加上元旦前的装修，俩宝在万岁山没待多久，就只能在里面摸黑玩了，还碰到施工大队</p>
<p>里面有一个防空洞，虽然味道不太好，但是想象着自己背着枪，猫着背往前慢慢走<br>嘟嘟嘟</p>
<p>这里面没拍太多照片，但是万岁山里面拍的照片都可逗了，里面的主题是关于水浒传的</p>
<p>来欣赏一下照片片<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723624194562.png" alt="两手支球"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723624253179.png" alt="五指支球"><br>好好好，卷起来了<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723624303600.png" alt="俩短腿嘻嘻"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723624352486.png" alt="替天行道"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723624392403.png" alt="大宝"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723624433913.png" alt="要拔刀了"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723624461139.png" alt="小宝"></p>
<p>摸黑摸的头晕转向，但是氛围感超级足，走夜路，只靠月光，好像下一秒，就要入戏了，但是园区里面几乎剩下工作人员了<br>开溜</p>
<p>回来的路上去了兴盛德，买开封的特产：花生酥、桂花糕、花生米、菊花茶</p>
<h1 id="2023-12-29"><a href="#2023-12-29" class="headerlink" title="2023-12-29"></a><strong>2023-12-29</strong></h1><p>依旧是睡到中午才出发的俩宝<br>午饭是小区门口的槐店王婆大虾<br>好吃好吃，巨好吃<br>除了李想大虾<br>就是这家店了</p>
<h2 id="第四站：中国翰园碑林"><a href="#第四站：中国翰园碑林" class="headerlink" title="第四站：中国翰园碑林"></a><strong>第四站：中国翰园碑林</strong></h2><p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723623698584.png" alt="大宝"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723623770567.png" alt="小宝"><br>好吧好吧！小宝宣布，两张照片，大宝拍的完胜</p>
<p>进去啦<br>碑林里面大都是文字<br>俩宝浅作欣赏</p>
<p>还有一个假山<br>下山的时候<br>大宝像老头子<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723623630968.png" alt="老头下山"></p>
<p>看了那么多字体<br>俩宝也来露一手<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723623937259.png" alt="认真的小宝"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723623964797.png" alt="认真的大宝"><br>俩宝写的太好了，就不展示成果了<br>开溜，干饭去</p>
<p>吃烤肉，水浒传主题<br>评价：氛围感强、量一般般、好吃</p>
<p>晚上回来<br>大宝带小宝去打台球了，这是小宝第一次打台球，之前都是听大宝分享大宝在学校打台球的事情，终于小宝也可以玩咯</p>
<p>果然小宝天赋异禀<br>晚上总比分超过了大宝<br>耶<br>(其实是大宝在放水啦)</p>
<h1 id="2023-12-30"><a href="#2023-12-30" class="headerlink" title="2023-12-30"></a><strong>2023-12-30</strong></h1><p>小宝和大宝都是下午的车，于是吃完午饭，俩宝又去打台球了<br>小宝上瘾了</p>
<p>两个人掐好时间，掐点到车站，就是出租车没有把小宝送到门口，小宝一个人背个大书包，拎着两大包特产，挺着不争气的腰，吭哧吭哧才走到车站里面</p>
<p>但是这次开封游玩小宝很开心<br>拍了很多很多可爱、搞怪、开心的照片<br>还学会了打台球<br>（因为是回忆版）<br>小宝回家就教朋友打台球了<br>哈哈哈哈</p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>开封</tag>
      </tags>
  </entry>
  <entry>
    <title>和小宝在西安</title>
    <url>/2024/08/09/he-xiao-bao-zai-xi-an/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="去西安玩喽"><a href="#去西安玩喽" class="headerlink" title="去西安玩喽~"></a>去西安玩喽~</h1><hr>
<p>出发前小宝做的游玩攻略，原计划定在武汉，但是天气太热，于是改计划去了西安<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723215388540.png" alt="理想计划但实际不按此执行"></p>
<h2 id="2024-08-02"><a href="#2024-08-02" class="headerlink" title="2024/08/02"></a><strong>2024/08/02</strong></h2><p>出发喽<br>小宝：早起赶车，不幸家中停水，门口寻觅矿泉水，奈何店家还未开门，突然小宝灵机一动，来到了无人售货店，支持国产娃哈哈，随手一拿，双子天秤<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723215259884.png" alt="我们俩的星座暗示"><br>洗漱过后，打车未遂，又遇小雨、车车晚点，几经波折，怀着激动的心情，顺利踏上路程</p>
<p>此刻的大宝zzzzz</p>
<p>时间来到八点<br>熟睡的大宝醒来，赖床宝现身，趴在床上，撅着屁股，再和亲爱的小床来十分钟的告别</p>
<p>今天上午的主线任务<br>大宝：收拾行李（这个任务其实被大宝安排在昨天下午，但是大宝被迷人的代码和板子吸引走了，呜，不过没关系，时间还够，而且大宝还带了一次性四件套和牙刷哦，很乖）<br>小宝：抢陕西历史博物馆的门票（门票真的很难预约，两三分钟就没有了）</p>
<p>时间过得很快，小宝早在一点半就到了郑州南站，算好时间刚好在两点钟与大宝在郑州站见面</p>
<p>好激动哇</p>
<p>出了地铁口，大宝找小宝，小宝找大宝，果不其然，大宝玩找人的游戏一如既往的菜，嘿嘿，小宝老远就看到了大宝，小宝真厉害</p>
<p>‘嘿’<br>‘你从哪冒出来的’<br>‘你猜’</p>
<p>太热了<br>此地不宜久留<br>出发去酒店</p>
<p>大宝一到酒店就打小宝屁股，啪叽一声，呜呜呜</p>
<p>打闹一番开始收拾行李，铺上四件套，休息一下，出发找吃的</p>
<p>吐槽：王婆大虾不好吃</p>
<p>紧赶慢赶，顺利看到了一场电影《你的名字》<br>以前小宝看过一点点，但是有些场景让小宝看不下去，就放弃了，而大宝看过好多遍了，但是大宝和小宝决定去影院再看一次</p>
<p>大宝评价还是好好看<br>小宝评价烧脑子</p>
<h2 id="2024-08-03"><a href="#2024-08-03" class="headerlink" title="2024/08/03"></a><strong>2024/08/03</strong></h2><p>早起赶车啦</p>
<p>小宝第一次坐火车卧铺，下铺对面有个小屁孩很吵，睡不了一点，然后小宝就去找大宝，嘿，和大宝一起看《我们一起摇太阳》，无法代入，但也确实有些感人</p>
<p>火车呜呜跑着，进度条慢慢走着<br>’西安站到了，请下车的乘客提前收拾好行李，准备下车‘</p>
<p>西安的天气没有河南那么热，即便是在室外，迎面吹来的风也带有些许凉意（这是初到西安的感受，后面则要收回这些话，若不是大宝时间挑的刚刚好，来时正是西安雨停之日，否则也是烈日骄阳，步行于蒸笼之上。</p>
<p>来到民宿，大宝洗水果，小宝铺床，井然有序（假的，实则一片混乱）休息片刻，小宝和大宝便正式开启西安之旅</p>
<h3 id="第一站-回民街-高家大院"><a href="#第一站-回民街-高家大院" class="headerlink" title="第一站     回民街+高家大院"></a><strong>第一站</strong>     回民街+高家大院</h3><p>回民街，一条西安游玩攻略中必不可少的地方，特色美食很多，but，人也多<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723215414051.png" alt="人巨多"><br>放个图片浅浅感受一下<br>街的中间还有很多网红打卡地方<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723215442494.png" alt="宝子拍的龙"><br>不知道有什么历史或则故事赋予它，但是气势绝对是这次游玩中的No.1</p>
<p>回民街的尽头就是高家大院<br>入口挂着牌匾：榜眼及第<br>对于大宝、小宝这种，还是学生的人群来说，此地乃必游之处<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723215463111.png" alt="高家大院"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723215484029.png" alt="在中堂"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723215566105.png" alt="庭院"><br>小宝和大宝给彼此拍的照片</p>
<h3 id="第二站-钟楼-鼓楼"><a href="#第二站-钟楼-鼓楼" class="headerlink" title="第二站    钟楼+鼓楼"></a><strong>第二站</strong>    钟楼+鼓楼</h3><p>就不买门票上楼了，人太多了<br>合影一张，也算是来过了<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723215623505.png" alt="钟楼合影"></p>
<h4 id="美食篇"><a href="#美食篇" class="headerlink" title="美食篇"></a><strong>美食篇</strong></h4><p>逛了一晚上，大宝小宝都很饿，沿着回民街，转到小巷子，找到了几家提前计划好的烤肉店，but，人太多了，基本上每一家都要等半个小时以上，又热又渴的大宝小宝决定先去品尝一下西安的特色奶茶——茶话弄，一杯梅占摇红，一杯茯生半日闲，评价好喝，没有踩雷</p>
<p>等烤肉的过程是煎熬的，隔桌飘来的香味让人不停的咽口水，但是有大宝在，枯燥的等待也会变得有趣，小宝记得大宝那天和小宝聊了很多，小宝听得迷迷糊糊的，努力地转动小脑瓜子，才跟上大宝</p>
<p>西安的烤肉分为两种，一种刷酱，一种老三样，前一种吃起来都是酱香，而后一种则是肉味更浓，小宝和大宝吃的老三样，一个字香，八十块钱两人吃的饱饱的</p>
<p>此处小宝要评价一下冰峰，还以为是什么好喝的，原来就是健力宝呀，换个马甲新鲜多了</p>
<p>插播一条：小宝抢了好几次陕西历史博物馆的门票，都没有抢到，呜</p>
<h2 id="2024-08-04"><a href="#2024-08-04" class="headerlink" title="2024/08/04"></a><strong>2024/08/04</strong></h2><p>今天原计划上午去陕西历史博物馆，但是人太多，没有抢到票，于是决定多休息一会，再出发</p>
<p>上午大宝还给小宝拍了美美的照片，大宝拍照略显仓促，小宝妆造技术稍微不足，拍照设备不够傻瓜，最后成片并不多，浅放两张<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723215669899.png" alt="小宝可爱"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723215722306.png" alt="可爱小宝"></p>
<h3 id="第三站-大雁塔-大唐不夜城"><a href="#第三站-大雁塔-大唐不夜城" class="headerlink" title="第三站    大雁塔+大唐不夜城"></a><strong>第三站</strong>    大雁塔+大唐不夜城</h3><p>大雁塔是目前最早，规模最大的唐代四方楼阁式建筑，和之前看到的其他的塔不太一样，它是随着佛教传入中原地区的。</p>
<p>在大悦城四楼拍照留恋一下</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723215789086.png" alt="大雁塔与小宝"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723215825569.png" alt="大雁塔与大宝"><br>大唐不夜城，人很多，走的有点累，此处不再赘述，路上还咨询了华山的票，好巧不巧票卖完了</p>
<h4 id="美食篇-1"><a href="#美食篇-1" class="headerlink" title="美食篇"></a><strong>美食篇</strong></h4><p>长安大排档<br>新体验<br>没有拍照片，第一次吃羊血粉丝，还有一个金汤锅，里面的白菜好甜呀，大宝和小宝都吃的非常撑，晚上就买了两晚馄饨</p>
<h2 id="2024-08-05"><a href="#2024-08-05" class="headerlink" title="2024/08/05"></a><strong>2024/08/05</strong></h2><h4 id="美食篇-2"><a href="#美食篇-2" class="headerlink" title="美食篇"></a><strong>美食篇</strong></h4><p>小炒泡馍、羊汤泡馍、牛肉<br>感觉在吃面疙瘩，虽然小宝的小炒泡馍看起来比较好吃，但是是番茄味道的，有点腻；大宝的羊汤泡馍虽然尝起来没有味道，但是汤还是好喝的。牛肉蘸酱好吃！</p>
<h3 id="第四站-爬骊山"><a href="#第四站-爬骊山" class="headerlink" title="第四站      爬骊山"></a><strong>第四站</strong>      爬骊山</h3><p>骊山，换个名字吧，烽火台<br>是一个神奇的地方，大约三分之一的山路是平缓的，让人一度觉得so easy，小小骊山，和逛公园差不多，直到一个转角，所有到此的游客都一脸惊讶，口出国粹</p>
<p>妈妈告诉我：山的那边是海<br>但是山的那边还是山</p>
<p>大宝爬到烽火台累的不行，一直喘，一直喘<br>小宝厉害的不行，easy、easy</p>
<p>额(⊙o⊙)…大宝给小宝拍的照片，啊啊啊啊，一时间不知道该怎么评价，呜呜呜呜<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723215925627.png" alt="山顶与小宝"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723215988173.png" alt="山顶与大宝"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723216061110.png" alt="山顶留影"></p>
<h2 id="2024-08-06"><a href="#2024-08-06" class="headerlink" title="2024/08/06"></a><strong>2024/08/06</strong></h2><p>返程啦<br>大宝背着两个书包<br>一瘸一拐<br>车还晚点了，一直到凌晨两点多<br>两个人眼都睁不开了<br>这个时候西安已经开始下大雨了<br>还好时间完美错开<br>我们也要离开这座城市了</p>
<p>西安给小宝的印象<br>面食多<br>牛羊肉多<br>人也多<br>古装小姐姐多<br>吃的便宜<br>天气宜人<br>可能行程有些赶<br>可能门票很难抢<br>很多地方都没有预约到——人太多<br>很多好吃的也没有吃——胃太小<br>美中总有不足<br>但是一路有大宝陪伴<br>也便不觉着遗憾了</p>
<p>小宝第一次坐动车上铺<br>上去了不敢下来<br>但是想上厕所<br>于是早上六点下来了<br>结果不敢上去<br>只能在下面<br>等七点大宝醒来<br>看看大宝会不会下来<br>然后找大宝玩</p>
<p>终于到了七点<br>大宝说他要再睡一会<br>此刻的他还不知道发生了什么</p>
<p>小宝就在下面坐着<br>话说早起的鸟儿有虫吃<br>尽管下去了不敢上来<br>听起来挺可怜的<br>但是早起的风景是真的美<br>小宝不仅看到了日出<br>还看到了彩虹彩虹<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723216079408.png" alt="路上"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723216088842.png" alt="山隐"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723216097924.png" alt="日出"><br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723216106250.png" alt="彩虹"></p>
<h2 id="分开前的饭饭"><a href="#分开前的饭饭" class="headerlink" title="分开前的饭饭"></a><strong>分开前的饭饭</strong></h2><p>袁老四火锅<br>有一说一 ，菠萝饮品好喝的，火锅店夸饮品，那就不用说，锅底一般般啦<br>看大宝吹风，哈哈哈哈哈哈<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723216117040.png" alt="有一说一真的热"><br>一大盆菠萝饮品，以后自己做，好喝<br><img src="https://markdown.xiaoshujiang.com/img/spinner.gif" alt="好喝的" title="[[[1723216127081]]]"></p>
<p>吃饱饱回家喽</p>
<p>大宝回学校<br>小宝回家</p>
<p>在大巴出发前五分钟赶到车站</p>
<p>不得不说大宝真厉害<br>又是一个全新的体验</p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>西安</tag>
      </tags>
  </entry>
  <entry>
    <title>和小宝焦作两日游</title>
    <url>/2024/08/15/he-xiao-bao-jiao-zuo-liang-ri-you/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>小宝要去玩蹦床<br>大宝想去圆融寺<br>出发~</p>
<hr>
<h2 id="2023-04-04"><a href="#2023-04-04" class="headerlink" title="2023-04-04"></a>2023-04-04</h2><p>出去玩喽<br>俩宝又骑小电驴乱逛啦</p>
<p>去玩之前肯定要先吃饱呀<br>小龙坎火锅真的非常好吃，牛油很香，但是也非常的辣，大宝都窜稀了，还窜稀了三次<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723720066413.png" alt="勤劳的小宝"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723720148570.png" alt="不会用筷子的大宝"><br>吃饱饱去玩喽<br>小宝刷抖音看到了焦作蹦床，感觉好好玩啊<br>真实体验确实好玩，完了两个小时，很开心，也很累</p>
<p>大宝拿泡泡球砸小宝，小宝笑到没有力气还手，只留下了证据<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723719619471.png" alt="证据！"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723719677457.png" alt="小宝"><br>是不是感觉图片里小宝躺在那，很舒服，很好玩，很梦幻<br>实际上小宝屁股被小球梗的好疼，而且还站不起来，前面还有个大宝子拿小球砸小宝，小宝脸都笑疼了</p>
<p>玩了两个小时，回去倒床就睡着了，第二天起来浑身酸痛，呜呜呜</p>
<h2 id="2023-04-05"><a href="#2023-04-05" class="headerlink" title="2023-04-05"></a>2023-04-05</h2><p>今天计划去圆融寺哦<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723733057444.png" alt="冰封玫瑰"></p>
<p>出发前去蜜雪买了最近很火的冰封玫瑰<br>然后小宝记得是大宝骑小电驴带小宝去了一个超市，然后从超市打车过去的</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723731247892.png" alt="幸福的俩宝"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723731283787.png" alt="挂牌牌祈福"></p>
<p>大宝：愿我二人，平安如意、幸福长久<br>小宝补充：日进斗金</p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723731212929.png" alt="大宝逗猫"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723731113349.png" alt="大宝逗狗"></p>
]]></content>
      <categories>
        <category>快乐时光</category>
      </categories>
      <tags>
        <tag>-蹦床 -圆融寺</tag>
      </tags>
  </entry>
  <entry>
    <title>和小宝打雪仗</title>
    <url>/2024/08/15/he-xiao-bao-da-xue-zhang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>第一次和小宝打雪仗</p>
<hr>
<h1 id="2023-03-16"><a href="#2023-03-16" class="headerlink" title="2023-03-16"></a>2023-03-16</h1><p>下雪啦<br>大宝和小宝第一次一起看雪，下雪那天两个人都很激动，约着一起出去看雪。<br>但是天气太冷了，就买了两杯益禾堂暖暖手，嘿嘿，好喝</p>
<p> 可是小宝真的不好意思出门<br> 是怕冷吗，不是的<br> 是臭大宝，呜呜呜，臭大宝在小宝额头正中间吸了个草莓，啊啊啊啊<br> 好几天不敢见人，室友问小宝的时候，小宝就说走路磕着柱子了，唉，大家居然都相信了，后面小宝出门还调侃小宝不要总是低头看手机，呼</p>
<p> 怎么出门呢，小宝打算在自己头上花个花，结果也没有花好，就这样吧，一会看照片就知道了，臭大宝</p>
<p> 下雪后的学校显得非常安静，也非常美丽，听雨林里面还有很多盛开的花<br> <img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723716890525.png" alt="雪后的校园"></p>
<p> 还记得这个湖嘛<br> 吐冰糖葫芦籽的那个，嘿嘿，嘟嘟嘟嘟，像植物大战僵尸里面的豌豆射手<br> 下过雪之后是不是很美<br> <img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723717694071.png" alt="截屏"><br> <img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723717719131.png" alt="加一"></p>
<p> <img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723716939895.png" alt="还没有准备好的小宝"><br> 吐槽一下这个照片，为什么放这个，因为找了一圈，这个还能看。大宝拍照就一顿咔咔拍，小宝姿势还没有摆好</p>
<p> 有时候是小宝姿势还没有摆好就拍了；有时候是摆好了但是也不和小宝说哪里需要调整；有时候小宝姿势摆好了大宝调设备又调好久，害<br> <img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723716965982.png" alt="馋嘴大宝"><br> <img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723717499766.png" alt="捡橘子吗？"></p>
<p> <img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723717542524.png" alt="欺负小宝"><br> <img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723717569057.png" alt="证据"></p>
<p> 俩宝冻得缩着头，但是是一次新体验，俩宝玩得很开心</p>
]]></content>
      <categories>
        <category>快乐时光</category>
      </categories>
      <tags>
        <tag>下雪</tag>
      </tags>
  </entry>
  <entry>
    <title>和小宝逛人民公园</title>
    <url>/2024/08/15/he-xiao-bao-guang-ren-min-gong-yuan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr>
<h2 id="2023-03-08"><a href="#2023-03-08" class="headerlink" title="2023-03-08"></a><strong>2023-03-08</strong></h2><p>今天和大宝一起出校玩喽<br>在学校大宝和小宝有个小电驴<br>大宝经常带小宝乱串</p>
<p>今天去焦作人民公园玩</p>
<p>入园门口有好多好多好吃的小摊<br>现榨甘蔗、烤鹌鹑蛋等等<br>大宝买了两串鹌鹑蛋<br>吃起来还不错哦<br>小宝在一旁拿手机拍大爷榨甘蔗<br>试图证明手机和自己的拍照技术还不赖<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723706338774.png" alt="往后余生"></p>
<p>好了，你可能会想，这高低得来两杯吧<br>不，并没有<br>俩宝被旁边的椰子吸引到了<br>所以喽，俩宝捧着俩椰子进去了<br>还碰到老奶奶问价格，嘿<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723706584718.png" alt="小宝比耶"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723706685316.png" alt="大宝装高冷"><br>哦，为什么俩宝要来人民公园呢<br>当然是这个季节开了好多花花呀<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723706719375.png" alt="白色"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723706739861.png" alt="粉色"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723707214416.png" alt="淡粉色"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723707238398.png" alt="大红色"><br>不一会大宝小宝又绕到了一个小园子<br>这个场地是用来打太极的，焦作特色<br>小园子门口停了一辆自行车，挂着彩色气球，很美，但说不上来，复古的美感<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723706942686.png" alt="松弛又精致"></p>
<p>当然作为焦作还能推荐一游的人民公园不仅仅只有花哦<br>公园里大爷们围在桌边打牌，阿姨奶奶们则在组团跳舞啦，孩子们则乐趣多多<br>野餐、散步、跳舞、打牌、休息、听书……<br>公园里还有喂鸽子的地方、还有游乐场<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723707504661.png" alt="喂鸽子"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723707525410.png" alt="摩天轮"><br>大宝小宝都不是小孩子了<br>俩宝是成熟的大人，俩宝不玩小屁孩玩的东西<br>散散步、吃吃零食、拍拍照片、嬉闹一番，能陪伴彼此就是最快乐的啦<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723707859977.png" alt="小宝和花花"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723707882170.png" alt="小宝教的拍照角度"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723707910466.png" alt="大宝和小宝"></p>
<p>晚饭大宝和小宝去吃了姐弟俩土豆粉，味道还不错哦，小宝点了被带有小冰熊的饮料，可爱极了</p>
<p>俩宝吃完饭饭，骑车兜风回去喽</p>
<p>THE END</p>
<p>等等等，你以为这就完了吗，还没有，嘿嘿（偷笑）</p>
<h2 id="2024-4-1"><a href="#2024-4-1" class="headerlink" title="2024-4-1"></a><strong>2024-4-1</strong></h2><p>没错，小宝和大宝又回来了。咦，24年小宝不是毕业了嘛，是的呀，小宝昨天上午复试完就飞奔焦作找大宝啦<br>大宝脚丫子不太方便走远，所以俩宝又来了人民公园，只是这次俩宝没有小电驴了。俩宝打车到一个小门，从小门进去的。</p>
<p>公园里还是老样子<br><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723708505929.png" alt="落花"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723708535688.png" alt="新风格"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723708556192.png" alt="小宝"></p>
<p><img src="https://biubiu-1319563496.cos.ap-nanjing.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1723708600789.png" alt="大宝和小宝"><br>故地重游的俩宝，一个变可爱了，一个变美丽了，哈哈哈哈哈</p>
]]></content>
      <categories>
        <category>快乐时光</category>
      </categories>
      <tags>
        <tag>公园</tag>
        <tag>游玩</tag>
      </tags>
  </entry>
</search>
